#!/usr/bin/perl

############################################################################
###
### Copyright Avaya Inc., All Rights Reserved.
### THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF Avaya Inc.
###
### The copyright notice above does not evidence any actual or intended
### publication of such source code.
###
### Some third-party source code components may have been modified from
### their original versions by Avaya Inc.
### The modifications are Copyright Avaya Inc., All Rights Reserved.
###
############################################################################

local $SIG{__WARN__} = sub {
  # ignore warnings as they still appear in a MAC
};
no if ($] >= 5.018), 'warnings' => 'experimental::lexical_topic';

use POSIX;
#use Getopt::Long;
use Getopt::Long qw(GetOptionsFromString);
use Term::ANSIColor;
use Term::Cap;
use threads;
use threads::shared;
use Fcntl qw(:flock);
use List::Util qw[min max];
use IO::Handle;
use Sys::Hostname;
use File::Basename;
use File::stat;
use DirHandle;
use Time::Local;
#use Time::HiRes qw ( time alarm sleep );
#no warnings 'threads';
#use Net::SSH::Expect;
use Config;

# Global Variables
my $dg_column_width: shared;
$dg_column_width = 12;
$dg_top_margin = 4;
$cl_top_margin = 3;
$min_row = 10;
$min_col = 80;
$max_packets = 10000;
$trace_dir = "/var/log/Avaya/trace/";
$to_archive_trace_dir = "/var/log/Avaya/trace/";
if(is_sip_file_based_log_running()) {
  $to_archive_trace_dir = "/var/log/Avaya/sip_trace/";
}
$sm_conf_dir = "/var/log/Avaya/sm/conf/";
$sm_conf_dir = "/opt/Avaya/Common/conf/" if ! -w "$sm_conf_dir/log4j.properties";
%log_file = (
  sm => "call_proc.log",
  asset => "tracer_asset.log",
  tls => "tls_handshake.log",
  ppm => "trace_ppm.log",
  push_notification => "pushnotification.log",
);
$sip_file_based_log_dir="/var/log/Avaya/sip_trace/";
$sip_file_based_log_filename= "$sip_file_based_log_dir"."sip_trace.log";
$audit_log_file = "traceSM_audit.log";
$asset_dir = "/opt/Avaya/asset/packages/active-version/bin/";
$asset_lib = "LD_LIBRARY_PATH=/opt/Avaya/asset/packages/active-version//lib";
$asset_trace_command = "$asset_dir/soapClientUpdateSipTracer";
$asset_net_command = "$asset_lib $asset_dir/soapClientGetNetParam";
$asset_getap_command = "$asset_lib $asset_dir/soapClientGetAP";
$enable_asset_trace = "$asset_lib $asset_trace_command 1 1 1 1 1 1 0 syslog 0 0 0 0";
$disable_asset_trace = "$asset_lib $asset_trace_command 0 1 1 1 1 1 0 syslog 0 0 0 0";
$get_asset_trace = "$asset_lib $asset_dir/soapClientGetSipTracer";
$commit_asset_trace = "$asset_lib $asset_dir/soapClientCommit TRACER";
$sip_stats_file = "/var/avaya/perfdata/csv/siptotal/siptotal.csv";
$asset_addinfo_command = "$asset_dir/addAssetNetInfo.sh";
$jboss_cli_script = "/opt/Avaya/Common/bin/jboss-logging-cli.sh";
@ppm_logging_pkg = (
  "com.avaya.ccs.ppm.ws.jdom.support.SchemaHelper",
  "com.avaya.ccs.ppm.app.auth.impl.ASM_PPMAuthHandler",
);
 
%ims_phase = qw(originating orig imsorig imsorig origdone origdone imsterm imsterm internal_terminating intterm terminating term termdone termdone endpoint endpoint);

# Use the TMP file for debugin to print to the TMP file instead of screen
# open(TMP,'+>', "/tmp/debug_traceSM.txt");
# TMP->autoflush(1);
# sleep 1;

# Shared Variables
my $uri: shared;
my $host_ip: shared;
my $contain_regex: shared;
my $sip_retain: shared;
my $or: shared;
my $call_id: shared;
my $push_user: shared;
my $global_session_id: shared;
my $gsi_call_id: shared;
my $header_value: shared; 
my $no_register: shared;
my $no_subscribe: shared;
my $no_options: shared;
my $no_asm: shared;
my $no_ppm: shared;
my $no_database: shared;
my $no_pingpong: shared;
my $no_push: shared;
my $need_resize: shared;
my $asm_ip: shared;
my $asm_ipv6: shared;
my $sm100_ip: shared;
my $sm100_ipv6: shared;
my $show_asm: shared;
my $dg_rec_pos: shared;
my $prev_dg_rec_pos: shared;
my $dg_col_pos: shared;
my $prev_dg_col_pos: shared;
my $dg_top_pos: shared;
my $prev_dg_top_pos: shared;
my $max_row: shared;
my $max_col: shared;
my $display_mode: shared;
my $capture_mode: shared;
my $prev_display_mode: shared;
my $status_bar_mode: shared;
my $status_bar_mode_color: shared;
my $status_bar_keys: shared;
my $prev_dg_column_no: shared;
my $prev_dg_record_no: shared;
my $tail_log: shared;
my $max_exceeded: shared;
#my $sipas_dir: shared;
my $display_asm: shared;
my $display_name: shared;
my $display_rtp: shared;
my $multiple_instances: shared;
my $cl_top_pos: shared;
my $cl_rec_pos: shared;
my $cl_view: shared;
my $prev_cl_rec_pos: shared;
my $prev_cl_top_pos: shared;
my $cl_need_refresh: shared;
my $last_timestamp: shared;
my $current_sip_record: shared;
my $current_asm_record: shared;
my $current_ppm_record: shared;
my $processing_initial_queue: shared;
my $is_real_time: shared;
my $quit: shared;
my $is_old_cygwin: shared;
my $is_new_cygwin: shared;
my $is_mac: shared;
my $no_tls: shared;
my $current_tls_record: shared;
my $current_push_record: shared;
my $goto_search: shared;
my $search_header_msg: shared;
my $version: shared;
my $psql_cmd: shared;
my $fetch_ppm_log_level: shared;
my $saved_ppm_log_level: shared;
my $status_sip_req: shared;
my $status_ppm_req: shared;
my $status_asm_req: shared;
my $status_tls_req: shared;
my $start_sip_req: shared;
my $start_ppm_req: shared;
my $start_asm_req: shared;
my $start_tls_req: shared;
my $stop_sip_req: shared;
my $stop_ppm_req: shared;
my $stop_asm_req: shared;
my $stop_tls_req: shared;

if (-f "/bin/mgmtia") {
  $psql_cmd = "mgmtia"; # Starting on 7.1, the psql command is now mgmtia
} else {
  $psql_cmd = "psql";
}

share(@dg_records);
share(@queue_sip_records);
share(@queue_asm_records);
share(@queue_ppm_records);
share(@queue_tls_records);
share(@queue_push_records);
share(@display_dg_records);
share(%calls);
share(%apns_tx);
share(%tls_streams);
share(%sessions);
share(%call_summary);
share(%dg_columns);
share(%sipentity_ip);
share(%sipentity);
share(%routingorigination);
share(%sipdomain);
share(%digitmap);
share(%routingpolicy);
share(%name_ip);
share(%contact_ip);
share(%rtp);
share(@cl_column_width);
share(@display_cl_record);
share(@cl_colum_name);
share(@cl_colum_keys);
share(@cl_column_width_max);
share(@cl_column_width_min);
share(%capture_filter_call);
share(%contain_regex_callid);
set_start_capture_time();

$fetch_ppm_log_level = 1;
$new_tmp_dir = "";

$is_real_time = 1;
# Check if running under Cygwin or MAC
$is_old_cygwin = $Config{osname} eq "cygwin";
$is_mac = $Config{osname} eq "darwin";
eval { require 'sys/ioctl.ph' };
if ( $@ and $is_old_cygwin) {
  # Older versions of Cygwin (< 1.7.x) used the termcap package, newer versions uses the terminfo
 
  my $cygwin_version = `uname -r`;
  # Check for old Cygwin (< 1.7.x) 
  if ($cygwin_version =~ /^1\.[0-6]\..*/) { # Old Cygwin
    first_time_cygwin_old_install();
  } else {                                  # New Cygwin
    $is_old_cygwin = 0;
    $is_new_cygwin = 1; 
  }
}

$quit = 0;
# Read the command line options
$all_command_args = join(" ", @ARGV);
$options_result = GetOptions('u=s' => \$uri, 'i=s' => \$host_ip, 'c=s' => \$call_id, 'pu=s' => \$push_user, 's=s' => \$global_session_id, 'g=s' => \$header_value, 'or' => \$or, 'h' => \$help, 'nr' => \$no_register, 'ns' => \$no_subscribe, 'no' => \$no_options, 'na' => \$no_asm, 'nd' => \$no_database, 'ni' => \$no_pingpong, 'uni' => \$unicode, 'nouni' => \$no_unicode, 'a' => \$show_asm, 'r' => \$display_rtp, 'np' => \$no_ppm, 'nu' => \$no_push, 'nt' => \$no_tls, 'm' => \$multiple_instances, 'max=s' => \$max_packets, 'k' => \$kill_others, 'sc=s' => \$sip_retain, 'o=s' => \$contain_regex, 'dt' => \$throttle, '<>' => \&push_file, 'startsip' => \$start_sip_req, 'starttls' => \$start_tls_req, 'startasm' => \$start_asm_req, 'startppm' => \$start_ppm_req, 'statussip' => \$status_sip_req, 'statusppm' => \$status_ppm_req, 'statusasm' => \$status_asm_req, 'statustls' => \$status_tls_req, 'stopsip' => \$stop_sip_req, 'stopppm' => \$stop_ppm_req, 'stoptls' => \$stop_tls_req, 'stopasm' => \$stop_asm_req);

$version = "8.1.3.2.001"; # traceSM version
if ($help || !$options_result) {
  print "traceSM V$version\n\n";
  print "Usage: traceSM [-startsip] [-startppm] [-starttls] [-stopasm] [-stopsip] [-stopppm] [-stoptls] [-stopasm] [-statussip] [-statusppm] [-statustls] [-statusasm] [-h] [-u <URI|NUMBER>] [-i <IP>] [-c <CALL-ID>] [-s <GSID>] [-g <HEA>=<VALUE>] [-o <REGEX>] [-or] [-nr] [-ns] [-no] [-na] [-np] [-nt] [-nd] [-nu] [-uni] [-nouni] [-a] [-r] [-m] [-max] [-k] [-sc <NUM_FILES>] [<LOG_FILE>...]\n\n";
  print "  Where:\n";
  print "     -startsip        Start SIP tracing in background\n";
  print "     -stopsip         Stop SIP tracing\n";
  print "     -statussip       Check status of SIP tracing\n";
  print "     -starttls        Start TLS tracing in background\n";
  print "     -stoptls         Stop TLS tracing\n";
  print "     -statustls       Check status of TLS tracing\n";
  print "     -startppm        Start PPM tracing in background\n";
  print "     -stopppm         Stop PPM tracing\n";
  print "     -statuspppm      Check status of PPM tracing\n";
  print "     -startasm        Start ASM/CALLP tracing in background\n";
  print "     -stopasm         Stop ASM/CALLP tracing\n";
  print "     -statusasm       Check status of Stop ASM/CALLP tracing\n";
  print "     -u <URI|NUMBER>  Filter calls that contain <URI|NUMBER> in the 'From' or\n";
  print "                      'To' field.\n";
  print "     -i <IP>          Filter SIP messages from/to <IP> address.\n";
  print "     -c <CALL-ID>     Filter based on the SIP 'Call-ID' header field.\n";
  print "     -s <GSID>        Filter based on the SIP 'Av-Global-Session-ID' header.\n";
  print "     -g <HEA>=<VALUE> Filter SIP packets with header field <HEA> and \n";
  print "                      value <VALUE>.\n";
  print "     -o <REGEX>       Filter SIP sessions that contain <REGEX> on any part\n";
  print "                      of the SIP message. If the matching message has\n";
  print "                      previously captured message, you need to reapply\n";
  print "                      the filter to display all the messages for that Call-ID\n";
  print "     -pu <USER>       Filter PUSH NOTITIFICATION  messages based on USER\n";
  print "     -or              Use a logical OR operator instead of the implicit\n";
  print "                      AND when using multiple filter options.\n";  
  print "     -nr              Do not display REGISTER messages.\n";
  print "     -ns              Do not display SUBSCRIBE/NOTIFY messages.\n";
  print "     -no              Do not display OPTIONS messages.\n";
  print "     -na              Do not display SM Call processing messages.\n";
  print "     -np              Do not display PPM messages.\n";
  print "     -nt              Do not display TLS messages.\n";
  print "     -nu              Do not display TLS messages.\n";
  print "     -nd              Do not lookup the Postgres DB to resolve names (Locations,\n";
  print "                      SIP Entities, Route Patterns, etc.)\n";
  print "     -ni              Do not display SIP PING/PONG messages (RFC5626)\n";
  print "     -uni             Use Unicode/UTF-8 characters. Display the arrows and other\n";
  print "                      lines in 'graphic' mode. Your terminal client has to\n";
  print "                      support Unicode to display this correctly. For example,\n";
  print "                      PuTTY using unicode fonts (like 'Lucida Console').Default is on.\n";
  print "     -nouni           Disable Unicode/UTF-8 characters.\n";
  print "     -a               Display internal SIP messages between SM100 and SM.\n";
  print "     -r               Display the RTP simulation. This is not based on the actual\n";
  print "                      RTP packets but using just the SDP content.\n"; 
  print "     -m               Allows to run multiple instances of traceSM. Do not use\n";
  print "                      this option in a production system as it may cause \n";
  print "                      performance issues.\n"; 
  print "     -max <NUM_MSG>   Limit the number of captured message in memory to <NUM_MSG>\n";
  print "                      By default this value is $max_packets. Extending the default\n";
  print "                      could cause performance issues (CPU and Memory). Do not use\n";
  print "                      this option in a production system\n"; 
  print "     -k               Kill other traceSM instances.\n"; 
  print "     -sc <NUM_FILES>  Change the number of SIP files (tracer_asset.log) to retain.\n"; 
  print "                      Default is 60, changing this will persist so make sure to put\n"; 
  print "                      it back as needed. Files rotate every minute when they are\n"; 
  print "                      over 20MB, but under heavy traffic each file could be larger.\n";
  print "                      Make sure there is enough disk space.\n";
  print "     <LOG_FILE>       One or more files previously captured with traceSM.\n";
  print "                      traceSM automatically detects the file format for:\n";
  print "                        - Call Processing (e.g. call_proc.log)\n";
  print "                        - SIP (e.g. tracer_asset.log)\n";
  print "                        - TLS (e.g. tls_handshake.log)\n";
  print "                        - PPM (e.g. trace_ppm.log)\n";
  print "                        - The .tgz generated by traceSM\n";
  print "                      If no file is specified, then you can start/stop the \n";
  print "                      capture using the 's' key.\n";
  print "                      OneX Communicator SIP log file (e.g. SIPMessages.txt) could be\n";
  print "                      open with traceSM as well.\n\n";
  print "  The Filter options can take a regular expression. Filters are also available\n";
  print "  by pressing 'f' in the application.\n\n";
  print "  WARNING: traceSM may use high CPU and memory in a busy Session Manager. traceSM\n";
  print "           stops displaying packets if captured $max_packets packets\n\n";
  print "  Usage examples:\n";
  print "    To start a new capture, run 'traceSM' without arguments and then press 's':\n";
  print "       \$ traceSM\n"; 
  print "    To filter SIP messages from/to 1.1.1.1 and 2.2.2.2:\n";
  print "       \$ traceSM -i \"1.1.1.1|2.2.2.2\"\n";
  print "    To analyze previously captured files named call_proc.log and tracer_asset.log:\n";
  print "       \$ traceSM call_proc.log tracer_asset.log\n";
  print "    To filter SIP messages containing 'Avaya' in the 'User-Agent' header field:\n";
  print "       \$ traceSM -g \"User-Agent=Avaya\"\n";
  print "    To filter SIP sessions that got a '487 Request Terminated' response:\n";
  print "       \$ traceSM -o \"487 Request Terminated\"\n";
  print "\n";
  exit;
}

if ($is_mac or $is_old_cygwin or $is_new_cygwin) {
  $no_database = 1;
  # always set throttling off when running in cygwin
  $throttle=true;
  # always enable unicode
  $unicode=true;
}

sub push_file {
  my $filename = shift @_;

  $is_real_time = 0;
  # Check if they are providing the .tgz file
  if ($filename =~ /^.*\.tgz$/) {
    $new_tmp_dir = `mktemp -d --tmpdir=.`;
    chop($new_tmp_dir);
    print "Extracting $filename to tmpdir $new_tmp_dir\n";
    $result = `tar xzvf "$filename" --exclude="*.pcapng"  -C $new_tmp_dir 2>/dev/null`;
    chop($result);
    # Prompt if the user wants to open the unfiltered logs
    if ($result =~ /unfiltered_since_start\/logs\.tgz/) {
      print "\n";
      print "The .tgz file contains unfiltered logs since the beginning of the capture.\n";
      print "Do you want to open those files instead of the filtered SIP messages? (Y/N): ";
      chomp(my $answer = <STDIN>);
      if (lc($answer) eq "y" || lc($answer) eq "yes") {
        $result = `cd $new_tmp_dir/unfiltered_since_start;tar xzvf logs.tgz`;chop($result);
        for (split /^/, $result) {
          chomp($_);
          # skip the traceMessage_audit.log
#          next if $_ eq "traceMessage_audit.log";

          # Add the file
          push_file("$new_tmp_dir/unfiltered_since_start/$_");
        }
        return;
      }
    } 
    # remove the unfiltered_since_start and unfiltered_all
    $result =~ s/^unfiltered_since_start\/logs.tgz$//m;
    $result =~ s/^unfiltered_all\/logs.tgz\n$//m;
    $result =~ s/\n$//;
    #chop($result);
    
    my $nr_of_lines = $result =~ tr/\n//;
    if ($result eq "") {
      print "ERROR: Could not open $filename\n";
      exit;
    } elsif ($nr_of_lines > 0) {
      print "ERROR: Multiple non-pcapng files in $filename\n";
      exit;
    }
    $filename = "$new_tmp_dir/$result";
  }

  $type = file_type($filename);
  #print TMP "$type\n";
  if ($type eq "asm") {
    push(@asm_files,$filename);
  } elsif ($type eq "asset") {
    push(@asset_files,$filename);
  } elsif ($type eq "onexc" || $type eq "ios") {
    push(@onexc_files,$filename);
  } elsif ($type eq "tls") {
    push(@tls_files,$filename);
  } elsif ($type eq "push") {
    push(@push_files,$filename);
  } else {
    push(@ppm_files,$filename);
  }
#  $is_real_time = 0; 
}

##################  Main program ##############################

start_audit();

# If user requested to start captures in backgound, then start them
# and immediately exit the program
if($start_sip_req && $stop_sip_req) {
  print "startsip and stopsip options can not be used at the same time.\n";
  exit; 
} else {
  if($start_sip_req) {
    start_asset_capture_cmd();
    $status_sip_req = 1;
    audit("Starting capture for SIP");
  } elsif ($stop_sip_req) {
    stop_asset_capture_cmd();
    $status_sip_req = 1;
    audit("Stopping capture for SIP");
  }
  if($status_sip_req == 1) {
    print "SIP Tracer: ";
    print is_asset_capture() ? "Started\n" : "Stopped\n";
  }
}

if($start_ppm_req && $stop_ppm_req) {
  print "startppm and stopppm options can not be used at the same time.\n";
  exit;
} else {
  if($start_ppm_req) {
    start_ppm_capture_cmd();
    $status_ppm_req = 1;
    audit("Starting capture for PPM");
  } elsif ($stop_ppm_req) {
    stop_ppm_capture_cmd();
    $status_ppm_req = 1;
    audit("Stopping capture for PPM");
  }
  if($status_ppm_req == 1) {
    print "PPM Tracer: ";
    print is_ppm_capture() ? "Started\n" : "Stopped\n";
  }
}

if($start_asm_req && $stop_asm_req) {
  print "startasm and stopasm options can not be used at the same time.\n";
  exit;
} else {
  if($start_asm_req) {
    start_sm_capture_cmd();
    $status_asm_req = 1;
    audit("Starting capture for CALLP");
  } elsif($stop_asm_req) {
    stop_sm_capture_cmd();
    $status_asm_req = 1;
    audit("Stopping capture for CALLP");
  }
  if($status_asm_req == 1) {
    print "ASM Tracer: ";
    print is_sm_capture() ? "Started\n" : "Stopped\n";
  }
}

if($start_tls_req && $stop_tls_req) {
  print "starttls and stoptls options can not be used at the same time.\n";
  exit;
} else {
  if($start_tls_req) {
    audit("Starting capture for TLS");
    if(1 == start_tls_capture_cmd()) {
      print "TLS tracing failed to start. Thsark is missing. Please install tshark and try again.\n";
    }
    $status_tls_req = 1;
  } elsif($stop_tls_req) {
    stop_tls_capture_cmd();
    $status_tls_req = 1;
    audit("Stopping capture for TLS");
  }
  if($status_tls_req == 1) {
    print "TLS Tracer: ";
    print is_tls_capture() ? "Started\n" : "Stopped\n";
  }
}

if($start_sip_req || $stop_sip_req  || $status_sip_req
   || $start_ppm_req || $stop_ppm_req || $status_ppm_req 
   || $start_tls_req || $stop_tls_req || $status_tls_req
   || $start_asm_req || $stop_asm_req || $status_asm_req) {
  print "Timestamp: ";
  print `date`;
  audit("---------------- traceSM close ----------------");
  exit;
}

# Set lower priority (nice 19) to this process to not take much CPU
if (!($throttle)) {
  setpriority(0,0,19);
}

# Validate command line arguments
validate_cmd_line();

# Init TLS lines to remove
init_tls_line_remove();

# Set the characterset for normal or unicode
set_characterset();

# Create the color table for the arrows
create_color_table();

# Initiate the screen (terminal mode and keyboard)
init_screen();

# Update the window title
set_title();

# Initiate the IPv6 regular expression pattern
init_regex_IPv6();

# Catch the "Windows change" signal (terminal window resize)
$SIG{'WINCH'} = \&terminal_resize;

# Catch the signals, so we graceful shutdown the program
$SIG{'INT'} = $SIG{'HUP'} = $SIG{'KILL'} = $SIG{'PIPE'} = $SIG{'TERM'} = \&die_message;

$asm_ip = "uknown";
$asm_ipv6 = "uknown v6";
$sm100_ip = "uknown";
$sm100_ipv6 = "uknown v6";

# Init the display name to show names in the columns
$display_name = 1;

# Init the display RTP to not show the simulated RTP
if ($display_rtp) {
  $display_rtp = 1;
} else {
  $display_rtp = 0;
}

$prev_display_mode = "diagram";
$display_mode = "opening file";
$processing_initial_queue = 1;

if ($is_real_time) {
  if ($is_old_cygwin or $is_new_cygwin or $is_mac) {
    end_screen();
    print "ERROR: Running under ".($is_mac ? "MAC" : "Cygwin").". Please specify the file to open.\n";
    exit;
  }
  real_time_capture();
} else {
  open_provided_capture_files();
}

audit("---------------- traceSM close ----------------");
exit;
##################  End Main  ##############################


sub real_time_capture {
  # Set the SM eth0 and eth1 (asset) IPs
  set_sm_ips_real_time();

  # If the user did not specify any file to decode, then decode the asm.log and tracer_asset.log
  get_logs();

  # Process the file(s)
  $tail_log = 1;
  $max_exceeded = 0;
  $display_asm = -1;
  my $asm_file = "";
  my $asset_file = "";

  foreach $f (@asm_files) {
    open(ASM_FILE, "$f") || die_message("Can't open $f file.\nERROR: $!\n");
    seek(ASM_FILE, 0, SEEK_END);
    $asm_file = $f;
  }

  foreach $f (@asset_files) {
    # SIP messages can contain unicode characters encoded in UTF-8. To display 
	# those unicode characters open tracer_asset files in UTF-8 mode. For any
	# reason if file can not be opened in UTF-8 mode, failback to traditional 
	# way.
    open(ASSET_FILE, "<:encoding(UTF-8)", "$f") || die_message("Can't open $f file.\nERROR: $!\n");
    seek(ASSET_FILE, 0, SEEK_END);
    $asset_file = $f;
  }

  foreach $f (@ppm_files) {
    open(PPM_FILE, "$f") || die_message("Can't open $f file.\nERROR: $!\n");
    seek(PPM_FILE, 0, SEEK_END);
    $ppm_file = $f;
  }

  foreach $f (@tls_files) {
    open(TLS_FILE, "$f") || die_message("Can't open $f file.\nERROR: $!\n");

    seek(TLS_FILE, 0, SEEK_END);
    $tls_file = $f;
  }

  foreach $f (@push_files) {
    open(PUSH_FILE, "$f") || die_message("Can't open $f file.\nERROR: $!\n");
    seek(PUSH_FILE, 0, SEEK_END);
    $push_file_name = $f;
  }

  # Run a 'tail -f' on asm.log and tracer_asset.log to capture live traffic
  threads->create(\&process_asm_file,\*ASM_FILE,$asm_file);
  if(is_sip_file_based_log_running()) {
    open(ASSET_FILE, "$sip_file_based_log_filename") || die_message("Can't open $f file.\nERROR: $!\n");
    seek(ASSET_FILE, 0, SEEK_END);
    $asset_file = $sip_file_based_log_filename;
    threads->create(\&process_asset_file,\*ASSET_FILE,$asset_file);
  } else {
    threads->create(\&process_asset_file,\*ASSET_FILE,$asset_file);
  }
  threads->create(\&process_ppm_file,\*PPM_FILE,$ppm_file);
  threads->create(\&process_tls_file,\*TLS_FILE,$tls_file);
  threads->create(\&process_push_notification_file,\*PUSH_FILE,$push_file_name);

  if (is_capture()) {
    change_mode("start",$display_mode);
    audit("Already capturing: ".(is_asset_capture() ? "SIP " : "").(is_ppm_capture() ? "PPM " : "").(is_sm_capture() ? "CallP " : "").(is_tls_capture() ? "TLS " : "").(is_push_notification_capture_started() ? "Push-Notification " : "")); 
  } else {
    change_mode("stop",$display_mode);
  }

  dg_init_positions("bottom");
  cl_init_positions("bottom");
  dg_paint_all();

  # Start the process queu thread
  threads->create(\&process_queue);

  # Start the keyboard loop to process keys
  keyboard_loop();
}

sub open_provided_capture_files {
  # Process the file(s)
  change_mode("opening_file",$display_mode);
  $tail_log = 0;
  $max_exceeded = 0;
  $display_asm = -1;

  # Set the SM eth0 and eth1 (asset) IPs using the provided files
  set_sm_ips_off_line();

  # ASM files. Reorder the files to start processing the oldest file first
  @asm_files = sort {-M $b <=> -M $a} @asm_files;
  foreach $f (@asm_files) {
    dos_2_unix($f);
    open(ASM_FILE, "$f") || die_message("Can't open $f file.\nERROR: $!\n");
    process_asm_file(\*ASM_FILE,$f);
    close(ASM_FILE);
  }

  # Asset files. Reorder the files to start processing the oldest file first
  @asset_files = sort {-M $b <=> -M $a} @asset_files;
  foreach $f (@asset_files) {
    dos_2_unix($f);
    # SIP messages can contain unicode characters encoded in UTF-8. To display 
	# those unicode characters open tracer_asset files in UTF-8 mode. For any
	# reason if file can not be opened in UTF-8 mode, failback to traditional 
	# way.
    open(ASSET_FILE, "<:encoding(UTF-8)","$f") || die_message("Can't open $f file.\nERROR: $!\n");
    process_asset_file(\*ASSET_FILE,$f);
    close(ASSET_FILE);
  }

  # OneX Communicator files. Reorder the files to start processing the oldest file first
  @onexc_files = sort {-M $b <=> -M $a} @onexc_files;
  foreach $f (@onexc_files) {
    dos_2_unix($f);
    open(ONEXC_FILE, "$f") || die_message("Can't open $f file.\nERROR: $!\n");
    process_onexc_file(\*ONEXC_FILE,$f);
    close(ONEXC_FILE);
  }

  # PPM files. Reorder the files to start processing the oldest file first
  @ppm_files = sort {-M $b <=> -M $a} @ppm_files;
  foreach $f (@ppm_files) {
    dos_2_unix($f);
    open(PPM_FILE, "$f") || die_message("Can't open $f file.\nERROR: $!\n");
    process_ppm_file(\*PPM_FILE,$f);
    close(PPM_FILE);
  }

  # TLS files. Reorder the files to start processing the oldest file first
  @tls_files = sort {-M $b <=> -M $a} @tls_files;
  foreach $f (@tls_files) {
    dos_2_unix($f);
    open(TLS_FILE, "$f") || die_message("Can't open $f file.\nERROR: $!\n");
    process_tls_file(\*TLS_FILE,$f);
    close(TLS_FILE);
  }

  # PUSH files. Reorder the files to start processing the oldest file first
  @push_files = sort {-M $b <=> -M $a} @push_files;
  foreach $f (@push_files) {
    dos_2_unix($f);
    open(PUSH_FILE, "$f") || die_message("Can't open $f file.\nERROR: $!\n");
    process_push_notification_file(\*PUSH_FILE,$f);
    close(PUSH_FILE);
  }

  # Create the GSI filter
  $gsi_call_id = "";
  create_gsi_call_id_filter_from_regexp($global_session_id) if ($global_session_id);

  change_mode("file","diagram");
  process_queue();

  set_title();

  dg_init_positions("top");
  cl_init_positions("top");
  dg_paint_all();

  # Start the keyboard loop to process keys
  keyboard_loop();
}

sub dos_2_unix {
  # Check if the file is unix format using bash file command
  # unix is either (CRLF and LF) or nothing, dos is only CRLF
  $dosfile = `file @_ | grep " CRLF" | grep -cv " LF"`;
  chomp($dosfile);
  if ($dosfile) {
    @dos2unix = ("/usr/bin/dos2unix", "@_");
    system(@dos2unix);
  }
}

sub set_sm_ips_off_line {
  # Asset files. Reorder the files to start processing the oldest file first
  @asset_files = sort {-M $b <=> -M $a} @asset_files;
  foreach $f (@asset_files) {
    # Get Asset IP
    $ipv4 = `grep -P \"(egress|ingress): { L\\d+\\.\\d+\\.\\d+\\.\\d+:\" "$f" -m1`;
    if ($ipv4 =~ /L(\d+\.\d+\.\d+\.\d+)/) {
      $sm100_ip = $1;
    }

    # Get Asset IPv6
    $ipv6 = `grep -P \"(egress|ingress): { L\\[\[^\\]\]+\" "$f" -m1`;
    if ($ipv6 =~ /L\[([^\]]+)\]/) {
      $sm100_ipv6 = $1;
    }

    # Get SIP container IP
    $ipv4 = `grep \"toSD: true\" "$f" -B3 | grep -P \"egress: { L.*/R\\d+\\.\\d+\\.\\d+\\.\\d+:\" -m1`;
    if ($ipv4 =~ /R(\d+\.\d+\.\d+\.\d+)/) {
      $asm_ip = $1;
    }

    # Get SIP container IPv6
    $ipv6 = `grep \"toSD: true\" "$f" -B3 | grep -P \"egress: { L.*/R\\[\[^\\]\]+\" -m1`;
    if ($ipv6 =~ /R\[([^\]]+)\]/) {
      $asm_ipv6 = $1;
    }
  }

  # TLS files. Reorder the files to start processing the oldest file first
  @tls_files = sort {-M $b <=> -M $a} @tls_files;
  foreach $f (@tls_files) {
    if ($sm100_ip eq "uknown") {
      $sm100_ips = `grep "SM100_IP:" -m1 "$f"`;
      if ($sm100_ips =~ /SM100_IP: ([^ ]*)(  SM100_IPV6: (.*))?$/) {
        $sm100_ip = $1;
        $sm100_ipv6 = $3;
      } else {
        die_message("Cannot find the SM100_IP in the TLS file $f\n");
      }
    }
  }
#print TMP "Off line sm100_ip $sm100_ip sm100_ipv6 $sm100_ipv6      asm_ip $asm_ip asm_ipv6 $asm_ipv6\n";
}

sub start_stop_capture {
  if ($capture_mode eq "stop") {
    start_dialog();
  } elsif ($capture_mode eq "start") {
    audit("Stopping capture");
    stop_asset_capture();
    stop_sm_capture();
    stop_ppm_capture();
    stop_tls_capture();
    stop_push_notification_capture();
  }
}

sub start_sm_capture_cmd {
  my $log4jprops = "$sm_conf_dir/log4j.properties";
  if (-w $log4jprops) {
    `sed -i "s/^log4j.logger.com.avaya=[a-zA-Z]*, ASM_LOGGER/log4j.logger.com.avaya=FINEST#com.avaya.common.logging.client.LogLevel, ASM_LOGGER, TRACESM_LOGGER/" $log4jprops`;
  } else {
    die_message("Cannot open log4j.properties file: $log4jprops");
  }
}

sub start_sm_capture {
  start_sm_capture_cmd();
}

sub stop_sm_capture_cmd {
  my $log4jprops = "$sm_conf_dir/log4j.properties";
  if (-w $log4jprops) { 
    my $result = `sed -i "s/^log4j.logger.com.avaya=FINEST#com.avaya.common.logging.client.LogLevel, ASM_LOGGER, TRACESM_LOGGER/log4j.logger.com.avaya=INFO, ASM_LOGGER/" $log4jprops`;
  } else  {
    die_message("Cannot open log4j.properties file: $log4jprops");
  }
}

sub stop_sm_capture {
  change_mode("stopping",$display_mode);
  stop_sm_capture_cmd();
  change_mode("stop",$display_mode);
}

sub start_ppm_capture_cmd {
  set_ppm_priority("FINE");
}

sub start_ppm_capture {
  start_ppm_capture_cmd();
}

sub stop_ppm_capture_cmd {
  set_ppm_priority("INFO");
}

sub stop_ppm_capture {
  stop_ppm_capture_cmd();
}

sub is_ppm_capture {
  my $priority = get_ppm_priority();
  if ($priority =~ /FINE/) {
    return 1;
  } else {
    return 0;
  }
}

sub get_ppm_priority {

  if($fetch_ppm_log_level == 0)
  {
    # Running "jboss-logging-cli.sh" takes few seconds. It is not efficient to call it
    # every time we need to know ppm priority level. Fetch priority from file 
    # only if it is changed.	
	return $saved_ppm_log_level;
  }
  my $_  = `$jboss_cli_script --command="/subsystem=logging/custom-handler=TRACESM_PPM_TRACE:read-attribute(name=level)" | grep FINE | wc -l`;
  if($_ == 1) {
    $saved_ppm_log_level = FINE;
  } else {
    $saved_ppm_log_level = INFO;
  }
  $fetch_ppm_log_level = 0;
  return $saved_ppm_log_level;
}

sub set_ppm_priority {
  $fetch_ppm_log_level = 1;
  my $new_value = shift;
  if($new_value eq FINE) {
    # Turn ON PPM trace
    #  a. Set TRACESM_PPM_TRACE to FINE
    #  b. If PERSONAL_PROFILE_MANAGER_TRACE is set to  INFO then set log level to FINE for SchemaHelper and ASM_PPMAuthHandler
    `$jboss_cli_script --command="/subsystem=logging/custom-handler=TRACESM_PPM_TRACE:write-attribute(name=level,value=$new_value)"`;
    my $_  = `$jboss_cli_script --command="/subsystem=logging/custom-handler=PERSONAL_PROFILE_MANAGER_TRACE:read-attribute(name=level)" | grep INFO | wc -l`;
    if($_ == 1) {
      `$jboss_cli_script --command="/subsystem=logging/logger=com.avaya.ccs.ppm.ws.jdom.support.SchemaHelper:write-attribute(name=level,value=FINE),/subsystem=logging/logger=com.avaya.ccs.ppm.app.auth.impl.ASM_PPMAuthHandler:write-attribute(name=level,value=FINE)"`;
    }
  } else {
    # Turn OFF PPM trace
    #  a. Set TRACESM_PPM_TRACE to INFO
    #  b. If PERSONAL_PROFILE_MANAGER_TRACE is set to  INFO then set log level to INFO for SchemaHelper and ASM_PPMAuthHandler

    `$jboss_cli_script --command="/subsystem=logging/custom-handler=TRACESM_PPM_TRACE:write-attribute(name=level,value=$new_value)"`;
    my $_  = `$jboss_cli_script --command="/subsystem=logging/custom-handler=PERSONAL_PROFILE_MANAGER_TRACE:read-attribute(name=level)" | grep INFO | wc -l`;
    if($_ == 1) {
      `$jboss_cli_script --command="/subsystem=logging/logger=com.avaya.ccs.ppm.ws.jdom.support.SchemaHelper:write-attribute(name=level,value=INFO),/subsystem=logging/logger=com.avaya.ccs.ppm.app.auth.impl.ASM_PPMAuthHandler:write-attribute(name=level,value=INFO)"`;
    }
  }
}

sub is_smcmd_ppm_capture {
  my $priority = get_ppm_priority();
  if ($priority =~ /FINE/) {
    return 1;
  } else {
    return 0;
  }
}

sub set_sm_ips_real_time {
  #Get and set the SM eth0 IP
  $ipv4 = `ip addr show eth0 | grep "inet "`;
  if ($ipv4 =~ /^.*inet (\d+\.\d+\.\d+\.\d+).*$/) {
    $asm_ip = $1;
  }
  $ipv6 = `ip addr show eth0 | grep "inet6 .* scope global"`;
  if ($ipv6 =~ /^.*inet6 ([^\/]*)\/.*$/) {
    $asm_ipv6 = $1;
  }  
  die_message("ERROR: Can't determine the eth0 IP\n") unless ($asm_ip ne "uknown" || $asm_ipv6 ne "uknown v6");

  # Get the Asset interface (e.g. eth2, bond0, etc.)
  my $interface = `$asset_net_command 2>&1 | grep interfaceName`;
  die_message("ERROR: Can't determine the Security Module interface name\n") unless $interface =~ s/.*interfaceName\s+(\w+\d+).*/\1/;
  chop($interface);

  # Get the Asset IP (need this as tshark does not tell you if packets are inbound or outbound)
  $ipv4 = `ip addr show | grep $interface | grep "inet " | grep secondary -v`;
  if ($ipv4 =~ /^.*inet (\d+\.\d+\.\d+\.\d+).*$/) {
    $sm100_ip = $1;
  }
  $ipv6 = `ip addr show $interface | grep "inet6 .* scope global"`;
  if ($ipv6 =~ /^.*inet6 ([^\/]*)\/.*$/) {
    $sm100_ipv6 = $1;
  }
  die_message("ERROR: Can't determine the Security Module IP\n") unless ($sm100_ip ne "uknown" || $sm100_ipv6 ne "uknown v6");
#print TMP "Real time: sm100_ip $sm100_ip sm100_ipv6 $sm100_ipv6     asm_ip $asm_ip asm_ipv6 $asm_ipv6\n";
}

sub start_tls_capture_cmd {

  # In software only SM installation setup, wireshark needs to be installed manually.
  # Some customers may choose not to install wireshark package. In this case tls capture
  # will not work. Report such incident where wireshark is not installed on system and 
  # tls capture is enabled.
  $result = `command -v tshark | wc -l`;
  chop($result);
  if ($result ne "1") {
	return 1;
  }

  # Get the Asset interface (e.g. eth2, bond0, etc.)
  $interface = `$asset_net_command 2>&1 | grep interfaceName`;
  die_message("ERROR: Can't determine the Security Module interface name\n") unless $interface =~ s/.*interfaceName\s+(\w+\d+).*/\1/;
  chop($interface);

  # Get all the TLS local ports
  $ports = "";
  $decode_as = "";
  for (split /^/, `$asset_getap_command 2>&1 | grep "trans:tls port:"`) {
    if (/trans:tls port:(\d+) /) {
      $ports .= " $1 or";
      $decode_as .= " -d tcp.port==$1,ssl";
    }
  }
  die_message("ERROR: Can't determine the Security Module TLS ports\n") unless $ports ne "";

  # Add port 443 for HTTPS (PPM)
  $ports .= " 443";

  # Create a logrotate config file to rotate the tshark output.
  $logrotate_config = <<"END_LOGROTATE";
/var/log/Avaya/trace/tls_handshake.log {
        nodateext
        rotate 30
        missingok
        size=20M
        copytruncate
        postrotate
          echo # SM100_IP: $sm100_ip  SM100_IPV6: $sm100_ipv6 >> /var/log/Avaya/trace/tls_handshake.log
        endscript

  return 0;
}
END_LOGROTATE

  # Starting with SM 7.1 (ASM-61244), Asset now controls the logrotate of tls_handshake.log. To
  # keep backward compatibility, we check if that is the case or not to create our own logrotate file
  $result = `grep "/var/log/Avaya/trace/tls_handshake.log" -m 1 -c "/etc/logrotate.d/assetLogRotate"`;
  chop($result);
  if ($result ne "1") {  # Pre 7.1 SM, so we need to create the logroate config and cron entry
    open(TLSLOGROTATE, ">", "$trace_dir/traceSM_tls_logrotate.conf") or die_message("ERROR: Can't create TLS logrotate config file $trace_dir/traceSM_tls_logrotate.conf: $!\n");
    print TLSLOGROTATE $logrotate_config or die_message("ERROR: Can't write TLS logrotate config file $trace_dir/traceSM_tls_logrotate.conf: $!\n");;
    close TLSLOGROTATE;
 
    # add a crontab job to run logrotate every minute.
    open (CRON, "| crontab -") or die_message("ERROR: Can't open crontab: $!\n");
    my $cron = qx(crontab -l);
    print CRON "$cron\n* * * * * /usr/sbin/logrotate /var/log/Avaya/trace/traceSM_tls_logrotate.conf\n";
    close CRON;
  }

  # Add the Asset IP to the tls log file so we can then use it for offline reads
  # `echo "# SM100_IP: $sm100_ip  SM100_IPV6: $sm100_ipv6" >> /var/log/Avaya/trace/tls_handshake.log`;

  # Finally construct the tshark command line. For example:
  # tshark -i eth2 -n -f "port 5063 or 5061 or port 15061" -d tcp.port==5063,ssl -d tcp.port==15061,ssl -d tcp.port==5061,ssl -l -S "--------------------------------------------"  -R ssl -O frame,ssl
  $tshark_command = "tshark -i $interface -S '--------------------------------------------' -R ssl -O frame,ssl -n -f 'port ".$ports."' ".$decode_as." -l";

  # Run the tshark command in the background
  `nohup $tshark_command 2>/dev/null >> $trace_dir/$log_file{tls} &`;

  # As a separation of privilege, packet capture and its processing/parsing is
  # done by two different linux processes. tcpdump utility is high privileged 
  # linux process and does packet capturing. While tshark is low privileged 
  # linux process which has protocol stack and it does parsing/processing of 
  # packets.
  #
  # Tcpdump and tshark communicate through a temporary file which is created in 
  # /tmp/ directory. But when tshark runs for long time the temp file becomes
  # too big and eats up disk space.
  #
  # When tshark writes output to stdout (as is the case in above tshark command)
  # tcpdump and tshark communicate over a FIFO(pipe). But temp file is also 
  # crated in /tmp. As in this case we are not expecting pcap file at the end 
  # we can delete the file and still have tshark running fine.
  `nohup bash -c "sleep 10; rm -f /tmp/wireshark_pcapng*" >/dev/null 2>&1 &`;

  # print TMP "interface $interface ports $ports $decode_as\n$tshark_command\n";
}

sub start_tls_capture {
    if(1 == start_tls_capture_cmd()) {
  	notify_user_wireshark_missing();
    }
}

sub stop_tls_capture_cmd {

  # Kill the tshark commands (should only be one, but just in case look for more than one)
  `pkill -f "tshark .* -R ssl -O frame,ssl"`;

  # Remove the crontab entry
  open (CRON, "| crontab -") or  die_message("ERROR: Can't open crontab: $!\n");
  my $cron = qx(crontab -l);
  $cron =~ s!\n\* \* \* \* \* /usr/sbin/logrotate /var/log/Avaya/trace/traceSM_tls_logrotate\.conf\n!!g;
  print CRON $cron;
  close CRON;
}

sub stop_tls_capture {
    stop_tls_capture_cmd();
}

sub is_tls_capture {
  # Check if the tshark command is running
  # Originally we used pgrep, but that causes to find myself when first run (ZEPHYR-49360)
  # so it was changed to use ps instead
  my $return = `ps -ef | grep "tshark .* -R ssl -O frame,ssl"`;
  # the $return will alwys return the grep command, but the tshark also contains "-------------..."
  # so we look for them
  if ($return =~ /--------------------------------------------/) {
    return 1;
  } else {
    return 0;
  }
}

sub start_asset_capture_cmd {

  # check if this is actually an SM server
  if (!(-e $asset_trace_command)) {
    die_message("Can not find 'soapClientUpdateSipTracer' command to start the capture.\n");
  }
  if(is_sip_file_based_log_running()) {
    return;
  }
  my $enable_command = $enable_asset_trace;
  my $response = `$enable_command`;
  if ($response !~ /ASSET Update - got success response/) {
    die_message("Error enabling SM100 trace.\n\n$response\n");
  }
  #print TMP "Asset command:\n$enable_command\n";
  #print TMP "Asset response:\n$response\n";
}

sub start_asset_capture {
#  change_mode("starting");
   start_asset_capture_cmd();
#  change_mode("start");
}

sub stop_asset_capture_cmd {
  # check if this is actually an SM server
  if (!(-e $asset_trace_command)) {
    die_message("Can not find 'soapClientUpdateSipTracer' command to stop the capture.\n");
  }
  if(is_sip_file_based_log_running()) {
    return;
  }
  my $response = `$disable_asset_trace`;
  if ($response !~ /ASSET Update - got success response/) {
    die_message("Error disabling SM100 trace.\n\n$response\n");
  }

  # Commit the stop so it will persist restarts (SIPMsgTracer.conf)
  # Done to avoid a trace started via SMGR "SIP Tracer"
  # When traceSM starts the capture, it does not persist the cahnges.
  my $response = `$commit_asset_trace`;
}

sub stop_asset_capture {
  change_mode("stopping",$display_mode);
  stop_asset_capture_cmd();
  change_mode("stop",$display_mode);
}

sub confirm_capture_filter {
  my $w = 59;
  my $h = 3;
  my ($x, $y, $answer);

  $display_mode = "confirm_capture_filter";
  create_box($w,$h);
  $x = ($max_col - $w-2)/2 + 1;
  $y = $cl_top_margin + ($max_row-$cl_top_margin-1 - $h-2)/2 + 1;

  undef(%capture_filter_call);

  goto_xy($x, $y++);

  until ($answer =~ /^y(es)?$|^n(o)?$/i) {
    undef($answer);

    goto_xy($x, $y);
    print " Do you want to specify a capture filter? (Yes/[No]) ";

    # display the cursor and change to normal keyboard mode
    set_keyboard(0);
    cursor_visible(1);

    $answer = <STDIN>;
    chop($answer);

    $answer = "no" if $answer eq "";

    # hide the cursor and go back to the special keyboard mode
    set_keyboard(1);
    cursor_visible(0);
  }

  $display_mode = "normal";
  $prev_display_mode = "normal";

  cl_init_positions("bottom");

  # update the window title
  set_title();

  cl_paint_all();
  $display_mode = "normal";

  return ($answer =~ /^y/i);
}

sub capture_filter {
  my $w = 70;
  my $h = 10;
  my $x, $y, $options_result;
  my $call_count = 1;
  my $from;
  my $to;
  my $uri;
  my $answer;
  my $regexp;

  $display_mode = "capture_filter";
  create_box($w,$h);
  $x = ($max_col - $w-2)/2 + 1;
  $y = $dg_top_margin + ($max_row-$dg_top_margin-1 - $h-2)/2 + 1;

  goto_xy($x, $y++);
  print "                            Capture Filter";
  goto_xy($x, $y++);
  print "                An empty field will match all messages";
  goto_xy($x, $y++);

  # display the cursor and change to normal keyboard mode
  set_keyboard(0);
  cursor_visible(1);

  $y++;
  while (1) {
    $from = "";
    $to = "";
    $uri = "";

    goto_xy($x, $y);
    print "            Call Filter $call_count";
    goto_xy($x, $y+1);
    print " From: "." " x ($w-7);
    goto_xy($x, $y+2);
    print " To: "." " x ($w-5);
    goto_xy($x, $y+3);
    print " Request URI: "." " x ($w-14);


    goto_xy($x, $y+1);
    print " From: ";
    $from = <STDIN>;
    chop($from);
    $regexp = eval { qr/$from/ };
    if ($@) {
      goto_xy($x, $y+5);
      print " " x $w;
      goto_xy($x, $y+5);
      print colored("ERROR: Invalid regular expression in From field",'red');
      redo;
    }


    goto_xy($x, $y+2);
    print " To: ";
    $to = <STDIN>;
    chop($to);
    $regexp = eval { qr/$to/ };
    if ($@) {
      goto_xy($x, $y+5);
      print " " x $w;
      goto_xy($x, $y+5);
      print colored("ERROR: Invalid regular expression in To field",'red');
      redo;
    }

    goto_xy($x, $y+3);
    print " Request URI: ";
    $uri = <STDIN>;
    chop($uri);
    $regexp = eval { qr/$uri/ };
    if ($@) {
      goto_xy($x, $y+5);
      print " " x $w;
      goto_xy($x, $y+5);
      print colored("ERROR: Invalid regular expression in URI field",'red');
      redo;
    }


    # hide the cursor and go back to the special keyboard mode
#    set_keyboard(1);
#    cursor_visible(0);

    $capture_filter_call{"from_$call_count"} = $from;
    $capture_filter_call{"to_$call_count"} = $to;
    $capture_filter_call{"uri_$call_count"} = $uri;

    if ($call_count < 3) {
      undef($answer);
      until ($answer =~ /^y(es)?$|^n(o)?$/i) {
        undef($answer);
        goto_xy($x, $y+5);
        print "Do you want to add an additional capture filter (Yes/No)? ";
        $answer = <STDIN>;
        chop($answer);
      }
      last if $answer =~ /^n/i;
    } else {
      last;
    }
    $call_count++;
    # clear the question line
    goto_xy($x, $y+5);
    print " " x $w;
  }

  # hide the cursor and go back to the special keyboard mode
  set_keyboard(1);
  cursor_visible(0);

  $display_mode = "normal";
  $prev_display_mode = "normal";

  cl_init_positions("bottom");

  # update the window title
  set_title();

  cl_paint_all();
  $display_mode = "normal";
}

sub is_capture {
  return 1 if not $is_real_time;
  return 1 if is_asset_capture() || is_sm_capture() || is_ppm_capture() || is_tls_capture() || is_push_notification_capture_started();
  return 0; 
}

sub is_sm_capture {
  my $log4jprops = "$sm_conf_dir/log4j.properties";
  if (-f $log4jprops) {
    return `egrep "^log4j.logger.com.avaya=FINEST#com.avaya.common.logging.client.LogLevel, ASM_LOGGER, TRACESM_LOGGER" $log4jprops 2>&1`;
  } else {
    return 0;
  }
}

sub is_asset_capture {
  my $response = `$get_asset_trace`;
  if(is_sip_file_based_log_running()) {
    return 1;
  }

  # Check for trace enabled
  if ($response =~ /trace_enable = 1/s) {
    return 1;
  }
  return 0;
}

sub get_logs {
  # Add the call_proc.log file
  if (!-f "$trace_dir$log_file{sm}") {
    if (`id wsuser 2>&1` =~ /No such user/) {
      $result = `touch $trace_dir$log_file{sm};chown root:susers $trace_dir$log_file{sm};chmod g+w $trace_dir$log_file{sm}`;
    } else {
      $result = `touch $trace_dir$log_file{sm};chown wsuser:susers $trace_dir$log_file{sm};chmod g+w $trace_dir$log_file{sm}`;
    }
  }
  if (-f "$trace_dir$log_file{sm}") {
    push(@asm_files,"$trace_dir$log_file{sm}");
  } else {
    die "Can not find the $log_file{sm} in $trace_dir. Please specify the $log_file{sm} and $log_file{asset} in the command line.";
  }

  # Add the tracer_asset.log file
  if (!-f "$trace_dir$log_file{asset}") {
    # Create the tracer_asset.log if does not exist
    $result = `touch $trace_dir$log_file{asset};chown root:susers $trace_dir$log_file{asset};chmod 640 $trace_dir$log_file{asset}`;
  }
  push(@asset_files,"$trace_dir$log_file{asset}");

  # Add the ppm.log file
  if (!-f "$trace_dir$log_file{ppm}") {
    $result = `touch $trace_dir$log_file{ppm};chown jboss:susers $trace_dir$log_file{ppm};chmod g+w $trace_dir$log_file{ppm}`;
  }
  if (-f "$trace_dir$log_file{ppm}") {
    # Change the file permissions, as in the case of log4j creating it will not have read permissions.
    `chmod go+r $trace_dir$log_file{ppm}*`;

    push(@ppm_files,"$trace_dir$log_file{ppm}");
  } else {
    die "Can not find the $log_file{ppm} in $trace_dir. Please specify the $log_file{ppm} in the command line.";
  }

  # Add the tls_handshake.log file
  if (!-f "$trace_dir$log_file{tls}") {
    $result = `touch $trace_dir$log_file{tls}`;
    # Add the Asset IPs to the tls log file so we can then use it for offline reads
    `$asset_addinfo_command $trace_dir$log_file{tls}`;
  }
  if (-f "$trace_dir$log_file{tls}") {
    push(@tls_files,"$trace_dir$log_file{tls}");
  } else {
    die "Can not find the $log_file{tls} in $trace_dir. Please specify the $log_file{tls} in the command line.";
  }
  if (-f "$trace_dir$log_file{push_notification}") {
    push(@push_files,"$trace_dir$log_file{push_notification}");
  } else {
    die "Can not find the $log_file{push_notification} in $trace_dir. Please specify the $log_file{push_notification} in the command line.";
  }
}

sub dg_init_positions {
  $pos = shift;
  my $dg_record_no = scalar (@display_dg_records);
  my $dg_column_no = keys(%dg_columns);

  if ($pos eq "top") {
    $dg_rec_pos = $dg_record_no?1:-1;
    $dg_col_pos = 1;
    $dg_top_pos = 1;
    $prev_dg_rec_pos = $dg_rec_pos;
    $prev_dg_col_pos = $dg_col_pos;
    $prev_dg_top_pos = $dg_top_pos;
    $prev_dg_column_no = $dg_column_no;
    $prev_dg_record_no = $dg_record_no;
  } elsif ($pos eq "bottom") {
    $prev_dg_rec_pos = 1;
    $prev_dg_col_pos = 1;
    $prev_dg_top_pos = 1;
    $prev_dg_record_no = $dg_record_no;
    $prev_dg_column_no = 1;
    $dg_col_pos = 1;
    $dg_top_pos = 1;
    $dg_rec_pos = $dg_record_no;
    $prev_dg_rec_pos = $dg_rec_pos;
  } elsif ($pos eq "next") {
    $search_header_msg = "                ";
    return if not $goto_search;
    print_search_header_msg("  Searching...  ");
    my $found = 0;
    for ($i=$dg_rec_pos; $i <= $#display_dg_records; $i++) {
      if (match_record($i)) {
        $found = 1;
        last;
      }
    }
    if ($found) {
      $dg_rec_pos = $i+1;
      my $dis_rec = min($max_row-$dg_top_margin-2,$dg_record_no-$dg_top_pos);
      if ($dg_rec_pos > $dg_top_pos + $dis_rec) { # Pass the current screen, set the cursor in the middle of the screen
        $dg_top_pos = min($dg_rec_pos-int(($max_row-$dg_top_margin-2)/2),$dg_record_no); 
      } else {  # In the current screen, set the cursor in the record (do not scroll)
        $dg_top_pos = $dg_top_pos;  
      } 
      $prev_dg_rec_pos = $dg_rec_pos;
      $prev_dg_top_pos = $dg_top_pos;
      print_search_header_msg("                ");
      return 1;
    }
    # If not found, lets search from the beginning and see if it wrapped
    $found = 0;
    for ($i=0; $i <= $dg_rec_pos; $i++) {
      if (match_record($i)) {
        $found = 1;
        last;
      }
    }
    if ($found) {  # Found on the second pass, so it wrapped
      $dg_rec_pos = $i+1;
      my $dis_rec = min($max_row-$dg_top_margin-2,$dg_record_no-$dg_top_pos);
      if ($dg_rec_pos > $dg_top_pos + $dis_rec) { # Pass the current screen, set the cursor in the middle of the screen
        $dg_top_pos = min($dg_rec_pos-int(($max_row-$dg_top_margin-2)/2),$dg_record_no);
      } else {  # In the current screen, set the cursor in the record (do not scroll)
        $dg_top_pos = $dg_top_pos;
      }
      $prev_dg_rec_pos = $dg_rec_pos;
      $prev_dg_top_pos = $dg_top_pos;
      print_search_header_msg(" Search wrapped ");
      return 1;
    } else { # Definitely not found anywhere
      print_search_header_msg("   Not found   ");
      return 0;
    }
  } elsif ($pos eq "previous") {
    $search_header_msg = "                ";
    return if not $goto_search;
    print_search_header_msg("  Searching...  ");
    my $found = 0;
    for ($i=$dg_rec_pos-2; $i >=0 ; $i--) {
      if (match_record($i)) {
        $found = 1;
        last;
      }
    }
    if ($found) {
      $dg_rec_pos = $i+1;
      my $dis_rec = min($max_row-$dg_top_margin-2,$dg_record_no-$dg_top_pos);
      if ($dg_rec_pos < $dg_top_pos) { $dg_top_pos = $dg_rec_pos - max(int(($max_row-$dg_top_margin-2)/2),0); }; # cursor in a prev screen, put it in the middle
      $prev_dg_rec_pos = $dg_rec_pos;
      $prev_dg_top_pos = $dg_top_pos;
      print_search_header_msg("                ");
      return 1;
    }
    # If not found, lets search from the beginning and see if it wrapped
    $found = 0;
    for ($i=$dg_record_no-1; $i >=0 ; $i--) {
      if (match_record($i)) {
        $found = 1;
        last;
      }
    }
    if ($found) { # Found on the second pass, so it wrapped
      $dg_rec_pos = $i+1;
      my $dis_rec = min($max_row-$dg_top_margin-2,$dg_record_no-$dg_top_pos);
      if ($dg_rec_pos < $dg_top_pos) { $dg_top_pos = $dg_rec_pos - max(int(($max_row-$dg_top_margin-2)/2),0); }; # cursor in a prev screen, put it in the middle
      $prev_dg_rec_pos = $dg_rec_pos;
      $prev_dg_top_pos = $dg_top_pos;
      print_search_header_msg(" Search wrapped ");
      return 1;
    } else { # Definitely not found anywhere
      print_search_header_msg("   Not found   ");
      return 0;
    }
  }
}

sub match_record {
  my ($idx) = @_;
  if (!exists($display_dg_records[$idx])) {
    print TMP "we shold never get here: idx=$idx\n";
    return 0;
  } 
  if ($display_dg_records[$idx]{timestamp} =~ /$goto_search/) {
    return 1;
  }

  # Go thru all the hash keys on the record, this will look in
  # day,timestamp,desc,sip message, etc.
  foreach my $key (keys %{$display_dg_records[$idx]}) {
    if ($display_dg_records[$idx]{$key} =~ /$goto_search/) {
      return 1;
    }
  }
  return 0;
}




sub quit_program {
#printstack();
  my ($msg) = @_;
  if ($capture_mode eq "start") {
    return if !confirm_close();
    audit("Leave capturing in the background");
  }

  if ($tail_log) {
    $tail_log = 0;
    $quit = 1;
    # Wait for the process_file thread to finish
    sleep(1);
  }
  end_screen();
  # Set the window title as the hostnmae
  print "\033]0;".hostname."\007";

  if ($is_real_time) {
    print "The complete log files are located:\n";
    print "\tSIP messages: ".$trace_dir.$log_file{asset}."*\n";
    print "\tSIP messages (if always ON enabled): /var/log/Avaya/sip_trace/sip_trace.log*\n";
    print "\tCall Processing: ".$trace_dir.$log_file{sm}."*\n";
    print "\tPPM: ".$trace_dir.$log_file{ppm}."*\n";
    print "\tTLS: ".$trace_dir.$log_file{tls}."*\n";
    print "\tPUSH_NOTIFICATION: ".$trace_dir.$log_file{push_notification}."*\n";
   
    # Detach all the threads to avoid the warning
    $_->detach() foreach threads->list(); 
  }
  print $msg."\n" if $msg;
  if ($new_tmp_dir) {
     `rm -rf $new_tmp_dir`;
     print "Removed tmpdir $new_tmp_dir.\n";
     audit("Removed tmpdir $new_tmp_dir.");
  }
  audit("---------------- traceSM close ----------------");
  exit;
}

sub toggle_show_asm {
  my $w = 30;
  my $h = 3;
  my ($x, $y);

  $display_mode = "refiltering_asset";
  create_box($w,$h);
  $x = ($max_col - $w-2)/2 + 1;
  $y = $dg_top_margin + ($max_row-$dg_top_margin-1 - $h-2)/2 + 2;
  goto_xy($x, $y);
  print "       Please wait...";

  if ($show_asm) {
    undef($show_asm);
  } else {
    $show_asm = 1;
  }
  change_mode($capture_mode,$display_mode);

  reset_call_flow_refresh();
  refilter();
}

sub start_dialog {
  my $w = 30;
  my $h = 10;
  my ($x, $y);
  my $key;
  my $fn_key = 0;
  my $pos = 4;

  # By default mark the SIP checkbox only
  @chekbox = (1, 0, 0);

  my $prev_display_mode = $display_mode;
  $display_mode = "start_dialog";
  display_start_dialog($w, $h, $x, $y);
  while(1){
    refresh_checkbox($x, $y, $pos);

    if ($fn_key) {
      $key .= getc(STDIN);
    } else {
      $key = getc(STDIN);
    }

    # The arrow keys are actually a sequence of three keys.
    # For example the up arrow is ESC [ A
    if ($key eq "\e" || $key eq "\e[") {
      $fn_key = 1;
      next;
    }
    $fn_key = 0;
    # UP or LEFT
    if ($key eq "\e[A" || $key eq "\e[D") {
      $pos--;
      $pos = 4 if $pos<0;
    # DOWN or RIGHT
    } elsif ($key eq "\e[B" || $key eq "\e[C") {
      $pos++;
      $pos = 0 if $pos>6;
    # ENTER or Space bar to View Details
    } elsif ($key eq "\n" || $key eq " ") {
      if ($pos < 5) {
        # For CallP, always display a warning of the perf impact
        # and prevent t to be checked if there are more than 50 messages/sec in
        # the last 20 minutes
        if ($pos == 2 && $chekbox[$pos] == 0) { # When Call Processing is checked
          # Display the WARNING about perf impact
          $chekbox[$pos] = 1 if display_callp_warning();
          display_start_dialog($w, $h, $x, $y);
          refresh_checkbox($x, $y, $pos);
          # If mesages/sec is over 50, do not allow to run it
          if (get_messages_per_second() > 50 && $chekbox[$pos]==1) {
            $chekbox[$pos] = 0;
            display_callp_error(); 
          }
          display_start_dialog($w, $h, $x, $y);
          refresh_checkbox($x, $y, $pos);
        } else {  
          # Toggle the checkbox
          $chekbox[$pos] = 1 - $chekbox[$pos];
        } 
      } elsif ($pos == 5) { # OK
        # Reset the start time for the files to be written
        set_start_capture_time();

        change_mode("starting",$display_mode);
        audit("Starting capture for: ".($chekbox[0] ? "SIP ":"").($chekbox[1] ? "PPM ":"").($chekbox[2] ? "CallP ":"").($chekbox[3] ? "TLS ":"").($chekbox[4] ? "Push Notification ":""));
        start_asset_capture() if $chekbox[0]; # SIP
        start_ppm_capture() if $chekbox[1]; # PPM 
        start_sm_capture() if $chekbox[2]; # Call Processing
        start_tls_capture() if $chekbox[3]; # TLS handshaking
        start_push_notification_capture() if $chekbox[4]; # Push Notification
        change_mode("start",$display_mode);
        last;
      } elsif ($pos == 6) { # CANCEL
        change_mode("stop",$display_mode);
        last;
      } 
    }
  }

  $display_mode = $prev_display_mode;

  if ($display_mode eq "call summary") {
    cl_paint_all();
  } else {
    dg_paint_all();
  }
}

sub get_messages_per_second {
  return -1 unless -f $sip_stats_file;

  # Get the last 20 minutes of SIP performance data (last 10 lines of siptotal.csv)
  $perf_data = `tail -10 $sip_stats_file`;
  # Format of the siptotal.csv is:
  #  timestamp,policy,msgtx,msgrx,siprequesttx,siprequestrx,sipresponsetx,sipresponserx,appmsgdrop,msgtxerrors
  # For example:
  #  1409345700,default,515,515,177,338,338,177,0,0
  #  1409345700,trusted,10211,10211,9412,799,799,9412,0,0
  # We use msgrx which is received SIP responses + SIP requests 
  $total_msgrx = 0;
  $min_default = 4294967295;
  $min_trusted = 4294967295;
  for (split /\n/, $perf_data) {
    ($timestamp, $policy, $msgtx, $msgrx, @others) = split(',',$_);
    if ($policy eq "default") {
      if ($msgrx < $min_default) {
        $min_default = $msgrx;
      }
      $total_default_msgrx = ($msgrx - $min_default);
    }
    if ($policy eq "trusted") {
      if ($msgrx < $min_trusted) {
        $min_trusted = $msgrx;
        $fisrt_timestamp = $timestamp;
      }
      $total_trusted_msgrx = ($msgrx - $min_trusted);
    }
  }
  #die_message("ERROR: Cannot get SIP performace data. Last timestamp value $timestamp. Current timestamp ".time()."\n") unless (time()-$timestamp) <= 300;  
  return -1 unless (time()-$timestamp) <= 300;  
  return -1 unless ($timestamp-$fisrt_timestamp) != 0;
  return ($total_default_msgrx+$total_trusted_msgrx)/($timestamp-$fisrt_timestamp);
}

sub display_callp_warning {
  my $w = 71;
  my $h = 5;
  my ($x, $y, $answer);

  create_box($w,$h);
  $x = ($max_col - $w-2)/2 + 1;
  $y = $dg_top_margin + ($max_row-$dg_top_margin-1 - $h-2)/2 + 1;

  goto_xy($x, $y++);
  print colored("WARNING:","red")." Enabling Call Processing may have a negative performace impact"; 
  goto_xy($x, $y++);
  print "on SM, potentially causing an outage. Use this only on non-Production";
  goto_xy($x, $y++);
  $messages_per_second = get_messages_per_second();
  if ($messages_per_second == -1) {
    printf "environments. ";
    goto_xy($x, $y++);
    print colored("Cannot estimate msg/sec or running on BSM, it is advised not to proceed","red");
  } else {
    printf "environments. SM processing %.1f messages/sec in the last 20 minutes.", get_messages_per_second();
    $y++;
  }

  until ($answer =~ /^y(es)?$|^n(o)?$/i) {
    undef($answer);

    goto_xy($x, $y);
    print "    Are you sure you want to enable Call Processing (Yes/No)? ";

    # display the cursor and change to normal keyboard mode
    set_keyboard(0);
    cursor_visible(1);

    $answer = <STDIN>;
    chop($answer);

    # hide the cursor and go back to the special keyboard mode
    set_keyboard(1);
    cursor_visible(0);

  }

  if ($display_mode eq "call summary") {
    cl_paint_all();
  } else {
    dg_paint_all();
  }

  return ($answer =~ /^y/i);
}

sub display_callp_error {
  my $w = 60;
  my $h = 4;
  my ($x, $y);

  create_box($w,$h);
  $x = ($max_col - $w-2)/2 + 1;
  $y = $dg_top_margin + ($max_row-$dg_top_margin-1 - $h-2)/2 + 1;

  goto_xy($x, $y++);
  print colored(" ERROR:","red")." Cannot enable Call Processing because it will cause";
  goto_xy($x, $y++);
  printf "a performance impact. SM processing %.1f messages/sec in", get_messages_per_second();
  goto_xy($x, $y++);
  print "the last 20 minutes.";
  goto_xy($x, $y++);
  print "                 Press any key to continue.";

  # change to special keyboard mode
  set_keyboard(1);

  getc(STDIN);

  if ($display_mode eq "call summary") {
    cl_paint_all();
  } else {
    dg_paint_all();
  }

} 

sub display_start_dialog {
  my ($w, $h, $x, $y) = @_;

  create_box($w,$h);
  $x = ($max_col - $w-2)/2 + 1;
  $y = $dg_top_margin + ($max_row-$dg_top_margin-1 - $h-2)/2 + 1;
  goto_xy($x, $y);
  print "        Start Capture";
  $x += 1; $y += 2;
  goto_xy($x, $y);
  if (is_sip_file_based_log_running()) {
    print "[ ] SIP Always ON";
  } else {
    print "[ ] SIP";
  }
  goto_xy($x, $y+1);
  print "[ ] PPM";
  goto_xy($x, $y+2);
  print "[ ] Call Processing";
  goto_xy($x, $y+3);
  print "[ ] TLS handshaking";
  goto_xy($x, $y+4);
  print "[ ] Push Notifications";
  goto_xy($x+4, $y+6);
  print " OK ";
  $x += 1;

  $_[2] = $x;
  $_[3] = $y;
}

sub refresh_checkbox {
  my ($x, $y, $pos) = @_;
  goto_xy($x, $y);

  for $i (0..6) {
    $reverse = "";
    $reverse = "reverse" if $pos == $i;

    if ($i < 5) {
      $label = " ";
      $label = "X" if $chekbox[$i];
      goto_xy($x, $y+$i);  
      print colored($label,$reverse);
    } elsif ($i == 5) {  # OK
      goto_xy($x+3, $y+6);
      $label = "   OK   ";
      print colored($label,$reverse);
    } elsif ($i == 6) {  # CANCEL
      goto_xy($x+13, $y+6);
      $label = " CANCEL ";
      print colored($label,$reverse);
    } 
  }
}

sub toggle_name_ip {
  if ($display_name) {
    $display_name = 0;
  } else {
    $display_name = 1;
  }

  reset_call_flow_refresh();

  if ($display_mode eq "call summary") {
    cl_paint_all();
  } else {
    dg_refresh_header();
  }
  change_mode($capture_mode,$display_mode);
}

sub toggle_rtp {
  my $w = 30;
  my $h = 3;
  my ($x, $y);

  $display_mode = "refiltering_rtp";
  create_box($w,$h);
  $x = ($max_col - $w-2)/2 + 1;
  $y = $dg_top_margin + ($max_row-$dg_top_margin-1 - $h-2)/2 + 2;
  goto_xy($x, $y);
  print "       Please wait...";

  if ($display_rtp) {
    $display_rtp = 0;
  } else {
    $display_rtp = 1;
  }
  change_mode($capture_mode,$display_mode);
  refilter();
}

sub clear_capture {
  return if $capture_mode =~ /file|opening_file/;
  lock(@dg_records);lock(@display_dg_records);lock(%calls);lock(%sessions);lock(%apns_tx);
  lock($cl_top_pos);lock($cl_rec_pos);lock(%call_summary);lock(@display_cl_record);
  lock(@queue_asm_records);lock(@queue_sip_records);lock(@queue_ppm_records);lock(@queue_tls_records);lock(@queue_push_records);
  lock($current_sip_record);lock($current_asm_record);lock($current_ppm_record);lock($current_tls_record);lock($current_push_record);

  # Reset the start time when the user clears
  set_start_capture_time();

  %dg_columns = ();
  %calls = ();
  %apns_tx = ();
  %sessions = ();
  %call_summary = ();
  %tls_streams = ();
  @display_cl_record = ();
  @display_dg_records = ();
  @dg_records = ();
  @queue_asm_records = ();
  @queue_sip_records = ();
  @queue_ppm_records = ();
  @queue_tls_records = ();
  @queue_push_records = ();
  $current_sip_record = 0;
  $current_asm_record = 0;
  $current_ppm_record = 0;
  $current_tls_record = 0;
  $current_push_record = 0;

  dg_init_positions("bottom");
  cl_init_positions("bottom");

  # update the window title
  set_title();

  if ($display_mode eq "call summary") {
    cl_paint_all();
    $display_mode = "call summary";
    $prev_display_mode = "call summary";
  } else {
    dg_paint_all();
    $display_mode = "diagram";
    $prev_display_mode = "diagram";
  }
  $max_exceeded = 0;
}

sub change_mode {
  ($capture_mode, $display_mode) = @_;
  my $dg_record_no = scalar (@display_dg_records);
  my $asm_asset;
  my $name_ip;
  my $rtp_nortp;
  my $diagram_call_summary;
  my $enter_key;
  my $full_screen;

  if ($show_asm) {
    $asm_asset = "HideSM";
  } else {
    $asm_asset = "ShowSM";
  }

  if ($display_name) {
    $name_ip = "IP";
  } else {
    $name_ip = "Name";
  }
 
  if ($display_rtp) {
    $rtp_nortp = "No_RTP";
  } else {
    $rtp_nortp = "RTP";
  } 

  if ($display_mode eq "call summary") {
    $diagram_call_summary = "Diagram";
    $enter_key = "Filter call";
    if ($cl_view) {
      $cl_nav_column = "LEFT=All columns";
    } else {
      $cl_nav_column = "RIGHT=Call flow";
    }
  } else {
    $diagram_call_summary = "Calls";
    $enter_key = "Details";
  }
  if ($display_mode eq "details") {
    if ($full_screen_details) {
      $full_screen = " u=Normal Screen"; 
    } else {
      $full_screen = " u=Full Screen";
    } 
  }

  if ($capture_mode eq "starting") {
    change_status_bar_mode("Initiating...","blue on_yellow");
    change_status_bar_keys("Please wait...");
  } elsif ($capture_mode eq "start") {
    change_status_bar_mode("Capturing","blue on_green");
    if ($display_mode eq "call summary") {
      change_status_bar_keys("s=Stop q=Quit ENTER=$enter_key f=Filters w=Write a=$asm_asset c=Clear i=$name_ip d=$diagram_call_summary $cl_nav_column");
    } else {
      change_status_bar_keys("s=Stop q=Quit ENTER=$enter_key f=Filters w=Write a=$asm_asset c=Clear i=$name_ip r=$rtp_nortp g=GoTo d=$diagram_call_summary$full_screen");
    }
  } elsif ($capture_mode eq "stopping") {
    change_status_bar_mode("Stopping...","blue on_yellow");
    change_status_bar_keys("");
  } elsif ($capture_mode eq "stop") {
    change_status_bar_mode("Stopped","blue on_red");
    if ($display_mode eq "call summary") {
      change_status_bar_keys("s=Start q=Quit ENTER=$enter_key f=Filters w=Write a=$asm_asset c=Clear i=$name_ip d=$diagram_call_summary $cl_nav_column");
    } else {
      change_status_bar_keys("s=Start q=Quit ENTER=$enter_key f=Filters w=Write a=$asm_asset c=Clear i=$name_ip r=$rtp_nortp g=GoTo d=$diagram_call_summary$full_screen");
    }
  } elsif ($capture_mode =~ /file|opening_file/) {
    if (scalar(@asm_files) + scalar(@asset_files) + scalar(@ppm_files) + scalar(@tls_files) > 1) {
      change_status_bar_mode("Multiple files","blue on_yellow");
    } else {
      if (scalar(@asm_files) > 0) { 
        change_status_bar_mode("$asm_files[0]","blue on_yellow");
      } elsif (scalar(@ppm_files) > 0) {
        change_status_bar_mode("$ppm_files[0]","blue on_yellow"); 
      } elsif (scalar(@tls_files) > 0) {
        change_status_bar_mode("$tls_files[0]","blue on_yellow"); 
      } else {
        change_status_bar_mode("$asset_files[0]","blue on_yellow");
      }
    }
    if ($display_mode eq "call summary") {
      change_status_bar_keys("q=Quit ENTER=$enter_key f=Filters w=Write a=$asm_asset i=$name_ip d=$diagram_call_summary $cl_nav_column");
    } else {
      change_status_bar_keys("q=Quit ENTER=$enter_key f=Filters w=Write a=$asm_asset i=$name_ip r=$rtp_nortp g=GoTo d=$diagram_call_summary$full_screen");
    }
  }
 
  if (!$dg_record_no && $display_mode ne "call summary") {
    display_message();
  }
}

sub process_asm_file {
  my($file, $file_name) = @_;
  my $in_multiline = "";
  my $max_dg_records = $max_packets;  # Stop the capture if there are more than 10000 packets
  my $file_size = -s $file_name;
  undef(%message);
  binmode STDOUT, ':utf8';
  my $prev_time = 0;
  my $window_time = 0;
  my $window_pos = 0;
  my $per_complete = 0;
  my $eta = -1;
  my @perf_history;
  my $full_file_name = $file_name;
  $file_name = basename($file_name);
  my $inode = stat($file)->ino;
  my $count = 0;
  my $curpos = 0;

  for (;;) {
#print TMP "max_exceeded: $max_exceeded\n";
    if (!$max_exceeded) {
      for ($curpos = tell($file); $_ = <$file>; $curpos = tell($file)) {
        ###### BEGIN CALL PROCESSING (SM) ######################### 
        if (/^(\d+[-\/]\d+[-\/]\d+) (\d{2}:\d{2}:\d{2}[,\.]\d{3})\s?(.*)/) {
          $message{day} = $1;
          $message{timestamp} = $2;
          $message{message} = $3;
          if ($message{message} =~ /FINEST - [A-Z]+\(.*\): getRoutePolicies\(\) for \d+ returned List\[$/) {
            $in_multiline = "RoutePolicies";
          } else {
            $in_multiline = "";
            process_asm_message(\%message); 
            undef(%message);
          }
        } elsif ($in_multiline eq "RoutePolicies") {
          chop($_);
          $message{message} .= $_;
          if (/\]\]$/) {
            $in_multiline = "";
            process_asm_message(\%message);
            undef(%message);
          }
        } 
        ###### END CALL PROCESSING (SM) ###########################
  
        # Slow down if throttle is enabled (default)
        if (!($throttle)) {
          # Pause for 0.0001 seconds to avoid high CPU usage
          select(undef, undef, undef, 0.0001);
        }
        # Display percentage and remainding time
        if ($capture_mode eq "opening_file" && (time() - $prev_time > 1)) {
          if ($file_size != 0) {
            $per_complete = $curpos * 100 / $file_size;
          } else {
            $per_complete = 100;
          }
  
          $his{pos} = $curpos;
          $his{time} = time();
          push(@perf_history,{%his});
          $eta = -1;
          if (scalar(@perf_history) > 5) {
            $hist = shift(@perf_history);
            
            $window_time = time() - $hist->{time};
            $window_pos = $curpos - $hist->{pos};
            if ($window_pos != 0) {
              $eta = ($file_size-$curpos)*$window_time/$window_pos;
            }
          }
  
          if ($eta == -1) {
            $eta = "n/a";
          } else { 
            my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = gmtime($eta);
            $eta = sprintf("%02d:%02d:%02d", $hour+($mday-1)*24, $min, $sec);
          }
          $label = "Opening ".$file_name." (".int($per_complete)."%  ETA: ".$eta.")";
          my $w = length($label);
          my $h = 1;
          display_text_box($w,$h,$label);
          $prev_time = time();
        }
      }
    } else {
      seek($file, 0, SEEK_END);
      $curpos = tell($file);
    }
    $count++;
    # This is to simulate a 'tail -f'
    sleep(1);
    my $dg_record_no = scalar (@dg_records);

    # Refresh the call summary screen
    if ($display_mode eq "call summary" && $cl_need_refresh) {
      cl_paint_all();
    }

    # update the window title
    set_title();
    if ($tail_log) {
      seek($file, $curpos, 0);

      # Check if log file has rotated (using inode) and we have finsihed
      # processing the complete file (using the file size -s)
      # The log rotation is done by log4j
      if ($inode != stat($full_file_name)->ino && (-s $file) == $curpos) {
        close($file);
        open(FILE, "$full_file_name") || die_message("Can't open $full_file_name file.\nERROR: $!\n");
        $file = \*FILE;
        $inode = stat($file)->ino;
      }
    } else {
      last;
    }
    # To prevent the capture to run forever, 
    # stop after 10k packets.
    if ( $dg_record_no > $max_dg_records ) {
      $max_exceeded = 1;
    }
  }
}

sub process_asset_file {
  my($file, $file_name) = @_;
  my $max_dg_records = $max_packets;  # Stop the capture if there are more than 10000 packets
  my $file_size = -s $file_name;
  undef(%message);
  binmode STDOUT, ':utf8';
  my $prev_time = 0;
  my $window_time = 0;
  my $window_pos = 0;
  my $per_complete = 0;
  my $eta = -1;
  my @perf_history;
  my @fragments;
  my $separator = 0;
  my $curpos = 0;
  my $full_file_name = $file_name;
  $file_name = basename($file_name);
  my $count = 0;
  my $prev_capture_mode = is_capture();
  my $file_rotated = 0;
  for (;;) {
    if (!$max_exceeded) {
      my $syslog_output = 1;
      for ($curpos = tell($file); $_ = <$file>; $curpos = tell($file)) {
#print TMP $_;
        if ($syslog_output) {
          #print TMP "syslog trace output detected undef message \n";
          undef(%message);
        }
        if (/SIPMSGT (MESSAGE DROPPED BY:([^-]*)-* REASON:(.*))?$/) {
          # rsyslog trace output over several lines
          $syslog_output = 0;
          #print TMP "rsyslog trace detected syslog_output $syslog_output undef message \n";
          #If message is already defined then process it before undef.
          process_sip_packet(\%message) if ($inMsg && %message);
          undef(%message);
          $inHdr = 1; $inMsg = 0;
          if ($1 ne "") { # Message dropped by SM100
            #print TMP "message dropped found\n";
            $message{dropped_by} = $2;
            $message{dropped_reason} = $3;
          }
        }
        elsif (/SIPMSGT /) {
          # rsyslog trace output over several lines
          $syslog_output = 0;
          #print TMP "rsyslog trace detected syslog_output $syslog_output undef message \n";
          process_sip_packet(\%message) if ($inMsg && %message);
          undef(%message);
          $inHdr = 1; $inMsg = 0;
        }
        elsif ($inHdr) {
          if (($date,$time,$dir) = /^(\S+) (\S+) ([-<]-[->v]) $/) {
            $message{day} = $date;
            $message{timestamp} = $time;
            #print TMP "Set message{timestamp} $message{timestamp}\n";
            $message{send_receive} = $dir;
            $inHdr++;
          }
          elsif (($msglen,$bodylen) = /octets: (\d+), Body Length: (\d+)/) {
            $message{msglen} = $msglen;
            $message{bodylen} = $bodylen;
            #print TMP "msglen $msglen bodylen $bodylen\n";
          }
          elsif (($x) = /ingress: (.*)$/) {
            $ingress = $x;
            $message{ingress} = $ingress;
          }
          elsif (($x) = /egress: (.*)$/) {
            $egress = $x;
            $message{egress} = $egress;
          }
          elsif (/Req: \S+e, TH: \S+e, instance: \S+e, isSIPS req'd: \S+e/) {
            $message{context} = $_;
            #print TMP "message{context} $message{context}\n";
          }
          elsif ($inHdr > 1 && (/^-+$/)) {
            if ($message{send_receive} eq '-->') {  # incoming to the SM100
              $message{send_receive} = "Incoming";
              ($message{local_host},$message{local_port},$message{host},$message{port},$message{protocol}) = parse_connection_line($message{ingress});
              
              # Commenting out this block as WAS does not bind on the Asset IP as SIPAS used to do
              # Incoming messages from the SIPAS to SM100 could have the same SM100 IP
              #if ($message{local_host} eq $message{host}) {
              #  #print TMP "message{host} $message{host}   asm_ip $asm_ip\n";
              #  $message{host} = $asm_ip;
              #}
            } elsif ($message{send_receive} eq '<--') { # outgoing from the SM100
              $message{send_receive} = "Outgoing";
              ($message{local_host},$message{local_port},$message{host},$message{port},$message{protocol}) = parse_connection_line($message{egress});
              #print TMP "asm_ip $asm_ip\n\n";
#              if ($asm_ip eq "uknown" || $asm_ipv6 eq "uknown v6") {
#                if ($message{context} =~ /instance: true/) {
#                  if( ($ingress_remote) = $message{ingress} =~ /R([\d\.]+|\[[^\]]*\]):.*/ ) {
#                    if ($ingress_remote ne "$message{local_host}") {
#                      if (is_ipv4($ingress_remote)) { # IPv4
#                        $asm_ip = $ingress_remote;
#                        # Rename the "uknown" column and update IPs as we now know the IP of ASM
#                        update_uknown_IP();
#                      } else { # IPv6
#                        $ingress_remote =~ s/^\[(.*)\]$/\1/; # remove the [ and ] on the IPv6
#                        $asm_ipv6 = $ingress_remote;
#                        # Rename the "uknown" column and update IPs as we now know the IP of ASM
#                        update_uknown_IPv6();
#                      }
#                    }
#                  }
#                } elsif ($message{context} =~ /toSD: true/) {
#                  my ($ip) = $message{egress} =~ /R([\d\.]+|\[[^\]]*\]):.*/;
#                  if (is_ipv4($ip)) { # IPv4
#                    $asm_ip = $ip;
#                    # Rename the "uknown" column and update IPs as we now now the IP of ASM
#                    update_uknown_IP();
#                  } else { # IPv6
#                    $ip =~ s/^\[(.*)\]$/\1/; # remove the [ and ] on the IPv6
#                    $asm_ipv6 = $ip;
#                    # Rename the "uknown v6" column and update IPs as we now now the IP of ASM
#                    update_uknown_IPv6();
#                  }
#                }
#              }
# 
              # Commented this block as this should not apply for WAS  
              # Outgoing messages from SM100 to SIPAS could have same SM100 IP
              #if ($message{local_host} eq $message{host}) {
              #  #print TMP "Outgoing message{host} $message{host}   asm_ip $asm_ip\n";
              #  $message{host} = $asm_ip;
              #}
  
            } elsif ($message{send_receive} eq '--v') { # dropped by SM100
              $message{send_receive} = "Incoming";
              ($message{local_host},$message{local_port},$message{host},$message{port},$message{protocol}) = parse_connection_line($message{ingress});
            }
#            if (is_ipv4($message{local_host})) { # IPv4
#              $sm100_ip = $message{local_host};
              # REMOVE ME! NOT SURE WHAT THIS CODE WAS ABOUT
              # If packet is from/to SM, then change the IP to the SM
              #if ($message{host} =~ "$asm_ip" ) {
              #  $message{host} = "$asm_ip";
              #}
#            } else { # IPv6
#              $sm100_ipv6 = $message{local_host};
#print TMP "other sm100_ipv6 $sm100_ipv6\n";
              # REMOVE ME! NOT SURE WHAT THIS CODE WAS ABOUT
              # If packet is from/to SM, then change the IP to the SM
              #if ($message{host} =~ "$asm_ipv6" ) {
              #  $message{host} = "$asm_ipv6";
              #}
#            }
            $inHdr = 0; $inMsg = 1;
            #print TMP "Finished reading header\n";
          }
        } # end of inHdr
        elsif ($inMsg) {
          # TODO: dangerous if SIP message just happens to have this pattern
          if ((($msgc) = /AasSipMgr.*SIPMSGT\+ (.*)$/)) {
            $msgc =~ s/\r//g;
            if(length $msgc > 0) {
              #print TMP "While inMsg detected multi-part record msgc $msgc\n";
              $message{sip} =~ s/\n$// if $message{sip} !~ /\r\n$/; # remove the last \n added when message is truncated , unless it ends with CR/NL as that is not correctly propagated to the next fragment.
              $message{sip} =~ s/\r//g; # Remove all the CR
              if ($msgc =~ /^-+$/) {
                $message{end_of_sip} .= $msgc;
                if ($message{end_of_sip} eq "--------------------") {
                  process_sip_packet(\%message); 
                  undef(%message);
                  $inHdr = 1; $inMsg = 0;
                }
              } else {
                $message{sip} .= $msgc."\n" if $msgc;
              }
            }
          }
          elsif (/^(-+)$/) {
              $message{end_of_sip} .= $1;
              $message{sip} =~ s/\r//g; # Remove all the CR
              if ($message{end_of_sip} eq "--------------------") {
                #print TMP "end of msg detected\n";
                process_sip_packet(\%message); 
                undef(%message);
                $inHdr = 1; $inMsg = 0;
              }
            #print TMP "Finished reading message so call process_sip_packet with message{timestamp} $message{timestamp}\n";
          } else {
            #s/\r//g;
            $message{sip} .= $_;
            #print TMP "Added another sip message line\n";
          }
        } # end of inMsg
        elsif (/^### traceSM (.*)/) {
          read_metadata($1); 
        } 
 
        ############################################################
        # Slow down if throttle is enabled (default)
        if (!($throttle)) {
          # Pause for 0.0001 seconds to avoid high CPU usage
          select(undef, undef, undef, 0.0001);
        }
        # Display percentage and remainding time
        if ($capture_mode eq "opening_file" && (time() - $prev_time > 1)) {
          if ($file_size != 0) {
            $per_complete = $curpos * 100 / $file_size;
          } else {
            $per_complete = 100;
          }
  
          $his{pos} = $curpos;
          $his{time} = time();
          push(@perf_history,{%his});
          $eta = -1;
          if (scalar(@perf_history) > 5) {
            $hist = shift(@perf_history);
  
            $window_time = time() - $hist->{time};
            $window_pos = $curpos - $hist->{pos};
            if ($window_pos != 0) {
              $eta = ($file_size-$curpos)*$window_time/$window_pos;
            }
          }

          if ($eta == -1) {
            $eta = "n/a";
          } else {
            my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = gmtime($eta);
            $eta = sprintf("%02d:%02d:%02d", $hour+($mday-1)*24, $min, $sec);
          }
          $label = "Opening ".$file_name." (".int($per_complete)."%  ETA: ".$eta.")";
          my $w = length($label);
          my $h = 1;
          display_text_box($w,$h,$label);
          $prev_time = time();
        }
      }
    } else {
      seek($file, 0, SEEK_END);
      $curpos = tell($file);
    }
    $count++;
    # This is to simulate a 'tail -f'
    sleep(1);
    my $record_no = scalar (@dg_records);

    # Check if any SM100/CallP/PPM/TLS is capturing every 10 seconds
    if ($count % 10 == 0) {
      my $new_capture_mode = is_capture();
      if (($prev_capture_mode ne $new_capture_mode) && ($display_mode eq "diagram") && ($capture_mode ne "starting")) {
        if ($new_capture_mode) {
          change_mode("start",$display_mode);
        } else {
          change_mode("stop",$display_mode);
        }
      }
      $prev_capture_mode = $new_capture_mode;
    }

    # update the window title
    set_title();

    if ($tail_log) {
      if ($file_rotated) {
        # Close the current file and reopen it.
        close($file);
        open(FILE, "$full_file_name") || die_message("Can't open $full_file_name file.\nERROR: $!\n");
        $file = \*FILE;
        $file_rotated = 0;
      } else {
        # Move to file offset to the current position
        seek($file, $curpos, 0);

        # Check if log file has rotated using the file size. 
        # The inode does not change when asset (rsyslog) rotates it
        if ((-s $file) < $curpos) {
          $file_rotated = 1;
          # Need to process the last lines of the previous file
          close($file);
          if(is_sip_file_based_log_running()) {
            $latest_rotated_file_name = `ls -tr /var/log/Avaya/sip_trace/sip_trace.log.* | tail -1`;
	  } else {
            $latest_rotated_file_name = `ls -tr /var/log/Avaya/trace/tracer_asset.log.* | tail -1`;
          }
          open(FILE, "$latest_rotated_file_name") || die_message("Can't open $latest_rotated_file_name file.\nERROR: $!\n");
		  #print TMP "Processing $latest_rotated_file_name\n";
          $file = \*FILE;
          seek($file, $curpos, 0);
        }
      }
    } else {
      last;
    }
    # To prevent the capture to run forever,
    # stop after 10k packets.
    if ( $record_no > $max_dg_records ) {
      $max_exceeded = 1;
    }
  }
}

sub parse_connection_line {
  my $line = shift;
  my ($local_host, $local_port, $remote_host, $remote_port, $protocol) = $line =~ /L([\d\.:]+|\[[^\]]*\]):(\d+)\/R([\d\.:]+|\[[^\]]*\]):(\d+)\/(.*)\//;

  # Remove the [ ] for IPv6 
  $local_host =~ s/^\[(.*)\]$/\1/; 
  $remote_host =~ s/^\[(.*)\]$/\1/;
  
  return ($local_host, $local_port, $remote_host, $remote_port, $protocol);
}

sub process_onexc_file {
  my($file, $file_name) = @_;
  my $max_dg_records = $max_packets;  # Stop the capture if there are more than 10000 packets
  my $file_size = -s $file_name;
  undef(%message);
  binmode STDOUT, ':utf8';
  my $prev_time = 0;
  my $window_time = 0;
  my $window_pos = 0;
  my $per_complete = 0;
  my $eta = -1;
  my @perf_history;
  my @fragments;
  my $separator = 0;
  my $curpos = 0;
  my $full_file_name = $file_name;
  $file_name = basename($file_name);
  my $count = 0;
  my $prev_capture_mode = is_capture();
  my $file_rotated = 0;
  $sm100_ip = "1.1.1.1";
  for (;;) {
    if (!$max_exceeded) {
      for ($curpos = tell($file); $_ = <$file>; $curpos = tell($file)) {
#print TMP $_;
        if ($type eq "onexc") {
          if (($date,$time,$id,$dir,$dummy,$ip,$port) = /\[(\S+) (\S+)\] DBH:\s+SIGNAL: \[(\S+)\] (SENT|RECEIVED) (from|to) (\d+\.\d+\.\d+\.\d+):(\d+)/) {
            undef(%message);
            $message{day} = $date;
            $message{timestamp} = $time;
            $message{id} = $id;
            #print TMP "Set message{timestamp} $message{timestamp}\n";
            if ($dir eq "SENT") {
              $message{send_receive} = "Outgoing";
            } else { # RECEIVED
              $message{send_receive} = "Incoming";
            }
            $message{host} = $ip;
            $message{port} = $port;
            $message{local_port} = 1111; # TODO: Instead of 1111 look in the SIP message Via/Contact for the actual port
            $message{local_host} = $sm100_ip; # TODO: Instead of 1.1.1.1 look in the SIP message Via/Contact for the actual phone IP
  
            $inHdr = 1; $inMsg = 0;
          } elsif ($inHdr) {
            if (/^\{\r?$/) {
              $inHdr = 0; $inMsg = 1;
            }
          } elsif ($inMsg) { # end of inHdr
            if (/^(.*)\[$message{id}\] \}\r?$/) { # END OF SIP MESSAGE
              $message{sip} .= $1; 
              process_sip_packet(\%message);
              undef(%message);
              $inHdr = 0; $inMsg = 0;
            } elsif (/^\[$message{id}\] ([^\r]*\r?)/) {
              #$1 =~ s/\r//g;
              $message{sip} = $1;
              $message{sip} =~ s/\r/\n/g;
            } else {
              s/\r//g;
              $message{sip} .= $_;
            } 
          } 
        } else { # $type = "ios"
          if (($year,$month,$day,$hour,$minute,$second,$millisecond,$dir,$ip,$port) = /\[(\d{4})\/(\d{2})\/(\d{2}) (\d{2}):(\d{2}):(\d{2}):(\d{1,3})\] (RECEIVED|SENDING) \d+ bytes (?:from|to) (\d+\.\d+\.\d+\.\d+):(\d+) \{/) {
            undef(%message);
            $message{day} = "$day/$month/$year";
            $message{timestamp} = "$hour:$minute:$second.$millisecond";
            #print TMP "Set message{timestamp} $message{timestamp}\n";
            if ($dir eq "SENDING") {
              $message{send_receive} = "Outgoing";
            } else { # RECEIVED
              $message{send_receive} = "Incoming";
            }
            $message{host} = $ip;
            $message{port} = $port;
            $message{local_port} = 1111; # TODO: Instead of 1111 look in the SIP message Via/Contact for the actual port
            $message{local_host} = $sm100_ip; # TODO: Instead of 1.1.1.1 look in the SIP message Via/Contact for the actual phone IP
  
            $inHdr = 1; $inMsg = 0;
          } elsif ($inHdr) {
            if (/^$/) { # Empty line after the first line
              $inHdr = 0; $inMsg = 1;
            }
          } elsif ($inMsg) { # end of inHdr
            if (/^\}$/) { # END OF SIP MESSAGE
              process_sip_packet(\%message);
              undef(%message);
              $inHdr = 0; $inMsg = 0;
            } else {
              s/\r//g;
              $message{sip} .= $_;
            } 
          } 
        } 
        ############################################################
        # Slow down if throttle is enabled (default)
        if (!($throttle)) {
          # Pause for 0.0001 seconds to avoid high CPU usage
          select(undef, undef, undef, 0.0001);
        }
        # Display percentage and remainding time
        if ($capture_mode eq "opening_file" && (time() - $prev_time > 1)) {
          if ($file_size != 0) {
            $per_complete = $curpos * 100 / $file_size;
          } else {
            $per_complete = 100;
          }
  
          $his{pos} = $curpos;
          $his{time} = time();
          push(@perf_history,{%his});
          $eta = -1;
          if (scalar(@perf_history) > 5) {
            $hist = shift(@perf_history);
  
            $window_time = time() - $hist->{time};
            $window_pos = $curpos - $hist->{pos};
            if ($window_pos != 0) {
              $eta = ($file_size-$curpos)*$window_time/$window_pos;
            }
          }

          if ($eta == -1) {
            $eta = "n/a";
          } else {
            my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = gmtime($eta);
            $eta = sprintf("%02d:%02d:%02d", $hour+($mday-1)*24, $min, $sec);
          }
          $label = "Opening ".$file_name." (".int($per_complete)."%  ETA: ".$eta.")";
          my $w = length($label);
          my $h = 1;
          display_text_box($w,$h,$label);
          $prev_time = time();
        }
      }
    } else {
      seek($file, 0, SEEK_END);
      $curpos = tell($file);
    }
    $count++;
    # This is to simulate a 'tail -f'
    sleep(1);
    my $record_no = scalar (@dg_records);

    # Check if any SM100/CallP/PPM/TLS is capturing every 10 seconds
    if ($count % 10 == 0) {
      my $new_capture_mode = is_capture();
      if (($prev_capture_mode ne $new_capture_mode) && ($display_mode eq "diagram") && ($capture_mode ne "starting")) {
        if ($new_capture_mode) {
          change_mode("start",$display_mode);
        } else {
          change_mode("stop",$display_mode);
        }
      }
      $prev_capture_mode = $new_capture_mode;
    }

    # update the window title
    set_title();

    if ($tail_log) {
      if ($file_rotated) {
        # Close the current file and reopen it.
        close($file);
        open(FILE, "$full_file_name") || die_message("Can't open $full_file_name file.\nERROR: $!\n");
        $file = \*FILE;
        $file_rotated = 0;
      } else {
        # Move to file offset to the current position
        seek($file, $curpos, 0);

        # Check if log file has rotated using the file size. 
        # The inode does not change when asset (rsyslog) rotates it
        if ((-s $file) < $curpos) {
          $file_rotated = 1;
          # Need to process the last lines of the previous file (traceser_asset.log.1)
          close($file);
          open(FILE, "$full_file_name".".1") || die_message("Can't open $full_file_name.1 file.\nERROR: $!\n");
          $file = \*FILE;
          seek($file, $curpos, 0);
        }
      }
    } else {
      last;
    }
    # To prevent the capture to run forever,
    # stop after 10k packets.
    if ( $record_no > $max_dg_records ) {
      $max_exceeded = 1;
    }
  }
}

sub process_ppm_file {
  my($file, $file_name) = @_;
  my $in_multiline = "";
  my $max_dg_records = $max_packets;  # Stop the capture if there are more than 10000 packets
  my $file_size = -s $file_name;
  undef(%message);
  binmode STDOUT, ':utf8';
  my $prev_time = 0;
  my $window_time = 0;
  my $window_pos = 0;
  my $per_complete = 0;
  my $eta = -1;
  my @perf_history;
  my $full_file_name = $file_name;
  $file_name = basename($file_name);
  my $inode = stat($file)->ino;
  my $count = 0;
  my $curpos = 0;

  for (;;) {
    if (!$max_exceeded) {
      for ($curpos = tell($file); $_ = <$file>; $curpos = tell($file)) {
        ###### BEGIN PPM ######################### 
        #if (/^(\d+[-\/]\d+[-\/]\d+) (\d{2}:\d{2}:\d{2}[,\.]\d{3})\s\w+\s.*\s\[Seq-(\d+)\]\s(.*)/) {
        if (/^(\d+[-\/]\d+[-\/]\d+) (\d{2}:\d{2}:\d{2}[,\.]\d{3})\s\w+\s(.*)/) {
          if ($in_multiline ne "") {
            $in_multiline = "";
            process_ppm_message(\%message);
            undef(%message);
          }
          $message{type} = "PPM";
          $message{day} = $1;
          $message{timestamp} = $2;
          if ($3 =~ /.*\s\[Seq-(\d+)\]\s(.*)/) {
            $message{seq} = $1;
            $message{message} = $2;
          } else {
            next;
          }
          if ($message{message} =~ /PPM Client Request:/) {
            $in_multiline = "request";
            $message{send_receive} = "Incoming";
            $message{message} = "";
          } elsif ($message{message} =~ /PPM Server( Fault | )Response:/) {
            $in_multiline = "response";
            $message{send_receive} = "Outgoing";
            $message{message} = "";
          } else {
            $in_multiline = "";
            process_ppm_message(\%message);
            undef(%message);
          }
        } elsif ($in_multiline ne "") {
          #chop($_);
          $message{message} .= $_ unless /^\s*$/;
          if (!$message{operation}) {
            if (/^<ns1?:(\w+)\sxmlns:ns1?.*/) {
              $message{operation} = $1;
            } elsif (/^  <faultstring>(.*)<\/faultstring>/) {
              $message{operation} = "Fault";
              $message{fault} = $1;
            }
          } 
          if (/^<\/ns1?:/ or /^<\/SOAP-ENV:Fault>/) {
            $in_multiline = "";
            process_ppm_message(\%message);
            undef(%message);
          }
        } 
        ###### END PPM ###########################
  
        # Slow down if throttle is enabled (default)
        if (!($throttle)) {
          # Pause for 0.0001 seconds to avoid high CPU usage
          select(undef, undef, undef, 0.0001);
        }
        # Display percentage and remainding time
        if ($capture_mode eq "opening_file" && (time() - $prev_time > 1)) {
          if ($file_size != 0) {
            $per_complete = $curpos * 100 / $file_size;
          } else {
            $per_complete = 100;
          }
  
          $his{pos} = $curpos;
          $his{time} = time();
          push(@perf_history,{%his});
          $eta = -1;
          if (scalar(@perf_history) > 5) {
            $hist = shift(@perf_history);
            
            $window_time = time() - $hist->{time};
            $window_pos = $curpos - $hist->{pos};
            if ($window_pos != 0) {
              $eta = ($file_size-$curpos)*$window_time/$window_pos;
            }
          }
  
          if ($eta == -1) {
            $eta = "n/a";
          } else { 
            my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = gmtime($eta);
            $eta = sprintf("%02d:%02d:%02d", $hour+($mday-1)*24, $min, $sec);
          }
          $label = "Opening ".$file_name." (".int($per_complete)."%  ETA: ".$eta.")";
          my $w = length($label);
          my $h = 1;
          display_text_box($w,$h,$label);
          $prev_time = time();
        }
      }
    } else {
      seek($file, 0, SEEK_END);
      $curpos = tell($file);
    }
    $count++;
    # This is to simulate a 'tail -f'
    sleep(1);
    my $dg_record_no = scalar (@dg_records);

    # update the window title
    set_title();
    if ($tail_log) {
      seek($file, $curpos, 0);

      # Check if log file has rotated (using inode) and we have finsihed
      # processing the complete file (using the file size -s)
      # The log rotation is done by log4j
      if ($inode != stat($full_file_name)->ino && (-s $file) == $curpos) {
        close($file);
        open(FILE, "$full_file_name") || die_message("Can't open $full_file_name file.\nERROR: $!\n");
        $file = \*FILE;
        $inode = stat($file)->ino;
      }
    } else {
      last;
    }
    # To prevent the capture to run forever, 
    # stop after 10k packets.
    if ( $dg_record_no > $max_dg_records ) {
      $max_exceeded = 1;
    }
  }
}

sub process_tls_file {
  my($file, $file_name) = @_;
  my $section = 1;
  my $max_dg_records = $max_packets;  # Stop the capture if there are more than 10000 packets
  my $file_size = -s $file_name;
  undef(%message);
  binmode STDOUT, ':utf8';
  my $prev_time = 0;
  my $window_time = 0;
  my $window_pos = 0;
  my $per_complete = 0;
  my $eta = -1;
  my @perf_history;
  my $full_file_name = $file_name;
  $file_name = basename($file_name);
  my $inode = stat($file)->ino;
  my $count = 0;
  my $curpos = 0;
  my $file_rotated = 0;

  %mon2num = qw(
    Jan 01  Feb 02  Mar 03  Apr 04  May 05  Jun 06
    Jul 07  Aug 08  Sep 09  Oct 10 Nov 11 Dec 12
  );

  for (;;) {
    if (!$max_exceeded) {
      for ($curpos = tell($file); $_ = <$file>; $curpos = tell($file)) {
        ###### BEGIN TLS #########################
#print TMP $_;
        # Frame (section=1)
        if ($section == 1) {
          if (/Arrival Time: (\w{3})\s+(\d+), (\d+) (\d+:\d+:\d+\.\d+)/) {
            $message{day} = $3."-".$mon2num{$1}."-".$2;
            $message{timestamp} = $4;
            $message{type} = "TLS";
            $section = 2; # Move to IP section (2)
          }

        # IP (section==2)
        } elsif ($section == 2) {
        #if ($section == 2) {
          if (($src,$dst) = /Internet Protocol Version 4, Src: (\d+\.\d+\.\d+\.\d+) .* Dst: (\d+\.\d+\.\d+\.\d+) .*/) {
            if ($sm100_ip eq $src) {
              $message{send_receive} = "Outgoing";
              $message{local_host} = $sm100_ip;
              $message{host} = $dst;
            } elsif ($sm100_ip eq $dst) {
              $message{send_receive} = "Incoming";
              $message{local_host} = $sm100_ip;
              $message{host} = $src;
            } else {
              #die_message("Soruce ($src) or Destiantion ($dst) does not match Asset IP ($sm100_ip)\n");
              # Could be eth2 in promiscuous on VM getting more packets than we need
              undef(%message);
              $record_layer_content = 0;
              $section = 1; # Next should be a new frame
              next;
            }
            $section = 3; # Move to TCP section (3)
          } elsif (($src,$dst) = /Internet Protocol Version 6, Src: ([^ ]*) .* Dst: ([^ ]*) .*/) {
            if ($sm100_ipv6 eq $src) {
              $message{send_receive} = "Outgoing";
              $message{local_host} = $sm100_ipv6;
              $message{host} = $dst;
            } elsif ($sm100_ipv6 eq $dst) {
              $message{send_receive} = "Incoming";
              $message{local_host} = $sm100_ipv6;
              $message{host} = $src;
            } else {
              #die_message("Soruce ($src) or Destiantion ($dst) does not match Asset IP ($sm100_ip)\n");
              # Could be eth2 in promiscuous on VM getting more packets than we need
              undef(%message);
              $record_layer_content = 0;
              $section = 1; # Next should be a new frame
              next;
            }
            $section = 3; # Move to TCP section (3)
          }
        # TCP (section==3)
        } elsif ($section == 3) {
          if (($src,$dst) = /Transmission Control Protocol, Src Port: (\d+) .*, Dst Port: (\d+) .*/) {
            if ($message{send_receive} eq "Outgoing") {
              $message{local_port} = $src;
              $message{port} = $dst;
            } else {
              $message{local_port} = $dst;
              $message{port} = $src;
            }
            $message{protocol} = "TCP";
            $section = 4; # Move to Record Layer section (4)
          }
        # TLS Record Layer (section==4)
        } elsif ($section == 4) {
          #if (($hand_type) = /^    .* Record Layer: Handshake Protocol: (.*)/) {
          if (($record_type, $record_desc) = /^    .* Record Layer: (Handshake Protocol|Encrypted Alert|Alert|Application Data)(?:: )?(.*)/) {
            $record_layer_content = 1;
            if ($record_type eq "Handshake Protocol") {
              $message{label} .= $record_desc.", ";
              $message{desc} .= $record_desc.", ";
            } elsif ($record_type eq "Application Data") {
              $message{label} .= "AppData, ";
              $message{desc} .= "Application Data, ";
            } elsif ($record_type eq "Encrypted Alert") {
              $message{label} .= "Alert, ";
              $message{desc} .= "Encrypted Alert, ";
            } elsif ($record_desc =~ /\(Level: (.*), Description: (.*)\)/) {
              $message{label} .= "Alert, ";
              $message{desc} .= "$1, $2, ";
            }
          }
          if ($record_layer_content and /^    /) {
            $message{msg} .= $_;
          }
        }

        # End of Frame. Process the message
        if (/--------------------------------------------/) {
          process_tls_message(\%message) if $section != 1;
          undef(%message);
          $record_layer_content = 0;
          $section = 1; # Next should be a new frame
          next;
        }

        ###### END TLS ###########################

        # Slow down if throttle is enabled (default)
        if (!($throttle)) {
          # Pause for 0.0001 seconds to avoid high CPU usage
          select(undef, undef, undef, 0.0001);
        }
        # Display percentage and remainding time
        if ($capture_mode eq "opening_file" && (time() - $prev_time > 1)) {
          if ($file_size != 0) {
            $per_complete = $curpos * 100 / $file_size;
          } else {
            $per_complete = 100;
          }

          $his{pos} = $curpos;
          $his{time} = time();
          push(@perf_history,{%his});
          $eta = -1;
          if (scalar(@perf_history) > 5) {
            $hist = shift(@perf_history);

            $window_time = time() - $hist->{time};
            $window_pos = $curpos - $hist->{pos};
            if ($window_pos != 0) {
              $eta = ($file_size-$curpos)*$window_time/$window_pos;
            }
          }

          if ($eta == -1) {
            $eta = "n/a";
          } else {
            my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = gmtime($eta);
            $eta = sprintf("%02d:%02d:%02d", $hour+($mday-1)*24, $min, $sec);
          }
          $label = "Opening ".$file_name." (".int($per_complete)."%  ETA: ".$eta.")";
          my $w = length($label);
          my $h = 1;
          display_text_box($w,$h,$label);
          $prev_time = time();
        }
      }
    } else {
      seek($file, 0, SEEK_END);
      $curpos = tell($file);
    }
    $count++;
    # This is to simulate a 'tail -f'
    sleep(1);
    my $dg_record_no = scalar (@dg_records);
    # update the window title
    set_title();
    if ($tail_log) {
      if ($file_rotated) {
        # Close the current file and reopen it.
        close($file);
        open(FILE, "$full_file_name") || die_message("Can't open $full_file_name file.\nERROR: $!\n");
        $file = \*FILE;
        $file_rotated = 0;
      } else {
        # Move to file offset to the current position
        seek($file, $curpos, 0);

        # Check if log file has rotated using the file size.
        # The inode does not change when logrotate rotates it
        if ((-s $file) < $curpos) {
          $file_rotated = 1;
          # Need to process the last lines of the previous file
          close($file);
          $latest_rotated_file_name = `ls -tr /var/log/Avaya/trace/tls_handshake.log.* | tail -1`;
          open(FILE, "$latest_rotated_file_name") || die_message("Can't open $latest_rotated_file_name file.\nERROR: $!\n");
          $file = \*FILE;
          seek($file, $curpos, 0);
        }
      }
    } else {
      last;
    }

    # To prevent the capture to run forever,
    # stop after 10k packets.
    if ( $dg_record_no > $max_dg_records ) {
      $max_exceeded = 1;
    }
  }
}

sub update_uknown_IP {
  return if (!exists($columns{"uknown"}));

  # Rename the "uknown" column with the ASM IP
  $columns{$asm_ip} = delete $columns{"uknown"};

  # Change all the "uknown" IPs on the messages
  foreach my $r (0..$#dg_records) {
    if ($dg_records[$r]{host} eq "uknown") {
      $dg_records[$r]{host} = $asm_ip;
    }
  }
}

sub update_uknown_IPv6 {
  return if (!exists($columns{"uknown v6"}));

  # Rename the "uknown v6" column with the ASM IP
  $columns{$asm_ipv6} = delete $columns{"uknown v6"};

  # Change all the "uknown v6" IPs on the messages
  foreach my $r (0..$#dg_records) {
    if ($dg_records[$r]{host} eq "uknown v6") {
      $dg_records[$r]{host} = $asm_ipv6;
    }
  }
}

sub process_ppm_message {
  my $params = shift;
  my %message = %$params;
  $_ = $message{message};
  lock(@dg_records);
  lock(@display_dg_records);
  lock(%calls);
  lock(%apns_tx);
  lock(%sessions);

  if ($message{send_receive} ne "") {
    # For PPM requests, we do not have the complete info (e.g. IP of the endpoint)
    # so defer for later 
    if ($message{send_receive} eq "Incoming") {
      $ppm_seq{$message{seq}}{timestamp} = $message{timestamp};
      $ppm_seq{$message{seq}}{message} = $message{message};
      $ppm_seq{$message{seq}}{operation} = $message{operation};
      ($ppm_seq{$message{seq}}{handle}) = $message{message} =~ /<[Hh]andle>(.*)<\/[Hh]andle>/;
    } else { # Outgoing response
      if (exists($ppm_seq{$message{seq}})) {
        $message{msg} = $message{message};
        $message{label} = $message{operation};
        $message{desc} = "PPM: ";
        if ($message{operation} eq "Fault") {
          $message{desc} .= "Fault: $message{fault}";
        } else {
          $message{desc} .= $message{operation};
        }
        $message{host} = $ppm_seq{$message{seq}}{host};
        if (is_ipv4($message{host})) {
          $message{local_host} = $sm100_ip;
        } else {
          $message{local_host} = $sm100_ipv6;
        }
        $message{handle} = $ppm_seq{$message{seq}}{handle};
        delete($ppm_seq{$message{seq}});
      } else {
        print TMP "ERROR: $message{timestamp} no seq for response $message{seq}\n";
      }
    }
  } elsif (/X-Forwarded-For header is (.*)/) {
    my $ip = $1;
    $message{host} = $ip;
    if (is_ipv4($ip)) {
      $message{local_host} = $sm100_ip; 
    } else {
      $message{local_host} = $sm100_ipv6;
    }
    # We now have the IP of the Endpoint, so process the Request
    if (exists($ppm_seq{$message{seq}})) {

      $message{msg} = $ppm_seq{$message{seq}}{message};
      $message{timestamp} = $ppm_seq{$message{seq}}{timestamp};
      #$message{label} = $message{operation};
      #$message{desc} = $message{operation};
      $message{label} = $ppm_seq{$message{seq}}{operation};
      $message{desc} = "PPM: ".$ppm_seq{$message{seq}}{operation};
      $message{send_receive} = "Incoming";
      $ppm_seq{$message{seq}}{host} = $message{host};
      $ppm_seq{$message{seq}}{local_host} = $message{local_host};
      $message{handle} = $ppm_seq{$message{seq}}{handle};    
    } else {
      print TMP "ERROR: $message{timestamp} no seq for $message{seq}\n";
    }
  }
  if ($message{label}) {
    queue_ppm_record(\%message);
  }
}

sub queue_ppm_record {
  my $params = shift;
  my %message = %$params;
  undef(%record);

  my ($year,$month,$day) = $message{day} =~ /(\d{4})-(\d{1,2})-(\d{1,2})/;
  my ($hour,$minute,$seconds,$milliseconds) = $message{timestamp} =~ /(\d{1,2}):(\d{1,2}):(\d{1,2}),(\d{1,3})?/;
  my $ts = timelocal($seconds,$minute,$hour,$day,$month-1,$year) + $milliseconds/1000;

  my $queue_ppm_records_no = scalar (@queue_ppm_records);
  $queue_ppm_records[$queue_ppm_records_no] = &share({});
  $queue_ppm_records[$queue_ppm_records_no]{day} = $message{day};
  $queue_ppm_records[$queue_ppm_records_no]{timestamp} = $message{timestamp};
  $queue_ppm_records[$queue_ppm_records_no]{time_seconds} = $ts;
  $queue_ppm_records[$queue_ppm_records_no]{send_receive} = $message{send_receive};
  $queue_ppm_records[$queue_ppm_records_no]{type} = $message{type};
  $queue_ppm_records[$queue_ppm_records_no]{desc} = $message{desc};
  $queue_ppm_records[$queue_ppm_records_no]{label} = $message{label};
  $queue_ppm_records[$queue_ppm_records_no]{msg} = $message{msg};
  $queue_ppm_records[$queue_ppm_records_no]{host} = $message{host};
  $queue_ppm_records[$queue_ppm_records_no]{local_host} = $message{local_host};
  $queue_ppm_records[$queue_ppm_records_no]{handle} = $message{handle};
}

sub process_asm_message {
  my $params = shift;
  my %message = %$params;
  $_ = $message{message};
  lock(@dg_records);
  lock(@display_dg_records);
  lock(%calls);
  lock(%apns_tx);
  lock(%sessions);

  $message{type} = "INFO";
  $message{color} = "blue on_green";
  $message{msg} = "";
  (my $category, my $type, my $method, my $callid, my $rest_line) = /^(.*) (FINE|FINER|FINEST|DEBUG|ERROR|WARN) - (?:\w+\.([A-Z]+)\((.*)\): )?(.*)/;
  $message{call_id} = $callid; 
  $_ = $rest_line;
 
  # Get originating SIP entity
  if (/getOriginatingEntity using parameters: (.*)/) {
    $message{label} = "Request originating SIP Entity";
    $message{desc} = "for: $1";
    $message{msg} = "Getting originating SIP Entity for '$1'";

  # Get originating SIP entity response
  } elsif (/getOriginatingEntity returned entity with id = (.*)/) {
    $message{label} = "Originating SIP Entity found";
    $message{desc} = "SIPEntity: ".get_name("sipentity",$1);
    $message{msg} = "Originating SIP Entity '".get_name("sipentity",$1)."' found.";

  # Get originating SIP entity not found
  } elsif (/getOriginatingEntity found no entity/) {
    $message{label} = "Originating SIP Entity or Entity Link not found";
    $message{desc} = "SIPEntity: <NOT FOUND>";
    $message{color} = "blue on_yellow"; 
    $message{msg} = "No SIP Entity found for the originating endpoint, or no Entity Link found/match.\n";
    $message{msg} .= "If the Endpoint is a non URE endpoint, make sure there is a SIP Entity that matches the source IP of the SIP request. And there is a Entity Link that matches the port and protocol."; 

  # Get originating SIP entity to match IP for the column header
  } elsif (/getSIPEntityByAddress\(.*\) returned \[SipEntity\[id=(\d+), name=\"(.*?)\", type=.*, addr=(.*), 3263=.*/) {
    $sipentity_ip{$3} = $1;
    $sipentity{$1} = $2;

  # Get ingress/egress adaptation
  } elsif (/adaptRequestUri: calling adapt direction: (INGRESS|EGRESS), digits: (.*), adaptation = Adaptation\[(name=(.*),adaptationModule=(.*),egressURIParameters=.*)\]/) {
    if ($1 eq INGRESS) { 
      $message{label} = "Request ingress Adaptation"; 
      $message{desc} = "Adapter: $4  for: $2";
      $message{msg} = "Calling ingress Adaptation '$4' module '$5' for '$2'\n\n";  
      $message{msg} .= "Adaptation: $3";  
    } else {
      $message{label} = "Request egress Adaptation"; 
      $message{desc} = "Adapter: $4  for: $2";
      $message{msg} = "Calling egress Adaptation '$4' module '$5' for '$2'\n\n";  
      $message{msg} .= "Adaptation: $3";  
    }

  # Get ingress/egress adaptation (6.1)
  } elsif (/In adapter, setting adaptation = Adaptation\[name=(.*),adaptationModule=(.*),egressURIParameters=.*\]/) {
    $message{label} = "Request Adaptation";
    $message{desc} = "Adapter: $1";
    $message{msg} = "Adaptation '$1' module '$2'";

  # Get ingress/egress adaptation response
  } elsif (/adaptToHeaders: adaptRequestUri returned digits: (.*)/) {
    return if $1 eq "null";
    $message{label} = "Adaptation result";
    $message{desc} = "result: $1";
    $message{msg} = "Adaptation result '$1'";

  # Applied ingress adapattion (6.1)
  } elsif (/applied ingress adaptations: \{(.*)\}/) {
    $message{label} = "Applied ingress Adaptation";
    $message{desc} = "$1";
    $message{msg} = "Applied ingress Adaptation '$1'";

  # Applied egress adapattion (6.1)
  } elsif (/egressHeaderMods: \{(.*)\}/) {
    if($1 ne '') {
      $message{label} = "Applied egress Adaptation";
      $message{desc} = "$1";
      $message{msg} = "Applied egress Adaptation '$1'";
    }

  # Invalid Adapation module
  } elsif (/No extension module was found for (.*) ThreadID: \d+/) {
    $message{label} = "Adaptation module not found";
    $message{desc} = "module: $1";
    $message{msg} = "Adaptation module '$1' was not found.\n";
    $message{msg} .= "Make sure the extension module '$1' is deployed.";
    $message{msg} .= " From the 'SIP A/S Managment Console':\n";
    $message{msg} .= "   -> Cluster Administration\n";
    $message{msg} .= "   -> Extensions\n";
    $message{msg} .= "   -> Service Host\n";
    $message{color} = "blue on_yellow";

  # Originating Location
  } elsif (/Found pattern match for (.*) to routing origination id (\d+)/) {
    $message{label} = "Location found";
    $message{desc} = "Location: ".get_name("routingorigination",$2);
    $message{msg} = "Location '".get_name("routingorigination",$2)."' was found for '$1'";

  # Originating Location not found
  } elsif (/No routing origination pattern match for (.*)/) {
    $message{label} = "Location not found";
    $message{desc} = "for: $1";
    $message{msg} = "No Location was found for '$1'";
    $message{color} = "blue on_yellow";

  # using SM Location
  } elsif (/Returning routing origination id (\d+) from my SIP Entity/) {
    $message{label} = "Using Session Manager Location";
    $message{desc} = "Location: ".get_name("routingorigination",$1);
    $message{msg} = "Using Session Manager Location '".get_name("routingorigination",$1)."'"; 

  # Request route
  } elsif (/Getting route for '(.*)' from origination (.*)/) {
    $message{label} = "Request Dial Pattern route";
    $message{desc} = "for: $1  Location: ".get_name("routingorigination",$2);
    $message{msg} = "Searching for a Dial Pattern route to '$1' from origination Location '".get_name("routingorigination",$2)."'";

  # Dial Pattern route parameters
  } elsif (/Calling getDigitMapRouter with parameters: (\S+) (\S+) (\S+)/) {
    $message{label} = "Dial Pattern route parameters";
    $message{desc} = "Orig Pattern Set Id: $3 URI Domain: $2  Location: ".get_name("routingorigination",$1);
    $message{msg} = "Attempting Dial Pattern route with URI domain '$2' and Location '".get_name("routingorigination",$1)."'";

  # Trying Dial Pattern route
  } elsif (/checking dmrMap for DigitMapRouter with domainId (.*) and locationId (.*)/) {
    $message{label} = "Trying Dial Pattern route";
    $message{desc} = "Domain: ".get_name("sipdomain",$1)."  Location: ".get_name("routingorigination",$2);
    $message{msg} = "Trying Dial Pattern route with Domain '".get_name("sipdomain",$1)."' and Location '".get_name("routingorigination",$2)."'";

  # Dial Pattern route found
  #} elsif (/Found digitMapId (.*) for digits <\s*(.*)\s*> and domain <\s*([^\s]*)\s*>/) {
  #  $message{label} = "Dial Pattern found";
  #  $message{desc} = "for: $2  Pattern: ".get_name("digitmap",$1);
  #  $message{msg} = "Dial Pattern '".get_name("digitmap",$1)."' was found for digits '$2' and domain '$3'"; 

  # Dial Pattern denied
  } elsif (/Digit map is denied for: (.*)/) {
    $message{label} = "Dial Pattern denied";
    $message{desc} = "for: $1";
    $message{msg} = "Dial Pattern was denied for '$1'";

  # Route found
  } elsif (/Route\(s\) were found by the SREEngine for (.*): \[(.*)\]/) {
    $message{label} = "Route found";
    $message{desc} = "for: $1  SIPEntity: ".get_name("sipentity",$2);
    $message{msg} = "Route(s) were found for '$1', destination SIP Entity(es) '".get_name("sipentity",$2)."'";

  # Rout denied
  } elsif (/Route denied for (.*)/) {
    $message{label} = "Route denied";
    $message{desc} = "for: $1";
    $message{msg} = "Route was denied for '$1'";
    $message{color} = "blue on_yellow"; 

  # All routing policies are disabled
  } elsif (/All routing policies are disabled for (.*)/) {
    $message{label} = "All Routing Policies disabled";
    $message{desc} = "for: $1";
    $message{msg} = "All Routing Policies are disabled for '$1'";
    $message{color} = "blue on_red";

  # No route found, proxying to LLNR
  } elsif (/No route was found by the SREEngine for (.*); proxying to LLNR/) {
    $message{label} = "Route not found, proxing with DNS lookup";
    $message{desc} = "for: $1";
    $message{msg} = "No route was found for '$1', proxying to LLNR to try a DNS domain resolution.";
    $message{color} = "blue on_yellow";
  
  # No route found
  } elsif (/No route was found for (.*)/) {
    $message{label} = "Route not found";
    $message{desc} = "for: $1";
    $message{msg} = "No route was found for '$1'";
    $message{color} = "blue on_red";
  
  # Request regular expression route
  } elsif (/Searching for a regular expression route to (.*)/) {
    $message{label} = "Request Regular Expression route";
    $message{desc} = "for: $1";
    $message{msg} = "Searching for a Regular Expression route to '$1'";
     
  # Trying regular expression route
  } elsif (/getMatchingRegExp\((.*)\): trying RegExp\[(.* pattern="(.*)" rank=.*)\]$/) {
    $message{label} = "Trying Regular Expression route";
    $message{desc} = "pattern: $3  for: $1";
    $message{msg} = "Trying to route '$1' using Regular Expression pattern '$3'\n\n";
    $message{msg} .= "RegExp: $2";

  # Regular Expression route found
  } elsif (/getMatchingRegExp\((.*)\) returned RegExp\[(id=\d+ pattern="(.*)" rank=.* policyList=\[(.*)\])\]$/) {
    $message{label} = "Regular Expression found";
    $message{desc} = "pattern: $3  for: $1  RoutePolicyList: ".get_name("routingpolicy",$4);
    $message{msg} = "Regular Expression was found for '$1', pattern '$3' using Route Policy(es) '".get_name("routingpolicy",$4)."'\n\n";
    $message{msg} .= "RegExp: $2";

  # Regular Expression denied
  } elsif (/RegExp is denied for (.*)/) {
    $message{label} = "Regular Expression denied";
    $message{desc} = "for: $1";
    $message{msg} = "Regular Expression was denied for '$1'";

  # Regular Expression match NOT found
  } elsif (/No RegExp match found for (\S+)/) {
    $message{color} = "blue on_yellow";
    $message{label} = "RegEx match NOT found";
    $message{desc} = "for: $1";
    $message{msg} = "Regular Expression match not found for '$1'";

  # Destination Entity Match Found
  } elsif (/Routing URI (\S+) matched destination entity (\S+)/) {
    $message{label} = "Destination Entity Matched";
    $message{desc} = "for Routing URI: $1, Destination Entity: $2";
    $message{msg} = "Destination Entity $2 match found for '$1'";

  # Default Outbound Proxy Retrieved
  } elsif (/Retrieved our default outbound proxy (.*)/) {
    $message{label} = "Default Outbound Proxy Retrieved";
    $message{desc} = "Proxy: $1";
    $message{msg} = "Retrieved our default outbound proxy: '$1'";

  # Using new match as best match
  } elsif (/Using new match as best match: (.*)/) {
    $message{label} = "Using new match as best match";
    $message{desc} = "$1";
    $message{msg} = "Using new match as best match: '$1'";

  # Using previous match as best match
  } elsif (/Using previous match as best match: (.*)/) {
    $message{label} = "Using previous match as best match";
    $message{desc} = "$1";
    $message{msg} = "Using previous match as best match: '$1'";

  # Using last search status as final status
  } elsif (/Using last search status as final status: (.*)/) {
    $message{label} = "Using last search status as final status";
    $message{desc} = "$1";
    $message{msg} = "Using last search status as final status: '$1']";

  # Digit Pattern Matched
  } elsif (/Digit pattern matched with status=(\S+) for null origination digit pattern row/) {
    $message{label} = "Digit Pattern Matched with";
    $message{desc} = "status = $1, Origination digit pattern row=null";
    $message{msg} = "Digit pattern matched with status '$1' for 'null' origination digit pattern row";

  # Trying route using origination digit pattern row=null
  } elsif (/Trying route using origination digit pattern row=null/) {
    $message{label} = "Trying route using Orig digit pattern";
    $message{desc} = "Trying route using origination digit pattern row=null";
    $message{msg} = "Trying route using origination digit pattern row=null";

  # Using previous match as best match so far
  } elsif (/Using previous match as best match so far: (.*)/) {
    $message{label} = "Using previous match as best match";
    $message{desc} = "$1";
    $message{msg} = "Using previous match as best match so far: '$1'";

  # Using new match as best match so far
  } elsif (/Using new match as best match so far: (.*)/) {
    $message{label} = "Using new match as best match";
    $message{desc} = "Using new match as best match so far $1";
    $message{msg} = "Using new match as best match so far: '$1']";

  # Digit pattern matched - Non null digit pattern row
  } elsif (/Digit pattern matched with status=(\S+) for origination digit pattern row (.*)/) {
    $message{label} = "Digit Pattern Matched with";
    $message{desc} = "Status=$1, Origination digit pattern row=$2";
    $message{msg} = "Digit pattern matched with status '$1' for origination digit pattern row '$2' ";

  # Trying route using origination digit pattern row = non null
  } elsif (/Trying route using origination digit pattern row=(.*)/) {
    $message{label} = "Trying route using Orig digit pattern";
    $message{desc} = "Trying route using origination digit pattern row = $1";
    $message{msg} = "Trying route using origination digit pattern row = '$1' ";

  # Found IM gateway entity
  } elsif (/getIMGatewayRoute: Found IM gateway entity \(id=(\S+)\) to route to for commProfileSetId=(\S+)/) {
    $message{label} = "Found IM gateway entity";
    $message{desc} = "id = $1, commProfileSetId = $2";
    $message{msg} = "Found IM gateway entity id = '$1' to route to for commProfileSetId = '$2'";

  # Found IM gateway entity
  } elsif (/getRegExpRoutePolicyList\(\) for RegExp(.*) returned (.*)/) {
    $message{label} = "Get RegEx Route Policy List";
    $message{desc} = "RegExp = $1, Returned = $2";
    $message{msg} = "getRegExpRoutePolicyList() returned = '$2' for RegExp = '$1'";

  # Searching for a digit map
  } elsif (/Searching for a digit map for (\S+) and domain (.*)/) {
    $message{label} = "Searching for digit map";
    $message{desc} = "for digit = $1 domain = $2";
    $message{msg} = "Searching for a digit map for '$1' and domain '$2' ";

  # getDigitBasedRoutes: not authoritative
  } elsif (/getDigitBasedRoutes: not authoritative for (\S+)/) {
    $message{color} = "blue on_yellow";
    $message{label} = "Not authoritative";
    $message{desc} = "for domain = $1";
    $message{msg} = "Not authoritative for domain: '$1' ";

  # Found Digit MapId
  } elsif (/Found digitMapId (\S+) for digits <(\S+)> domain <(\S+)> origPatternSetId < (\S+) > and routingOriginationId < (\S+) >/) {
    $message{label} = "Found Digit Map";
    $message{desc} = "Dial Pattern ".get_name("digitmap",$1)." digits: $2, domain: $3, origPatternSetId: $4, routingOriginationId: $5";
    $message{msg} = "Dial Pattern ".get_name("digitmap",$1)." digits: $2, domain: $3, origPatternSetId: $4, routingOriginationId: $5";

  # Found Route Policies for digtMapId
  } elsif (/getRoutePolicies\(\) for (\S+) returned (.*)/) {
    $message{label} = "Found Route Policies";
    $message{desc} = "Dial Pattern ".get_name("digitmap",$1)." Route Policies = $2";
    $message{msg} = "Found Route Policies for ".get_name("digitmap",$1)." Route Policies: '$2'";

  # Route policy destination list (loc 1)
  } elsif (/Route policy destination list \(loc 1\)=(.*)/) {
    $message{label} = "Route policy destination list";
    $message{desc} = "destination = $1";
    $message{msg} = "Route policy destination list (loc 1)= '$1' ";

  # uriUsedForRouting
  } elsif (/getDigitBasedRoutes: uriUsedForRouting=(\S+), routingOriginationId=(\S+), flexRouting=(\S+), rtMatchPrecedence=(\S+), origPatternSetRows=(.*)/) {
    $message{label} = "Get Digit Based Routes";
    $message{desc} = "uriUsedForRouting=$1, routingOriginationId=$2, flexRouting=$3, rtMatchPrecedence=$4, origPatternSetRows=$5";
    $message{msg} = "uriUsedForRouting='$1', routingOriginationId='$2', flexRouting='$3', rtMatchPrecedence='$4', origPatternSetRows='$5' ";

  } elsif (/getMatchingRegExp uri=(\S+) routingOriginationId=(\S+) regex=(.*); location matches; regex does not match; failed match/) {
    $message{label} = "Regex does not match";
    $message{desc} = "uri=$1, routingOriginationId=$2, regex=$3";
    $message{msg} = "Location matches; regex does not match; match failed for uri='$1', routingOriginationId='$2', regex='$3'";

  # Entity Links found
  } elsif ((my $sip_entity, my $entity_link_list) = /Found EntityLinks to id (.*) \(isSecure = .*\): \[(.+)\]$/) {
    $message{label} = "Entity Link found";
    my @entity_link_list_arr = ($entity_link_list =~ /(Link\[.*?\]),?\s?/g);
    my $entity_link_ID_list = "";
    foreach my $entity_link (@entity_link_list_arr) {
      if ($entity_link =~ /Link\[entityId1=(\d+),.*portEntity2=(.*), .* transport=(.*)\]/g) {
        $entity_link_ID_list .= get_name("sipentity",$1)."->$3:$2 ";
      }
    }
    chop($entity_link_ID_list);
    $message{desc} = "SIPEntity: ".get_name("sipentity",$sip_entity)."  EntityLink: $entity_link_ID_list";
    $message{msg} = "Entity Link(s) '$entity_link_ID_list' were found for destination SIP Entity '".get_name("sipentity",$sip_entity)."'\n\n";
    $" = "\n";
    $message{msg} .= "@entity_link_list_arr";

  # Entity Links not found
  } elsif (/No EntityLinks found for routing destination (SipEntity\[id=(.*), type.*\])/) {
    $message{label} = "Entity Link not found";
    $message{desc} = "DestSIPEntity: ".get_name("sipentity",$2);
    $message{msg} = "No Entity Link was found for routing destination SIP Entity '".get_name("sipentity",$2)."'\n\n";
    $message{msg} .= $1;
    $message{color} = "blue on_yellow"; 

  # Routing request
  } elsif (/routeRequestViaLink: routing (.*) to SipEntity\[(id=(.*), type=.*, fqdnoripaddr=(.*), name=\"(.*)\", useRFC3263=.*)\] via EntityLink\[(entity1_id=(\d+),.*, listenportentity2=(.*), .*, transportProtocol=(.*))\]$/) {
    $message{label} = "Routing SIP request";
    $message{desc} = "URI: $1  SipEntity: $5  EntityLink: ".get_name("sipentity",$7)."->$9:$8";
    $message{msg} = "Routing SIP request '$1' to SIP Entity '$5' via Entity Link '".get_name("sipentity",$7)."->$9:$8'\n\n";
    $message{msg} .= "SipEntity: $2\n\n";
    $message{msg} .= "EntityLink: $6";
    $sipentity_ip{$4} = $3;
    $sipentity{$3} = $5;

  # Routing request (6.1)
  } elsif (/routeRequestViaLink: routing (.*) to SipEntity\[(id=(.*), name=\"(.*)\", type=.*, addr=(.*), 3263=.*)\] via Link\[(entityId1=(\d+), entityId2.*portEntity2=(.*), trusted=.*, transport=(.*), biDirId=.*)\]$/) {
    $message{label} = "Routing SIP request";
    $message{desc} = "SipEntity: $4  EntityLink: ".get_name("sipentity",$7)."->$9:$8";
    $message{msg} = "Routing SIP request '$1' to SIP Entity '$4' via Entity Link '".get_name("sipentity",$7)."->$9:$8'\n\n";
    $message{msg} .= "SipEntity: $2\n\n";
    $message{msg} .= "EntityLink: $6";
    $sipentity_ip{$5} = $3;
    $sipentity{$3} = $4;
 
  # Route Policies found
  } elsif ((my $pattern, my $route_policy_list) = /getRoutePolicies\(\) for (\d+) returned \[(.*)\]/) {
    $message{label} = "Route Policy found";
    my @route_policy_list_arr = ($route_policy_list =~ /(RoutePolicy\[.*?\])/g);
    my $route_policy_ID_list = "";
    foreach my $route_policy (@route_policy_list_arr) {
      if ($route_policy =~ /RoutePolicy\[id: '(.*)', sipEntityId: .*\]/g) {
        $route_policy_ID_list .= "$1,";
      } 
    }
    chop($route_policy_ID_list); 
    $message{desc} = "Pattern: ".get_name("digitmap",$pattern)."  RoutePolicyList: ".get_name("routingpolicy",$route_policy_ID_list);
    $message{msg} = "Route Policy(es) '".get_name("routingpolicy",$route_policy_ID_list)."' were found for Dial Pattern '".get_name("digitmap",$pattern)."'\n\n";
    $" = "\n";
    $message{msg} .= "@route_policy_list_arr"; 

  # Another SM instance
  } elsif ((my $to_inst, $my_inst) = /not my instance: (\d+) : (\d+)/) {
    $message{label} = "Entity Link to another SM";
    $message{desc} = "To: ".get_name("sipentity",$to_inst)."  MyInstance: ".get_name("sipentity",$my_inst);
    $message{msg} = "The SIP Entity has a link to SM '".get_name("sipentity",$to_inst)."'. This SM instance is '".get_name("sipentity",$my_inst)."'";   
  # Ranking Route Policies
  } elsif ((my $route_policy_list) = /Ranking RoutePolicies RoutePolicyList\[ (.*)\]$/) {
    $message{label} = "Ranking Route Policies";
    my @route_policy_list_arr = ($route_policy_list =~ /(RoutePolicy\[.*?\])/g);
    my $route_policy_ID_list = "";
    foreach my $route_policy (@route_policy_list_arr) {
      if ($route_policy =~ /RoutePolicy\[id: '(.*)', sipEntityId: .*\]/g) {
        $route_policy_ID_list .= "$1,";
      }
    }
    chop($route_policy_ID_list);
    $message{desc} = "RoutePolicyList: ".get_name("routingpolicy",$route_policy_ID_list);
    $message{msg} = "Ranking Route Policies '".get_name("routingpolicy",$route_policy_ID_list)."'\n\n";
    $" = "\n";
    $message{msg} .= "@route_policy_list_arr";

  # Setting rank
  } elsif (/Setting rank to (.*) for policy (\d+).*$/) {
    if ($1 eq "null") {
      $message{label} = "Time Range not assigned while setting rank";
      $message{desc} = "Rank: $1  Policy: ".get_name("routingpolicy",$2);
      $message{msg} = "Setting rank to 'null' for Route Policy '".get_name("routingpolicy",$2)."' because no Time Range assigned to the Route Policy.";
      $message{color} = "blue on_yellow";
    } else {
      $message{label} = "Setting rank for Route Policy";
      $message{desc} = "Rank: $1  Policy: ".get_name("routingpolicy",$2);
      $message{msg} = "Setting rank to '$1' for Route Policy '".get_name("routingpolicy",$2)."'";
    }

  # No Time Range found
  } elsif (/Setting rank to null for RoutePolicy (RoutePolicy\[id: '(.*)', sipEntityId: .*\]) because no TimeRange match was found at time .*/) {
    $message{label} = "Time Range not matched while setting rank";
    $message{desc} = "Rank: null  Policy: ".get_name("routingpolicy",$2);
    $message{msg} = "Setting rank to null for Route Policy '".get_name("routingpolicy",$2)."' because no Time Range match for the destination SIP Entity at its timezone.\n\n";
    $message{msg} .= "$1";
    $message{color} = "blue on_yellow";

  # No domain found
  } elsif (/No domain was found for (.*); returning SC_SERVICE_UNAVAILABLE/) {
    $message{label} = "Domain not found";
    $message{desc} = "for: $1";
    $message{msg} = "No Domain was found for '$1'";
    $message{color} = "blue on_red";

  # Using default outbound Proxy
  } elsif (/Retrieved our default outbound proxy: (SipEntity\[id=(.*), type=.*\])/) {
    $message{label} = "Using Outbound Proxy";
    $message{desc} = "Proxy SIP Entity: ".get_name("sipentity",$2);
    $message{msg} = "Using default Outbound Proxy '".get_name("sipentity",$2)."'\n\n";
    $message{msg} .= "$1";

  # SM identity unresolved
  } elsif (/ASM identity unresolved; cannot process message/) {
    $message{label} = "SM identity unresolved";
    $message{desc} = "No SM";
    $message{msg} = "SM identity unresolved. Make sure the SM is defined under 'SM Element Manager' -> 'Session Manager Administration'. And that the scrush process is running correctly.";
    $message{color} = "blue on_red";

  # Resolve hostname
  } elsif (/resolveHostName: (.*) ThreadID: \d+/) {
    $message{label} = "Resolving SIP URI";
    $message{desc} = "SIP URI: $1";
    $message{msg} = "Resolving SIP URI '$1'";

  # Using real DNS lookup
  } elsif (/No provisioned locations, perform real DNS lookup,/) {
    $message{label} = "No Local Host Name Resolution provisioned";
    $message{desc} = "Using real DNS lookup";
    $message{msg} = "No Local Host Name Resolution provisioned, perform real DNS lookup";
    $message{color} = "blue on_yellow";
 
  # Low Level Name Resolution (LLNR) result
  } elsif ((my $resolved_location_list) = /store: \[(ResolvedLocation\[.*)\] index: \d+/) {
    $message{label} = "Resolved DNS Locations";
    my @resolved_location_list_arr = ($resolved_location_list =~ /(ResolvedLocation\[.*?\])/g);
    my $resolved_location_desc = "";
    foreach my $resolved_location (@resolved_location_list_arr) {
      if ($resolved_location =~ /ResolvedLocation\[ipaddress=(.*), .*, transport=(.*)\]/g) {
        $resolved_location_desc .= "$2:$1, ";
      }
    }
    chop($resolved_location_desc);
    chop($resolved_location_desc);
    $message{desc} = "Locations: $resolved_location_desc";
    $message{msg} = "Resolved DNS Location(s) '$resolved_location_desc' for the URI domain.\n\n";
    $" = "\n";
    $message{msg} .= "@resolved_location_list_arr";

  # No hostname resolution required
  } elsif (/No hostname resolution required; routing to: (.*)/) {
    $message{label} = "No hostname resolution required";
    $message{desc} = "Routing to: $1";
    $message{msg} = "No hostname resolution was required, routing to '$1'";

  # Trying new DNS resolved route
  } elsif (/push new route with string = (.*)/) {
    $message{label} = "Routing SIP request using DNS route";
    $message{desc} = "To: $1";
    $message{msg} = "Routing SIP request using DNS route '$1'"; 
    
  # Trying next DNS resolved route
  } elsif (/Try the next location: <(.*)>/) {
    $message{label} = "Routing SIP request using next DNS route";
    $message{desc} = "To: $1";
    $message{msg} = "Routing SIP request using the next DNS route '$1'"; 
    
  # Proxying based on the route header
  } elsif (/Proxying to (.*) based on the route header/) {
    $message{label} = "Proxying based on route header";
    $message{desc} = "To: $1";
    $message{msg} = "Proxying to '$1' based on the route header";

  # No authoritative domain
  } elsif (/getDigitBasedRoutes: not authoritative for (.*)/) {
    $message{label} = "No authoritative domain";
    $message{desc} = "Domain: $1";
    $message{msg} = "No authoritative domain for '$1'";

  # Remote host is not trusted
  } elsif (/remote host is not trusted/) {
    $message{color} = "blue on_yellow";
    $message{label} = "Remote host is not trusted";
    $message{desc} = "Host not trusted";
    $message{msg} = "The remote host is not trusted. This could indicate P-AV-Transport header does not contain th.";

  # Monitoring status link down
  } elsif (/Cannot route to (.*) due to monitoring status link down indication/) {
    $message{color} = "blue on_yellow";
    $message{label} = "Monitoring status link down";
    $message{desc} = "Routing to: $1";
    $message{msg} = "Cannot route to '$1' due to monitoring status link down indication";

  # SIP Entity monitor
  } elsif (/SipMonitorTask is running for MonitoredEntity\[(id=(\d+), fqdnoripaddr=(.*), name=\"(.*)\", status=(\w+), mode=(\w+), .*)\]/) {
    if ($5 eq "DOWN") {
      $message{label} = "SIP Entity down";
      $message{color} = "blue on_red";
    } elsif ($5 eq "UP") {
      $message{label} = "SIP Entity up";
    } else {
      $message{label} = "SIP Entity $5";
      $message{color} = "blue on_yellow";
    }
    $message{desc} = "SIPEntity: $4  Status: $5  IP: $3";
    $message{msg} = "SIP Entity '$4' is '$5'. Monitor mode is '$6'.";
    $message{msg} .= "\n\nMonitored Entity: $1";
    $sipentity_ip{$3} = $2;
    $sipentity{$2} = $4;

  # Send OPTIONS
  } elsif (/sendOptions\(MonitoredAddress\[(.*), status=(\w+), downCount.*/) {
    $message{label} = "Sending keepalive OPTIONS";
    $message{desc} = "To: $1  status: $2";
    $message{msg} = "Sending keepalive OPTIONS to '$1', current status is '$2'";

  # SIP Entity monitor result
  } elsif (/publishResults\(MonitoredEntity\[(id=(\d+), fqdnoripaddr=(.*), name=\"(.*)\", status=(\w+), mode=(\w+), .*)\]\)$/) {
    if ($5 eq "DOWN") {
      $message{label} = "Keepalive OPTIONS result down";
      $message{color} = "blue on_red";
    } elsif ($5 eq "UP") {
      $message{label} = "Keepalive OPTIONS result up";
    } else {
      $message{label} = "Keepalive OPTIONS result $5";
      $message{color} = "blue on_yellow";
    }
    $message{desc} = "SIPEntity: $4  Status: $5  IP: $3";
    $message{msg} = "OPTIONS keepalive result for SIP Entity '$4' is '$5'. Monitor mode is '$6'.";
    $message{msg} .= "\n\nMonitored Entity: $1";
    $sipentity_ip{$3} = $2;
    $sipentity{$2} = $4;

  # Registered contact
  } elsif (/registeredContactExists: handle=(.*), domain=(.*) is true/) {
    $message{label} = "Registered contact";
    $message{desc} = "Handle: $1  Domain: $2";
    $message{msg} = "Registered contact with handle '$1' and domain '$2' exists";

  # Non registered contact
  } elsif (/registeredContactExists: handle=(.*), domain=(.*) is false/) {
    $message{label} = "Non registered contact";
    $message{desc} = "Handle: $1  Domain: $2";
    $message{msg} = "Non registered contact with handle '$1' and domain '$2'";
    $message{color} = "blue on_yellow";

  # Contact information
  } elsif (/getLocationFromRegistration found a matching contact for the incoming request: (Contact\[URI=(.*), qValue=(.*), handleId=(.*), locationId=(.*), registrationTime=(.*), pathVector=\[(.*)\]\])/) {
    $message{label} = "Contact Information";
    $message{desc} = "URI: $2";
    $message{msg} = "Found a matching contact for the incoming request. Contact URI '$2'\n\n$1";
   
  # remote host is trusted
  } elsif (/remote host is trusted/) {
    # Display this message only at the begining of the call as it is repeated too
    # many times that confuse the reading
    if (exists($calls{$message{call_id}}) && $calls{$message{call_id}}{first} == 1) {
      $calls{$message{call_id}}{first} = 0;
      $message{label} = "Remote host is trusted";
      $message{desc} = "Trusted";
      $message{msg} = "Remote host is trusted";
    }
    
  # Check if is an Emergency call
  } elsif (/Calling getRoute to determine if this call is to an emergency number for the origination location (.*)/) {
    $message{label} = "Try routing to determine if emergency call";
    $message{desc} = "Location: ".get_name("routingorigination",$1);
    $message{msg} = "Try routing to determine if this call is to an emergency number for the origination location '".get_name("routingorigination",$1)."'";

  # Rotuing to Application
  } elsif (/routing to App SipEntity\[id=.*, name="(.*)", type=(.*), addr=(.*), 3263=(true|false), adapt=(.*), proxy=.*\] using entityLink Link\[entityId1=(\d+),.*portEntity2=(.*), .* transport=(.*), biDirId=.*\]/) {
    $message{label} = "Routing to Application";
    $message{desc} = "SIPEntity: $1";
    $message{msg} = "Routing to Application on '$1' SIP Entity at '$3' using Entity Link '".get_name("sipentity",$6)."->$8:$7'";

  # User Authenticate failed
  } elsif (/in Authenticate \(Authorization failed!\)/) {
    $message{label} = "Authorization failed";
    $message{desc} = "";
    $message{msg} = "Endpoint authorization failed";
    $message{color} = "blue on_red";

  # Add the phone extension as the name column
  } elsif (/(returning data from local cache, key: URE_CONTACTS:.*data:|getContactFromRegistration found a matching contact for the incoming request:) Contact\[URI=sips?:(.*)@(\d+\.\d+\.\d+\.\d+)/) {
    $contact_ip{$3} = $2;

  # Add the phone extension as the name column (egress calls)
  } elsif (/adding contact sips?:(.*)@(\d+\.\d+\.\d+\.\d+)/) {
    $contact_ip{$2} = $1;    

  # Rotuing to the endpoint
  } elsif (/Routing Call ID .* - no more termination apps, going to endpoint/) {
    $message{label} = "Routing to endpoint";
    $message{desc} = "";
    $message{msg} = "No more termination apps, going to endpoint";

  # URE Originating Location
  } elsif (/Location ID is (\d+)/) {
    $message{label} = "Originating Location found";
    $message{desc} = "Location: ".get_name("routingorigination",$1);
    $message{msg} = "Originating Location '".get_name("routingorigination",$1)."' found";

  # Trying to Authenticate
  } elsif (/Authenticate: user = (.*) realm = (.*) creds = (.*)/) {
    $message{label} = "Trying to Authenticate";
    $message{desc} = "User: $1  Realm: $2";
    $message{msg} = "Trying to authenticate user '$1' with realm '$2' and credentials '$3'";

  # Authorization verified
  } elsif (/in Authenticate \(Authorization verified!\)/) {
    $message{label} = "Authorization verified";
    $message{desc} = "Verified";
    $message{msg} = "Authorization verified";

  }
  if ($message{label}) {
    #generate_asm_record(\%message); 
    queue_asm_record(\%message); 
#print TMP "$message{timestamp} $type $method CALLID: $callid\n";
  }
}

sub queue_asm_record {
  my $params = shift;
  my %message = %$params;
  undef(%record);

  my ($year,$month,$day) = $message{day} =~ /(\d{4})-(\d{1,2})-(\d{1,2})/;
  my ($hour,$minute,$seconds,$milliseconds) = $message{timestamp} =~ /(\d{1,2}):(\d{1,2}):(\d{1,2}),(\d{1,3})?/;
  my $ts = timelocal($seconds,$minute,$hour,$day,$month-1,$year) + $milliseconds/1000;

  # Add the record to the array of dg_records
  my $queue_asm_records_no = scalar (@queue_asm_records);
  $queue_asm_records[$queue_asm_records_no] = &share({});
  $queue_asm_records[$queue_asm_records_no]{day} = $message{day};
  $queue_asm_records[$queue_asm_records_no]{timestamp} = $message{timestamp};
  $queue_asm_records[$queue_asm_records_no]{time_seconds} = $ts;
  $queue_asm_records[$queue_asm_records_no]{type} = $message{type};
  $queue_asm_records[$queue_asm_records_no]{desc} = $message{desc};
  $queue_asm_records[$queue_asm_records_no]{label} = $message{label};
  $queue_asm_records[$queue_asm_records_no]{msg} = $message{msg};
  $queue_asm_records[$queue_asm_records_no]{color} = $message{color};
  $queue_asm_records[$queue_asm_records_no]{call_id} = $message{call_id};

  #generate_asm_record($queue_asm_records[$queue_asm_records_no]);
}

sub generate_asm_record {
  my $params = shift;
  my %message = %$params;
  undef(%record);

  my ($year,$month,$day) = $message{day} =~ /(\d{4})-(\d{1,2})-(\d{1,2})/;
  my ($hour,$minute,$seconds,$milliseconds) = $message{timestamp} =~ /(\d{1,2}):(\d{1,2}):(\d{1,2}),(\d{1,3})?/;
#my $ts = timelocal($seconds,$minute,$hour,$day,$month-1,$year) + $milliseconds/1000;
#if ($last_timestamp > $ts) {
#  print TMP "OUT OF ORDER ASM: last_timestamp $last_timestamp  ts $ts  message{timestamp}  $message{timestamp}\n";
#}
#$last_timestamp = $ts;

  # add the record to the dg_records array
  my $dg_record_no = scalar (@dg_records);
  $dg_records[$dg_record_no] = &share({});
  $dg_records[$dg_record_no] = $params;

  my $filtered = filter_asm_message($dg_records[$dg_record_no]);
  if ($filtered == 0) { 
    # When capturing, if the cursor is in the bottom we refresh the screen
    $dg_record_no = scalar(@display_dg_records);
    if ($capture_mode ne "opening_file" && $display_mode ne "details") {
      if ($dg_rec_pos == $dg_record_no-1) {
        $dg_rec_pos = $dg_record_no;
      }
    }
    refresh();
  }
}

sub generate_ppm_record {
  my $params = shift;
  my %message = %$params;
  undef(%record);

  my ($year,$month,$day) = $message{day} =~ /(\d{4})-(\d{1,2})-(\d{1,2})/;
  my ($hour,$minute,$seconds,$milliseconds) = $message{timestamp} =~ /(\d{1,2}):(\d{1,2}):(\d{1,2}),(\d{1,3})?/;
#my $ts = timelocal($seconds,$minute,$hour,$day,$month-1,$year) + $milliseconds/1000;
#if ($last_timestamp > $ts) {
#  print TMP "OUT OF ORDER ASM: last_timestamp $last_timestamp  ts $ts  message{timestamp}  $message{timestamp}\n";
#}
#$last_timestamp = $ts;
  # add the record to the dg_records array
  my $dg_record_no = scalar (@dg_records);
  $dg_records[$dg_record_no] = &share({});
  $dg_records[$dg_record_no] = $params;

  my $filtered = filter_ppm_message($dg_records[$dg_record_no]);
  if ($filtered == 0) {
    # When capturing, if the cursor is in the bottom we refresh the screen
    $dg_record_no = scalar(@display_dg_records);
    if ($capture_mode ne "opening_file" && $display_mode ne "details") {
      if ($dg_rec_pos == $dg_record_no-1) {
        $dg_rec_pos = $dg_record_no;
      }
    }
    refresh();
  }
}

sub generate_tls_record {
  my $params = shift;
  my %message = %$params;
  undef(%record);

  my ($year,$month,$day) = $message{day} =~ /(\d{4})-(\d{1,2})-(\d{1,2})/;
  my ($hour,$minute,$seconds,$milliseconds) = $message{timestamp} =~ /(\d{1,2}):(\d{1,2}):(\d{1,2})\.(\d{1,3})?/;
#my $ts = timelocal($seconds,$minute,$hour,$day,$month-1,$year) + $milliseconds/1000;
#if ($last_timestamp > $ts) {
#  print TMP "OUT OF ORDER ASM: last_timestamp $last_timestamp  ts $ts  message{timestamp}  $message{timestamp}\n";
#}
#$last_timestamp = $ts;
  # add the record to the dg_records array
  my $dg_record_no = scalar (@dg_records);
  $dg_records[$dg_record_no] = &share({});
  $dg_records[$dg_record_no] = $params;

  my $filtered = filter_tls_message($dg_records[$dg_record_no]);
  if ($filtered == 0) {
    # When capturing, if the cursor is in the bottom we refresh the screen
    $dg_record_no = scalar(@display_dg_records);
    if ($capture_mode ne "opening_file" && $display_mode ne "details") {
      if ($dg_rec_pos == $dg_record_no-1) {
        $dg_rec_pos = $dg_record_no;
      }
    }
    refresh();
  }
}

sub process_sip_packet {
  my $params = shift;
  my %message = %$params;
  lock(@dg_records);
  lock(@display_dg_records);
  lock(%calls);
  lock(%apns_tx);
  lock(%sessions);
#print TMP "in process_sip_packet\n";
#print TMP %message;
  # SIP RESPONSE
  if ($message{sip} =~ /^SIP\/2\.0 (.*)/) {
    $message{type} = "RESPONSE";
    $message{response} = "$1";

  # SIP REQUEST
  } elsif ($message{sip} =~ /^(\w+) ((sip[s]?|tel):.*?)([;].*)* SIP\/2\.0/) {
    $message{type} = "REQUEST";
    $message{method} = "$1";
    $message{request_uri} = "$2";

  # SIP PING/PONG
  } elsif ($message{sip} =~ /^\n\n(\n?)$/) {
    $message{type} = "PINGPONG";
    if ($1 eq "\n") {
      $message{method} = "PING";
    } else {
      $message{method} = "PONG";
    }

  } else {
    $message{type} = "ERROR";
#   print TMP "ERROR: $message{timestamp}\n$message{sip}\n\n";
  }

    # Get the Call-ID header
  if ($message{sip} =~ /^(Call-I[Dd]|i):\s*(.*)$/mi) {
    if (!exists($calls{$2})) {
      $calls{$2} = &share({});
      $calls{$2}{number} = keys(%calls);
      $calls{$2}{invites} = &share({});
      $calls{$2}{invites}{$message{host}} = 0;
      $calls{$2}{status} = 0;
      $calls{$2}{first} = 1;
      $calls{$2}{display} = 0;
      $calls{$2}{global_session_id} = &share({});
    }
    $message{call_id} = $2;
  } else {
    #print TMP "WARNING: No Call-ID in:\n$message{sip}\n";
    $invalid_call_id = "not_call_id";
    $message{call_id} = $invalid_call_id;
    $calls{$invalid_call_id} = &share({});
    $calls{$invalid_call_id}{number} = keys(%calls);
    $calls{$invalid_call_id}{invites} = &share({});
    $calls{$invalid_call_id}{invites}{$message{host}} = 0;
    $calls{$invalid_call_id}{display} = 0;
    $calls{$invalid_call_id}{first} = 1;
    $calls{$invalid_call_id}{status} = -1;
    $calls{$invalid_call_id}{global_session_id} = &share({});
  }

  (my $to_tag) = ($message{sip} =~ /^(?:To|t): .*;tag=(.*)$/m);
  $message{to_tag} = $to_tag;

  # Get the Contact header to be used as the name (in case it is not a trusted SIP Entity)
  if ($message{send_receive} eq "Incoming") {
    if ($message{sip} =~ /^(?:Contact|m):.*sips?:([^@\n]*)@.*$/m) {
      $contact_ip{$message{host}} = $1;
    } 
  }

  queue_sip_record(\%message);
  process_rtp_packet(\%message);
  update_call_summary(\%message);
}

sub process_tls_message {
  my $params = shift;
  my %message = %$params;
  lock(@dg_records);
  lock(@display_dg_records);

  # Remove the last ", " in the desc and lable
  chop($message{label});chop($message{desc});
  chop($message{label});chop($message{desc});

  # Abbreviate the label
  $message{label} = abbreviate_tls_label($message{label});

  # Compress the details. The decoded TLS handshaking messages
  # have lot of details that an advance user can look directly on the
  # generated text files or do a separate tshark. In here we try to
  # display what is necessary to trableshoot common certs issues
  $message{msg} = compress_tls_msg($message{msg});

  # Hash each TLS stream with <remote_IP>_<local_port>_<remote_port>
  my $key = "$message{host}_$message{local_port}_$message{port}";
  $tls_streams{$key} = keys(%tls_streams)+1 if !exists($tls_streams{$key});

  queue_tls_record(\%message);
}

sub init_tls_line_remove {
  @tls_lines_to_remove = (
    '^    Content Type.*$(?:\n)?',
    '^    Length: .*$(?:\n)?',
    '^        Handshake Type: .*$(?:\n)?',
    '^        Length: .*$(?:\n)?',
    '^        Cipher Suites Length: .*$(?:\n)?',
    '^        Compression Methods Length: .*$(?:\n)?',
    '^        Extensions Length: .*$(?:\n)?',
    '^            Length: .*$(?:\n)?',
    '^            EC point formats Length: .*$(?:\n)?',
    '^            Elliptic Curves Length: .*$(?:\n)?',
    '^            Type: .*$(?:\n)?',
    '^                Renegotiation info extension length: .*$(?:\n)?',
    '^        Certificates Length: .*$(?:\n)?',
    '^            Certificate Length: .*$(?:\n)?',
    '^                    version: .*$(?:\n)?',
    '^                        Algorithm Id: .*$(?:\n)?',
    '^                        rdnSequence: \d+ items \(.*$(?:\n)?',
    '^                                RelativeDistinguishedName item .*$(?:\n)?',
    '^                                    Id: .*$(?:\n)?',
    '^                                    DirectoryString: .*$(?:\n)?',
    '^                                        printableString: .*$(?:\n)?',
    '^                                        uTF8String: .*$(?:\n)?',
    '^                                    IA5String: .*$(?:\n)?', 
    '^                                    CountryName: .*$(?:\n)?',
    '^                            Algorithm Id: .*$(?:\n)?',
    '^                            Extension Id: .*$(?:\n)?',
    '^                                GeneralName: .*$(?:\n)?',
    '^                            KeyPurposeIDs: .*$(?:\n)?',
    '^                                [01.]{4} [01.]{4} = .*$(?:\n)?',
    '^                    Algorithm Id: .*$(?:\n)?',
    '^                            GeneralNames: \d+ items$(?:\n)?',
   );
}

sub compress_tls_msg {
  my $msg = shift;

  # remove the first 4 spaces
  $msg =~ s/^    //mg;

  foreach (@tls_lines_to_remove) {
    $msg =~ s/$_//mg;
  }

  # Reorder multiple lines in one (e.g. validity)
  $msg =~ s/^                        notBefore: utcTime \(0\)\n                            utcTime: (.*)\n                        notAfter: utcTime \(0\)\n                            utcTime: (.*)\n/                        notBefore: \1\n                        notAfter: \2\n/mg;
  $msg =~ s/^            Certificate \(.*\n/            Certificate\n/mg; 
  $msg =~ s/^                    (subject|issuer): rdnSequence \(0\)\n/                    \1: \n/mg;
  $msg =~ s/^                            RDNSequence item: \d+ item \((.*)\)\n/\1, /mg;  
  $msg =~ s/^                    (subject|issuer): \n(.*), (                    .*)\n/                    \1: \2\n\3\n/mg; 
  $msg =~ s/^                    subjectPublicKeyInfo\n                        algorithm \((.*)\)\n                        Padding: \d+\n/                    subjectPublicKeyInfo (\1)\n/mg;

  # Abbreviate the Certificate subject/issues line
  $msg =~ s/id-at-commonName/CN/g;
  $msg =~ s/id-at-surname/SN/g;
  $msg =~ s/id-at-countryName/C/g;
  $msg =~ s/id-at-localityName/L/g;
  $msg =~ s/id-at-stateOrProvinceName/ST/g;
  $msg =~ s/id-at-streetAddress/STREET/g;
  $msg =~ s/id-at-organizationName/O/g;
  $msg =~ s/id-at-organizationalUnitName/OU/g;
  $msg =~ s/pkcs-9-at-emailAddress/EMAIL/g;
  $msg =~ s/id-at-//g;

  # Number the Certificates
  my $count = 1;
  while ($msg =~ /^            Certificate\n/m) {
    $msg =~ s/^            Certificate\n/            Certificate $count\n/m;
    $msg =~ s/^(            Certificate $count)\n(.*?)                    issuer: ([^\n]*)\n(.*?)                    subject: ([^\n]*)\n/"$1 ".(($count == 1) ? "(Identity Certificate)" : (($3 eq $5) ? "(Root Certificate)" : "(Intermediate Certificate)"))."\n$2                    issuer: $3\n$4                    subject: $5\n"/ems;
    $count++; 
  }

  return $msg;
}

sub abbreviate_tls_label {
  my $label = shift;

  # Abbreviate the label
  $label =~ s/Server Hello Done/SHelloDone/g;
  $label =~ s/Client Hello/CHello/g;
  $label =~ s/Server Hello/SHello/g;
  $label =~ s/Certificate Request/CertReq/g;
  $label =~ s/Certificate Verify/CertVer/g;
  $label =~ s/Certificate/Cert/g;
  $label =~ s/Server Key Exchange/SKeyEx/g;
  $label =~ s/Client Key Exchange/CKeyEx/g;
  $label =~ s/Encrypted Handshake Message/EncHandMsg/g;
  $label =~ s/Hello Request/HelloReq/g;
  $label =~ s/Finished/Fin/g;

  return $label;
}

sub process_queue {
  binmode STDOUT, ':utf8';

  # Display processing queue message
  display_message();

  while (not $quit) {
    if ($is_real_time) {
      $proc_time = time - 4;
      #$proc_time = time - 2;
    } else {
      # Added this as offline (non-real time) file may have timestamps
      # in the future
      $proc_time = 9999999999;
    }


    # Reorder the messages based on packets that
    # arrived more than 2 second ago. 
    # Compare the timestamp of the SIP, PPM and ASM queues.
    # If same timestamp, then the SIP is first if incoming.

    my $queue_asm_records_no = scalar (@queue_asm_records);
    my $queue_sip_records_no = scalar (@queue_sip_records);
    my $queue_ppm_records_no = scalar (@queue_ppm_records);
    my $queue_tls_records_no = scalar (@queue_tls_records);
    my $queue_push_records_no = scalar (@queue_push_records);
  
    $sip_record = -1;
    $asm_record = -1;
    $ppm_record = -1;
    $tls_record = -1;
    $push_record = -1;
    $sip_time = 9999999999;
    $asm_time = 9999999999;
    $ppm_time = 9999999999;
    $tls_time = 9999999999;
    $push_time = 9999999999;


    if ($current_sip_record < $queue_sip_records_no && $queue_sip_records[$current_sip_record]{time_seconds} <= $proc_time) {
      $sip_record = $current_sip_record;
      $sip_time = $queue_sip_records[$current_sip_record]{time_seconds};
      $current_sip_record++;
    }
    if ($current_asm_record < $queue_asm_records_no && $queue_asm_records[$current_asm_record]{time_seconds} <= $proc_time) {
      $asm_record = $current_asm_record;
      $asm_time = $queue_asm_records[$current_asm_record]{time_seconds};
      $current_asm_record++;
    }
    if ($current_ppm_record < $queue_ppm_records_no && $queue_ppm_records[$current_ppm_record]{time_seconds} <= $proc_time) {
      $ppm_record = $current_ppm_record;
      $ppm_time = $queue_ppm_records[$current_ppm_record]{time_seconds};
      $current_ppm_record++;
    }

    if ($current_tls_record < $queue_tls_records_no && $queue_tls_records[$current_tls_record]{time_seconds} <= $proc_time) {
      $tls_record = $current_tls_record;
      $tls_time = $queue_tls_records[$current_tls_record]{time_seconds};
      $current_tls_record++;
    }
    if ($current_push_record < $queue_push_records_no && $queue_push_records[$current_push_record]{time_seconds} <= $proc_time) {
      $push_record = $current_push_record;
      $push_time = $queue_push_records[$current_push_record]{time_seconds};
      $current_push_record++;
    }
   
    #print TMP "$processing_initial_queue queue_asm ".($queue_asm_records_no-$current_asm_record)."     queue_sip ".($queue_sip_records_no-$current_sip_record)."     queue_tls  ".($queue_tls_records_no-$current_tls_record)." queue_push ".($queue_push_records_no-$current_push_record)."  total_asm $queue_asm_records_no   total_sip $queue_sip_records_no total_tls $queue_tls_records_no total_push $queue_push_records_no\n";
    
    #print TMP "sip_record = $sip_record, asm_record = $asm_record, ppm_record = $ppm_record, tls_record = $tls_record, push_record = $push_record\n";

    if ($sip_record == -1 && $asm_record == -1 && $ppm_record == -1 && $tls_record == -1 && $push_record == -1) {
      # print TMP "queue_asm ".($queue_asm_records_no-$current_asm_record)."     queue_sip ".($queue_sip_records_no-$current_sip_record)."     queue_ppm ".($queue_ppm_records_no-$current_ppm_record)."queue_push ".($queue_push_records_no-$current_push_record)."  total_asm $queue_asm_records_no   total_sip $queue_sip_records_no   total_ppm $queue_ppm_records_no\n total_push $queue_push_records_no";
      if ($processing_initial_queue) {
        $processing_initial_queue = 0;
        #refresh();
        refilter() if not $is_real_time; # This is so the columns get reordered so the first messages is the one from the far left
        return if not $is_real_time;
      }
      sleep(1);
      next;
    }
    # To order TLS agains other messages (SIP, PPM, CallP), we do not care
    # the arrival time as TLS are independent than the others
    if ($tls_record != -1 && $tls_time <= $sip_time && $tls_time <= $asm_time && $tls_time <= $ppm_time && $tls_time <= $push_time) {
      generate_tls_record($queue_tls_records[$tls_record]);
      $current_sip_record-- if $sip_record != -1;
      $current_asm_record-- if $asm_record != -1;
      $current_ppm_record-- if $ppm_record != -1;
      $current_push_record-- if $push_record != -1;
      next;
    }
    $current_tls_record-- if $tls_record != -1;

    # Order and display Push Notification Message
    if ($push_record != -1 && $push_time <= $sip_time && $push_time <= $asm_time && $push_time <= $ppm_time && $push_time <= $tls_time) {
      generate_push_notification_record($queue_push_records[$push_record]);
      $current_sip_record-- if $sip_record != -1;
      $current_asm_record-- if $asm_record != -1;
      $current_ppm_record-- if $ppm_record != -1;
      $current_tls_record-- if $tls_record != -1;
      next;
    }
    $current_push_record-- if $push_record != -1;

    # Intercalate the messages based on the timestamp. Need to consider
    # if they have the same timestamp, which goes first

    # Two are -1
    if ($ppm_record == -1 && $asm_record == -1 && $sip_record != -1) {
      generate_sip_record($queue_sip_records[$sip_record]);
    } elsif ($ppm_record == -1 && $sip_record == -1 && $asm_record != -1) {
      generate_asm_record($queue_asm_records[$asm_record]);
    } elsif ($asm_record == -1 && $sip_record == -1 && $ppm_record != -1) {
      generate_ppm_record($queue_ppm_records[$ppm_record]);

    # One is -1 
    } elsif ($ppm_record == -1 && $asm_record != -1 && $sip_record != -1) {
      if ($sip_time < $asm_time) {
        generate_sip_record($queue_sip_records[$sip_record]);
        $current_asm_record-- if $asm_record != -1;
      } elsif ($sip_time > $asm_time) {
        generate_asm_record($queue_asm_records[$asm_record]);
        $current_sip_record-- if $sip_record != -1;
      } else { # $sip_time == $asm_time
        my $rem_ip = $queue_sip_records[$sip_record]{host};
        if (($queue_sip_records[$sip_record]{send_receive} eq "Outgoing" && ($rem_ip eq "$asm_ip" || $rem_ip eq "$asm_ipv6")) || ($queue_sip_records[$sip_record]{send_receive} eq "Incoming" && ($rem_ip eq "$sm100_ip" || $rem_ip eq "$sm100_ipv6"))) {
          generate_sip_record($queue_sip_records[$sip_record]);
          $current_asm_record-- if $asm_record != -1;
        } else {
          generate_asm_record($queue_asm_records[$asm_record]);
          $current_sip_record-- if $sip_record != -1;
        }
      }
    } elsif ($asm_record == -1 && $sip_record != -1 && $ppm_record != -1) {
      if ($sip_time < $ppm_time) {
        generate_sip_record($queue_sip_records[$sip_record]);
        $current_ppm_record-- if $ppm_record != -1;
      } elsif ($sip_time > $ppm_time) {
        generate_ppm_record($queue_ppm_records[$ppm_record]);
        $current_sip_record-- if $sip_record != -1;
      } else { # $sip_time == $ppm_time
        my $rem_ip = $queue_sip_records[$sip_record]{host};
        if (($queue_sip_records[$sip_record]{send_receive} eq "Outgoing" && ($rem_ip eq "$asm_ip" || $rem_ip eq "$asm_ipv6")) || ($queue_sip_records[$sip_record]{send_receive} eq "Incoming" && ($rem_ip eq "$sm100_ip" || $rem_ip eq "$sm100_ipv6"))) {
          generate_sip_record($queue_sip_records[$sip_record]);
          $current_ppm_record-- if $ppm_record != -1;
        } else {
          generate_ppm_record($queue_ppm_records[$ppm_record]);
          $current_sip_record-- if $sip_record != -1;
        }
      }
    } elsif ($sip_record == -1 && $asm_record != -1 && $ppm_record != -1) {
      if ($asm_time < $ppm_time) {
        generate_asm_record($queue_asm_records[$asm_record]);
        $current_ppm_record-- if $ppm_record != -1;
      } elsif ($asm_time >= $ppm_time) {
        generate_ppm_record($queue_ppm_records[$ppm_record]);
        $current_asm_record-- if $asm_record != -1;
      }
    
    # All are different than -1
    } elsif ($sip_time < $asm_time && $sip_time < $ppm_time) { 
      generate_sip_record($queue_sip_records[$sip_record]);
      $current_ppm_record-- if $ppm_record != -1;$current_asm_record-- if $asm_record != -1;
    } elsif ($asm_time < $sip_time && $asm_time < $ppm_time) {
      generate_asm_record($queue_asm_records[$asm_record]);
      $current_ppm_record-- if $ppm_record != -1;$current_sip_record-- if $sip_record != -1;
    } elsif ($ppm_time < $sip_time && $ppm_time < $asm_time) {
      generate_ppm_record($queue_ppm_records[$ppm_record]);
      $current_asm_record-- if $asm_record != -1;$current_sip_record-- if $sip_record != -1;
    } elsif ($sip_time < $asm_time && $sip_time == $ppm_time) {
      my $rem_ip = $queue_sip_records[$sip_record]{host};
      if (($queue_sip_records[$sip_record]{send_receive} eq "Outgoing" && ($rem_ip eq "$asm_ip" || $rem_ip eq "$asm_ipv6")) || ($queue_sip_records[$sip_record]{send_receive} eq "Incoming" && ($rem_ip eq "$sm100_ip" || $rem_ip eq "$sm100_ipv6"))) {
        generate_sip_record($queue_sip_records[$sip_record]);
        $current_ppm_record-- if $ppm_record != -1;$current_asm_record-- if $asm_record != -1;
      } else {
        generate_ppm_record($queue_ppm_records[$ppm_record]);
        $current_sip_record-- if $sip_record != -1;$current_asm_record-- if $asm_record != -1;
      }
    } elsif ($sip_time < $ppm_time && $sip_time == $asm_time) {
      my $rem_ip = $queue_sip_records[$sip_record]{host}; 
      if (($queue_sip_records[$sip_record]{send_receive} eq "Outgoing" && ($rem_ip eq "$asm_ip" || $rem_ip eq "$asm_ipv6")) || ($queue_sip_records[$sip_record]{send_receive} eq "Incoming" && ($rem_ip eq "$sm100_ip" || $rem_ip eq "$sm100_ipv6"))) {
        generate_sip_record($queue_sip_records[$sip_record]);
        $current_ppm_record-- if $ppm_record != -1;$current_asm_record-- if $asm_record != -1;
      } else {
        generate_asm_record($queue_asm_records[$asm_record]);
        $current_sip_record-- if $sip_record != -1;$current_ppm_record-- if $ppm_record != -1;
      }
    } elsif (($asm_time < $sip_time && $asm_time == $ppm_time) || ($ppm_time < $sip_time && $asm_time == $ppm_time)) {
      generate_asm_record($queue_asm_records[$asm_record]);
      $current_sip_record-- if $sip_record != -1;$current_ppm_record-- if $ppm_record != -1;
    } elsif ($asm_time == $sip_time && $asm_time == $ppm_time && $sip_time == $ppm_time) {
      my $rem_ip = $queue_sip_records[$sip_record]{host};
      if (($queue_sip_records[$sip_record]{send_receive} eq "Outgoing" && ($rem_ip eq "$asm_ip" || $rem_ip eq "$asm_ipv6")) || ($queue_sip_records[$sip_record]{send_receive} eq "Incoming" && ($rem_ip eq "$sm100_ip" || $rem_ip eq "$sm100_ipv6"))) {
        generate_sip_record($queue_sip_records[$sip_record]);
        $current_ppm_record-- if $ppm_record != -1;$current_asm_record-- if $asm_record != -1;
      } else {
        generate_asm_record($queue_asm_records[$asm_record]);
        $current_sip_record-- if $sip_record != -1;$current_ppm_record-- if $ppm_record != -1;
      }
    } else {
      print TMP "we should never be here. How did I get here???????????????????\n";
      exit;
    } 
  }   
}

sub filter_message {
  my $ref = shift;
  my %message = %$ref;

  if ($message{type} eq "INFO") {
    return filter_asm_message($ref);
  } elsif ($message{type} eq "RTP") {
    return filter_rtp_message($ref);
  } elsif ($message{type} eq "PPM") {
    return filter_ppm_message($ref);
  } elsif ($message{type} eq "TLS") {
    return filter_tls_message($ref);
  } elsif ($message{type} eq "PUSH_NOTIFICATION_REQ" || $message{type} eq "PUSH_NOTIFICATION_RESP") {
    return filter_push_notification_message($ref);
  } else {
    return filter_sip_message($ref);
  }
}

sub filter_asm_message {
  my $ref = shift;
  my %message = %$ref;

  return 1 if $no_asm;

  if ($display_asm != -1) {
    # Some SM messages have the SIP Call-ID for the call that belongs, in those
    # cases we use that to filter them. In case there is no Call-ID, we use the
    # timestamp to filter them (based on $display_asm)
    if ($message{call_id} ne "" && exists($calls{$message{call_id}})) {
      return 1 if $calls{$message{call_id}}{status}<=0;
    } else {
      return 1 if $display_asm == 0;
    }
  }

  my $dg_record_no = scalar (@display_dg_records);
  $display_dg_records[$dg_record_no] = &share({});
  $display_dg_records[$dg_record_no] = $ref;
  return 0;
}

sub filter_ppm_message {
  my $ref = shift;
  my %message = %$ref;
  my $match = 0;

  return 1 if $no_ppm;

  # Filter based on the host IP address
  if ($host_ip) {
    $host = $message{host};
    if ($host !~ /($host_ip)/) {
      return 1 if !$or;
    } else {
      $match=1;
    }
  }

  # Filter based on the Handle
  if ($uri) {
    if ($message{handle} !~ /($uri)/) {
      return 1 if !$or;
    } else {
      $match=1;
    }
  }

  # If there was no match and the OR operator is set, then return
  if ($or && $match == 0) {
    return 1;
  }

  # If there was any other filter (expect the do not display OPTIONS/REG/SUB/etc) and we did not match, then return
  if (($call_id || $global_session_id || $gsi_call_id || $header_value) && $match == 0) {
    return 1;
  }
 
  my $dg_record_no = scalar (@display_dg_records);
  $display_dg_records[$dg_record_no] = &share({});
  $display_dg_records[$dg_record_no] = $ref;
  return 0;
}

sub filter_tls_message {
  my $ref = shift;
  my %message = %$ref;
  my $match = 0;

  return 1 if $no_tls;

  # Filter based on the host IP address
  if ($host_ip) {
    $host = $message{host};
    if ($host !~ /($host_ip)/) {
      return 1 if !$or;
    } else {
      $match=1;
    }
  }

  # If there was no match and the OR operator is set, then return
  if ($or && $match == 0) {
    return 1;
  }

  # If there was any other filter (expect the do not display OPTIONS/REG/SUB/etc) and we did not match, then return
  if (($call_id || $global_session_id || $gsi_call_id || $header_value) && $match == 0) {
    return 1;
  }


  my $dg_record_no = scalar (@display_dg_records);
  $display_dg_records[$dg_record_no] = &share({});
  $display_dg_records[$dg_record_no] = $ref;
  return 0;
}

sub filter_sip_message {
  my $ref = shift;
  my %message = %$ref;
  my $match = 0;
  my $host;

  # When WAS does not Record-Route, Asset still does RR so there are messages that loop on Asset. Those make
  # people confuse, so we do not display them by default unless the clikc "a" to see the WAS and Asset interaction.
  # For that reason we include here the Asset IPs as well
  return 1 if !($show_asm) && ($message{host} eq "$sm100_ip" || $message{host} eq "$sm100_ipv6" || $message{host} eq "$asm_ip" || $message{host} eq "$asm_ipv6" || $message{host} eq "127.0.0.1" || $message{host} eq "::1" || $message{host} eq "127.0.0.2" || $message{host} eq "::2");
  
  if ($no_subscribe) {
    if ($message{type} eq "REQUEST" && $message{method} =~ /SUBSCRIBE|NOTIFY/) {
      return 1;
    }
    if ($message{type} eq "RESPONSE" && $message{sip} =~ /^CSeq: \d+ (SUBSCRIBE|NOTIFY)/mi) {
      return 1;
    }
  }

  if ($no_options) {
    if ($message{type} eq "REQUEST" && $message{method} eq "OPTIONS") {
      return 1;
    }
    if ($message{type} eq "RESPONSE" && $message{sip} =~ /^CSeq: \d+ OPTIONS/mi) {
      return 1;
    }
  }

  if ($no_register) {
    if ($message{type} eq "REQUEST" && $message{method} eq "REGISTER") {
      return 1;
    }
    if ($message{type} eq "RESPONSE" && $message{sip} =~ /^CSeq: \d+ REGISTER/mi) {
      return 1;
    }
  }

  if ($no_pingpong) {
    if ($message{type} eq "PINGPONG") {
      return 1;
    }
  }

  # Filter based on the host IP address
  if ($host_ip) {
    $host = $message{host};
    if ($host !~ /($host_ip)/) {
      return 1 if !$or;
    } else {
      $match=1;
    } 
  }

  # Filter based on the From: and To: fields
  if ($uri) {
    if ($message{sip} !~ /^(From|To|f|t): .*($uri).*/mi) {
      return 1 if !$or; 
    } else {
      $match=1;
    }
  }

  # Filter based on the Call-ID field
  if ($call_id) {
    if ($message{call_id} !~ /$call_id/) {
      return 1 if !$or;
    } else {
      $match=1;
    }
  }

  # Filter based on the Global-Session-ID field
  if ($global_session_id && !($gsi_call_id)) {
    if ($message{sip} !~ /^Av-Global-Session-ID: $global_session_id/mi) {
      return 1 if !$or;
    } else {
      $match=1;
    }
  }

  # Filter based on the Global-Session-ID using the created Call-ID filter
  if ($gsi_call_id) {
    if ($message{call_id} !~ /$gsi_call_id/) {
      return 1 if !$or;
    } else {
      $match=1;
    }
  }

  # Filter based on any SIP header and value
  if ($header_value) {
    $header_value =~ /(.*?)=(.*)/;
    if ($message{sip} !~ /^($1): .*($2).*/m) {
      return 1 if !$or;
    } else {
      $match=1;
    }
  }

  # Filter based on a generic regex. If the message
  # contain the regex, then add the Call-ID to the 
  # $contain_regex_callid hash.
  if ($contain_regex) {
    if (exists($contain_regex_callid{$message{call_id}})) {
      $match=1;
    } elsif ($message{sip} !~ /$contain_regex/) {
      return 1 if !$or;
    } else {
      $contain_regex_callid{$message{call_id}} = 1;
      $match=1;
    }
  }


  # If there was no match and the OR operator is set, then return
  if ($or && $match == 0) {
    return 1;
  }

  # If we are here, the message passed all the filters so we
  # add the record to the display_dg_records array
  my $dg_record_no = scalar (@display_dg_records);
  $display_dg_records[$dg_record_no] = &share({});
  $display_dg_records[$dg_record_no] = $ref;
  # Flag the SIP Call-ID to display the corresponded RTP packets
  if (exists($calls{$message{call_id}})) {
    $calls{$message{call_id}}{display} = 1;
  } else {
    return 1;
  }


  # We create the label again after filtering because it can change
  # when using the SM100 as some of the reINVITEs are now INVITEs
  $display_dg_records[$dg_record_no]{label} = get_label(\%message); 

  if ($display_asm != -1) {
    # we display all the SM log entries between the first incoming
    # SIP request and the first non-Trying response from SM
    my ($response_code) = $message{response} =~ /^(\d+) .*/;
    if ($calls{$message{call_id}}{status} == 0 && $message{type} eq "REQUEST" && $message{send_receive} eq "Incoming" && $message{method} ne "ACK") {
      $calls{$message{call_id}}{status} = 1;
      $display_asm++;
    } elsif ($calls{$message{call_id}}{status} == 1 && $message{type} eq "RESPONSE" && $message{send_receive} eq "Outgoing" && $response_code > 100) {
      $calls{$message{call_id}}{status} = 2;
      $display_asm--;
    }
  }
  return 0;
}

sub filter_rtp_message {
  my $ref = shift;
  my %message = %$ref;

  return 1 if !$display_rtp;
  return 1 if $calls{$message{call_id}}{display} == 0;

  # Add the record to the display_dg_records array
  my $dg_record_no = scalar (@display_dg_records);
  $display_dg_records[$dg_record_no] = &share({});
  $display_dg_records[$dg_record_no] = $ref;

  add_column($display_dg_records[$dg_record_no]{ep_1});
  add_column($display_dg_records[$dg_record_no]{ep_2});


  return 0;
}

sub queue_rtp_record {
  my $params = shift;
  my %message = %$params;
  my $host;

  my ($day,$month,$year) = $message{day} =~ /(\d{1,2})\/(\d{1,2})\/(\d{4})/;
  my ($hour,$minute,$seconds,$milliseconds) = $message{timestamp} =~ /(\d{1,2}):(\d{1,2}):(\d{1,2})\.(\d{1,3})?/;
  my $ts = timelocal($seconds,$minute,$hour,$day,$month-1,$year) + $milliseconds/1000;

  undef(%record);
  # Add the record to the array of queue_sip_records
  my $queue_sip_records_no = scalar (@queue_sip_records);
  $queue_sip_records[$queue_sip_records_no] = &share({});
  $queue_sip_records[$queue_sip_records_no]{day} = $message{day};
  $queue_sip_records[$queue_sip_records_no]{timestamp} = $message{timestamp};
  $queue_sip_records[$queue_sip_records_no]{time_seconds} = $ts;
  $queue_sip_records[$queue_sip_records_no]{protocol} = $message{protocol};
  $queue_sip_records[$queue_sip_records_no]{host} = $message{host};
  $queue_sip_records[$queue_sip_records_no]{port} = $message{port};
  $queue_sip_records[$queue_sip_records_no]{type} = $message{type};
  $queue_sip_records[$queue_sip_records_no]{send_receive} = $message{send_receive};
  $queue_sip_records[$queue_sip_records_no]{call_id} = $message{call_id};
  $queue_sip_records[$queue_sip_records_no]{desc} = get_desc(\%message);
  $queue_sip_records[$queue_sip_records_no]{sip} = $message{sip};
  $queue_sip_records[$queue_sip_records_no]{method} = $message{method};
  $queue_sip_records[$queue_sip_records_no]{response} = $message{response};
  $queue_sip_records[$queue_sip_records_no]{local_host} = $message{local_host};
  $queue_sip_records[$queue_sip_records_no]{local_port} = $message{local_port};
  $queue_sip_records[$queue_sip_records_no]{dropped_by} = $message{dropped_by};
  $queue_sip_records[$queue_sip_records_no]{dropped_reason} = $message{dropped_reason};

  #generate_sip_record($queue_sip_records[$queue_sip_records_no]);
}

sub queue_sip_record {
  my $params = shift;
  my %message = %$params;
  my $host;
  #my ($day,$month,$year) = $message{day} =~ /(\d{1,2})\/(\d{1,2})\/(\d{4})/;
  #my ($hour,$minute,$seconds,$milliseconds) = $message{timestamp} =~ /(\d{1,2}):(\d{1,2}):(\d{1,2})\.(\d{1,3})?/;
  next unless my ($day,$month,$year) = $message{day} =~ /(\d{1,2})\/(\d{1,2})\/(\d{4})/;
  if ($type eq "onexc") {
    # Swap day and month
    my $tmp_day = $day;
    $day = $month;
    $month = $tmp_day;
    next unless ($hour,$minute,$seconds,$milliseconds) = $message{timestamp} =~ /(\d{1,2}):(\d{1,2}):(\d{1,2}):(\d{1,3})?/;
  } else {
    next unless ($hour,$minute,$seconds,$milliseconds) = $message{timestamp} =~ /(\d{1,2}):(\d{1,2}):(\d{1,2})\.(\d{1,3})?/;
  }
  my $ts = timelocal($seconds,$minute,$hour,$day,$month-1,$year) + $milliseconds/1000;
  undef(%record);
  # Add the record to the array of queue_sip_records
  my $queue_sip_records_no = scalar (@queue_sip_records);
  $queue_sip_records[$queue_sip_records_no] = &share({});
  $queue_sip_records[$queue_sip_records_no]{day} = $message{day};
  $queue_sip_records[$queue_sip_records_no]{timestamp} = $message{timestamp};
  $queue_sip_records[$queue_sip_records_no]{time_seconds} = $ts;
  $queue_sip_records[$queue_sip_records_no]{protocol} = $message{protocol};
  $queue_sip_records[$queue_sip_records_no]{host} = $message{host};
  $queue_sip_records[$queue_sip_records_no]{port} = $message{port};
  $queue_sip_records[$queue_sip_records_no]{type} = $message{type};
  $queue_sip_records[$queue_sip_records_no]{send_receive} = $message{send_receive};
  $queue_sip_records[$queue_sip_records_no]{call_id} = $message{call_id};
  $queue_sip_records[$queue_sip_records_no]{desc} = get_desc(\%message);
  $queue_sip_records[$queue_sip_records_no]{sip} = $message{sip};
  $queue_sip_records[$queue_sip_records_no]{method} = $message{method};
  $queue_sip_records[$queue_sip_records_no]{response} = $message{response};
  $queue_sip_records[$queue_sip_records_no]{local_host} = $message{local_host};
  $queue_sip_records[$queue_sip_records_no]{local_port} = $message{local_port};
  $queue_sip_records[$queue_sip_records_no]{dropped_by} = $message{dropped_by};
  $queue_sip_records[$queue_sip_records_no]{dropped_reason} = $message{dropped_reason};
  $queue_sip_records[$queue_sip_records_no]{context} = $message{context};
  #generate_sip_record($queue_sip_records[$queue_sip_records_no]); 
}

sub queue_tls_record {
  my $params = shift;
  my %message = %$params;
  undef(%record);
  my ($year,$month,$day) = $message{day} =~ /(\d{4})-(\d{1,2})-(\d{1,2})/;
  my ($hour,$minute,$seconds,$milliseconds) = $message{timestamp} =~ /(\d{1,2}):(\d{1,2}):(\d{1,2})\.(\d{1,3})?/;
  my $ts = timelocal($seconds,$minute,$hour,$day,$month-1,$year) + $milliseconds/1000;

  my $queue_tls_records_no = scalar (@queue_tls_records);
  $queue_tls_records[$queue_tls_records_no] = &share({});
  $queue_tls_records[$queue_tls_records_no]{day} = $message{day};
  $queue_tls_records[$queue_tls_records_no]{timestamp} = $message{timestamp};
  $queue_tls_records[$queue_tls_records_no]{time_seconds} = $ts;
  $queue_tls_records[$queue_tls_records_no]{send_receive} = $message{send_receive};
  $queue_tls_records[$queue_tls_records_no]{type} = $message{type};
  $queue_tls_records[$queue_tls_records_no]{desc} = $message{desc};
#  my $key = "$message{host}_$message{local_port}_$message{port}";
#  $queue_tls_records[$queue_tls_records_no]{desc} = "(T".$tls_streams{$key}.") ".$message{desc};
  $queue_tls_records[$queue_tls_records_no]{label} = $message{label};
  $queue_tls_records[$queue_tls_records_no]{msg} = $message{msg};
  $queue_tls_records[$queue_tls_records_no]{host} = $message{host};
  $queue_tls_records[$queue_tls_records_no]{port} = $message{port};
  $queue_tls_records[$queue_tls_records_no]{local_host} = $message{local_host};
  $queue_tls_records[$queue_tls_records_no]{local_port} = $message{local_port};
  $queue_tls_records[$queue_tls_records_no]{protocol} = $message{protocol};
}

sub generate_sip_record {
  my $params = shift;
  my %message = %$params;
  my $host;

#my ($day,$month,$year) = $message{day} =~ /(\d{1,2})\/(\d{1,2})\/(\d{4})/;
#my ($hour,$minute,$seconds,$milliseconds) = $message{timestamp} =~ /(\d{1,2}):(\d{1,2}):(\d{1,2})\.(\d{1,3})?/;
#my $ts = timelocal($seconds,$minute,$hour,$day,$month-1,$year) + $milliseconds/1000;
#if ($last_timestamp > $ts) {
#  print TMP "OUT OF ORDER SIP: last_timestamp $last_timestamp  ts $ts  message{timestamp}  $message{timestamp}\n";
#}
#$last_timestamp = $ts;

  # add the record to the dg_records array
  my $dg_record_no = scalar (@dg_records);
  $dg_records[$dg_record_no] = &share({});
  $dg_records[$dg_record_no] = $params;

  undef(%record);
  
  if ($dg_records[$dg_record_no]{type} eq "RTP") {
    my $filtered = filter_rtp_message($dg_records[$dg_record_no]);
    if ($filtered == 0) {
      # When capturing, if the cursor is in the bottom we refresh the screen
      $dg_record_no = scalar(@display_dg_records);
      if ($capture_mode ne "opening_file" && $display_mode ne "details") {
        if ($dg_rec_pos == $dg_record_no-1) {
          $dg_rec_pos = $dg_record_no;
        }
      }
      refresh();
    }
  } else {  # SIP packet
    my $filtered = filter_sip_message($dg_records[$dg_record_no]);
    if ($filtered == 0) {
      if ($message{send_receive} eq "Outgoing") {
        add_column($message{local_host});
        add_column($message{host});
      } else {
        add_column($message{host});
        add_column($message{local_host});
      }
 
      # When capturing, if the cursor is in the bottom we refresh the screen
      $dg_record_no = scalar(@display_dg_records);
#print TMP "generate capture_mode: $capture_mode dg_record_no: $dg_record_no\n";
      if ($capture_mode ne "opening_file" && $display_mode ne "details") {
        if ($dg_rec_pos == $dg_record_no-1) {
          $dg_rec_pos = $dg_record_no;
        }
      }
      refresh();
    }
  }
}

sub process_rtp_packet {
  my $params = shift;
  my %message = %$params;
  my $host;
  my $endpoint_ip;
  my $port;
  undef(%record);
  my @codecs;
  my $codec;
  my $origin;
  my $from_tag;
  my $new_or_change = 0;

  # Only process "Outgoing" messages from SM. This  
  # will add the new RTP entry after the message
  # is delivered which makes the RTP simulation
  # more realistic.
  return if $message{send_receive} ne "Outgoing";

  # Get the IP and port from the SDP, or retrun if no SDP
  if ($message{sip} =~ /^c=IN IP4 (\d+\.\d+\.\d+\.\d+)/m) {
    $endpoint_ip = $1;
  } else {
    return;
  }

  %rtp_payload = (
    0 => 'G711u',
    3 => 'GSM',
    4 => 'G723',
    5 => 'DVI4',
    6 => 'DVI4',
    7 => 'LPC',
    8 => 'G711a',
    9 => 'G722',
    10 => 'L16',
    11 => 'L16',
    12 => 'QCELP',
    13 => 'CN',
    14 => 'MPA',
    15 => 'G728',
    16 => 'DVI4',
    17 => 'DVI4',
    18 => 'G729',
  );

  # get the codec and port 
  if ($message{sip} =~ /^m=audio (\d+) RTP\/AVP (.*)/m) {
    $endpoint_port = $1;
    @codecs = split(" ",$2);
    # Check the well known RTP payload types
    if (exists($rtp_payload{$codecs[0]})) {
      $codec = $rtp_payload{$codecs[0]};
 
    # If not well known, check the SDP for 'a=rtpmap'
    } elsif ($message{sip} =~ /^a=rtpmap:$codecs[0] (.*?)\//m) {
      $codec = $1;
    } else {
      $codec = 'UKN';
    }  
  } else {
    return;
  } 

  # get the origin/owner 'o=' of this SDP
  if ($message{sip} =~ /^o=.*IN IP4 (.*)/m) {
    $origin = $1;
  } else {
    return;
  }

  # get the from tag
  if ($message{sip} =~ /^(From|f): .*;tag=(.*)$/m) {
    $from_tag = $2;
  } else {
    return;
  }

  if (!exists($rtp{$message{call_id}}) || (exists($rtp{$message{call_id}}) && $rtp{$message{call_id}}{ori_1} ne $origin) && $rtp{$message{call_id}}{first_from_tag} eq $from_tag && $rtp{$message{call_id}}{first_type} eq $message{type}) {
    # New RTP stream. Add the originator/owner of the SDP, and endpoint 1 info.
    $rtp{$message{call_id}} = &share({});
    $rtp{$message{call_id}}{ori_1} = $origin;
    $rtp{$message{call_id}}{ep_1} = $endpoint_ip;
    $rtp{$message{call_id}}{port_1} = $endpoint_port;
    $rtp{$message{call_id}}{mode} = "sendrecv";
    $rtp{$message{call_id}}{ori_2} = "";
    $rtp{$message{call_id}}{ep_2} = "";
    $rtp{$message{call_id}}{port_2} = 0;
    $rtp{$message{call_id}}{first_type} = $message{type}; # REQUEST or RESPONSE
    $rtp{$message{call_id}}{first_from_tag} = $from_tag;
	$rtp{$message{call_id}}{offer_answer} = "offer";
    return;
  } else {
    if ($rtp{$message{call_id}}{offer_answer} eq "offer") {
      $rtp{$message{call_id}}{offer_answer} = "answer";
    } else {
      $rtp{$message{call_id}}{offer_answer} = "offer";
	}
    # Existing RTP.
    if ($rtp{$message{call_id}}{first_from_tag} eq $from_tag) {
      if ($rtp{$message{call_id}}{first_type} eq $message{type}) {
		return if $rtp{$message{call_id}}{ep_1} eq $endpoint_ip && $rtp{$message{call_id}}{port_1}==$endpoint_port && $rtp{$message{call_id}}{offer_answer} eq "offer";
        $rtp{$message{call_id}}{ep_1} = $endpoint_ip;
        $rtp{$message{call_id}}{port_1} = $endpoint_port;
      } else {
        return if $rtp{$message{call_id}}{ep_2} eq $endpoint_ip && $rtp{$message{call_id}}{port_2}==$endpoint_port;
        $rtp{$message{call_id}}{ep_2} = $endpoint_ip;
        $rtp{$message{call_id}}{port_2} = $endpoint_port;
      }  
    } else {
      if ($rtp{$message{call_id}}{first_type} eq $message{type}) {
        return if $rtp{$message{call_id}}{ep_2} eq $endpoint_ip && $rtp{$message{call_id}}{port_2}==$endpoint_port;
        $rtp{$message{call_id}}{ep_2} = $endpoint_ip;
        $rtp{$message{call_id}}{port_2} = $endpoint_port;
      } else {
        return if $rtp{$message{call_id}}{ep_1} eq $endpoint_ip && $rtp{$message{call_id}}{port_1}==$endpoint_port;
        $rtp{$message{call_id}}{ep_1} = $endpoint_ip;
        $rtp{$message{call_id}}{port_1} = $endpoint_port;
      }
    }
  }

  # If the request (e.g INVITE) was retransmited or is coming twice from diff IPs
  # then ep_2 could still be blank 
  return if $rtp{$message{call_id}}{ep_2} eq "";
        
  # Update RTP stream info on display only if message represents SDP answer 
  return if $rtp{$message{call_id}}{offer_answer} ne "answer";  

  # Queue RTP record
  $message{type} = "RTP"; 
  # Add the record to the array of queue_sip_records
  my $queue_sip_records_no = scalar (@queue_sip_records);
  $queue_sip_records[$queue_sip_records_no] = &share({});
  $queue_sip_records[$queue_sip_records_no]{day} = $message{day};
  $queue_sip_records[$queue_sip_records_no]{timestamp} = $message{timestamp};
  $queue_sip_records[$queue_sip_records_no]{protocol} = $message{protocol};
  $queue_sip_records[$queue_sip_records_no]{host} = $message{host};
  $queue_sip_records[$queue_sip_records_no]{port} = $message{port};
  $queue_sip_records[$queue_sip_records_no]{type} = $message{type};
  $queue_sip_records[$queue_sip_records_no]{send_receive} = $message{send_receive};
  $queue_sip_records[$queue_sip_records_no]{call_id} = $message{call_id};
  $queue_sip_records[$queue_sip_records_no]{ep_1} = $rtp{$message{call_id}}{ep_1};
  $queue_sip_records[$queue_sip_records_no]{ep_2} = $rtp{$message{call_id}}{ep_2};
  $queue_sip_records[$queue_sip_records_no]{port_1} = $rtp{$message{call_id}}{port_1};
  $queue_sip_records[$queue_sip_records_no]{port_2} = $rtp{$message{call_id}}{port_2};
  $queue_sip_records[$queue_sip_records_no]{mode} = $rtp{$message{call_id}}{mode};
  $queue_sip_records[$queue_sip_records_no]{codec} = $codec;
  $queue_sip_records[$queue_sip_records_no]{desc} = get_desc(\%{$queue_sip_records[$queue_sip_records_no]});
  $queue_sip_records[$queue_sip_records_no]{label} = get_label(\%{$queue_sip_records[$queue_sip_records_no]});
}

sub add_column {
#printstack();
  my ($host) = @_;
  my $col_name;
  return if $host eq "";
  # Add the host to the column
  if (!exists($dg_columns{$host})) {
    $dg_columns{$host} = keys(%dg_columns) + 1;
    return 1;
  }
  return 0;
}

sub generate_dg_line {
  my ($params,$reverse) = @_;
  my %record = %$params;
  my $label = "";
  my $desc = "";
  my $timestamp = $record{timestamp};
  my $width;
  my $dir = "-";
  my $host;
  my $column_start;

  # Add the IP as a new column if it is the first time it appears
  if ($record{type} eq "RTP") {
    add_column($record{ep_1});
    add_column($record{ep_2});
  } else {  
    add_column($record{host});
    add_column($record{local_host});
  }

  my $dg_column_no = max(3,keys(%dg_columns) - 1); 
  if ($record{type} eq "INFO") {
    $width = $dg_column_width * min($dg_column_no,int(($max_col-12-25) / $dg_column_width));
  } elsif ($record{type} eq "RTP") {
    my $column_1 = $dg_columns{$record{ep_1}}; 
    my $column_2 = $dg_columns{$record{ep_2}};
    $column_start = min($column_1, $column_2) - 1;
    $width = $dg_column_width * (abs($column_2 - $column_1));
  } else { # SIP line/PUSH NOTIFICATION 
    my $column_1 = $dg_columns{$record{host}};
    my $column_2 = $dg_columns{$record{local_host}};
    $column_start = min($column_1, $column_2) - 1;
    $width = $dg_column_width * (abs($column_2 - $column_1));
  }

  $desc = $record{desc};
  $label = $record{label};

  # Truncate the label if necessary
  $label = sprintf("%.".($width-5)."s", $label);

  my $labelWidth = length($label);
  my $arrow;
  my $line;
  my $separators = "";
  
  #if ($record{type} !~ /ERROR|INFO/) {
  if ($record{type} !~ /INFO/) {
    if ($record{type} eq "RTP") {
      $dir = "<>";
    } else {
      if (($record{send_receive} eq "Outgoing" && $dg_columns{$record{host}} < $dg_columns{$record{local_host}}) || ($record{send_receive} eq "Incoming" && $dg_columns{$record{host}} > $dg_columns{$record{local_host}})) {
        $dir = "<";
      } else {
        $dir = ">";
      }
    }
    $separators = ($vert_chr.(" "x($dg_column_width-1)))x($dg_column_no).$vert_chr;
  }

  if ($record{type} eq "PUSH_NOTIFICATION_RESP" || $record{type} eq "PUSH_NOTIFICATION_REQ") {
    $lc = $thick_line_chr;
  } else {
    $lc = $line_chr;
  }

  if ($dir eq ">") {
    $arrow = $lc x ($width/2 - int($labelWidth/2) - 1).$label.$lc x ($width/2 - $labelWidth/2 - 1).$right_arrow_chr;
  } elsif ($dir eq "<") {
    $arrow = $left_arrow_chr.$lc x ($width/2 - int($labelWidth/2) - 1).$label.$lc x ($width/2 - $labelWidth/2 -1);
  } elsif ($dir eq "<>") {
    $arrow = $left_arrow_chr.$wide_line_chr x ($width/2 - int($labelWidth/2) - 1).$label.$wide_line_chr x ($width/2 - $labelWidth/2 -2).$right_arrow_chr;
  } else {
    $arrow = $vert_chr." "x($width/2 - int($labelWidth/2) - 1).$label." "x($width/2 - $labelWidth/2 ).$vert_chr;
  }
  my $arrow_width = length($arrow);
  my $color_width = 0;

  my $call_number;
  my $apns_tx_number;
  my $color = "";
  
  if ($record{type} =~ "REQUEST|RESPONSE|RTP") {
    if (!exists($record{call_id}) || !exists($calls{$record{call_id}})) {
      $desc = "ERROR in traceSM";
    } else {
      $call_number = $calls{$record{call_id}}{number};
      $desc = "($call_number) $desc";
      $color = $colors[($call_number-1) % ($#colors+1)];
    }
  } elsif ($record{type} =~ "PUSH_NOTIFICATION_REQ|PUSH_NOTIFICATION_RESP") {
    if (!exists($record{apns_id}) || !exists($apns_tx{$record{apns_id}})) {
      $desc = "ERROR in traceSM";
    }   else {
    $apns_tx_number = $apns_tx{$record{apns_id}}{number};
    $desc = "$record{desc}";
    $color = $colors[($apns_tx_number-1) % ($#colors+1)];
    } 
  } elsif ($record{type} eq "INFO") {
    if ($record{color}) {
      $color = $record{color};
    }
  } elsif ($record{type} eq "TLS") {
    my $key = "$record{host}_$record{local_port}_$record{port}";
    $desc = "(T".$tls_streams{$key}.") ".$desc;
    $color = "tls".(($tls_streams{$key}-1) % keys(%tls_colors));
  } 

  $timestamp = substr($timestamp,0,12);

  # Create the middle section (arrows and separators)
  my $mid_sec;
  my $color_start;
  my $color_end;
  my $trunc_start;
  my $trunc_end;
  my $desc_len;

  if ($record{type} eq "INFO") {
    $mid_sec = $arrow;
    $desc_len = $max_col - length($mid_sec) - 14;
    $mid_sec = colored($mid_sec,$color.' '.$reverse);
  } else {
    if ($width == 0) { # loop on the same IP
      if ($record{type} eq "RTP") { # RTP
        $mid_sec = substr($separators, 0, $column_start*$dg_column_width)."o".substr($separators, 1+$column_start*$dg_column_width);
        $color_start = $column_start*$dg_column_width;
        $color_end = $color_start;
      } else {                      # SIP (display a ->|<- but only if the show WAS option is enabled)
        if ($column_start == 0) {
          $mid_sec = substr($separators, 0, $column_start*$dg_column_width).$vert_chr.$left_arrow_chr.$line_chr.substr($separators, 3+$column_start*$dg_column_width);
          $color_start = $column_start;
          $color_end = $color_start+2;
        } else {
          $mid_sec = substr($separators, 0, $column_start*$dg_column_width-2).$line_chr.$right_arrow_chr.$vert_chr.$left_arrow_chr.$line_chr.substr($separators, 3+$column_start*$dg_column_width);
          $color_start = $column_start*$dg_column_width-2;
          $color_end = $color_start+4;
        }
        if ($record{type} eq "REQUEST") {
          $desc =~ s/(\(\d+\) )(.*)/\1$record{label} \2/;
        }
      }
    } else {           # normal case (two different IPs) 
      $mid_sec = substr($separators, 0, 1+$column_start*$dg_column_width).$arrow.substr($separators, length($arrow)+1+$column_start*$dg_column_width);
      $color_start = 1+$column_start*$dg_column_width;
      $color_end = $color_start + length($arrow) - 1;
    }

    # truncate the middle section
    $trunc_start = ($dg_col_pos-1)*$dg_column_width;
    $trunc_end = $trunc_start + min($dg_column_no,int(($max_col-12-25) / $dg_column_width))*$dg_column_width;
    # Color the arrow and apply reverse if applicable
    if ($trunc_start > $color_end || $color_start > $trunc_end) {
      $mid_sec = colored(substr($mid_sec,$trunc_start,$trunc_end+1-$trunc_start),$reverse);
    } elsif ($color_start <= $trunc_start && $color_end >= $trunc_end) {
      $mid_sec = colored(substr($mid_sec,$trunc_start,$trunc_end+1-$trunc_start),$color.' '.$reverse);
    } elsif ($trunc_start >= $color_start && $color_end < $trunc_end) {
      $mid_sec = colored(substr($mid_sec,$trunc_start,$color_end+1-$trunc_start),$color.' '.$reverse).colored(substr($mid_sec,$color_end+1,$trunc_end-$color_end),$reverse);
    } elsif ($trunc_start < $color_start && $trunc_end <= $color_end) {
      $mid_sec = colored(substr($mid_sec,$trunc_start,$color_start-$trunc_start),$reverse).colored(substr($mid_sec,$color_start,$trunc_end+1-$color_start),$color.' '.$reverse);
    } else {
#print TMP "len ".length($mid_sec)." mid_sec $mid_sec trunc_start $trunc_start color_start $color_start color_end $color_end trunc_end $trunc_end\n";
      $mid_sec = colored(substr($mid_sec,$trunc_start,$color_start-$trunc_start),$reverse).colored(substr($mid_sec,$color_start,$color_end+1-$color_start),$color.' '.$reverse).colored(substr($mid_sec,$color_end+1,$trunc_end-$color_end),$reverse);
    }
    $desc_len = $max_col - ($trunc_end-$trunc_start) - 15;
  }

  $desc = substr($desc,0,$desc_len);
  $desc .= " " x ($desc_len - length($desc) );
  if ($record{dropped_by} ne "") {
    $line .= $timestamp." ".$mid_sec.colored(" ".$desc,"red reverse");
  } else {
    $line .= $timestamp." ".$mid_sec." ".$desc;
  }
  return $line;
}

sub dg_refresh_header {
  my $first_header = "";
  my $second_header = "";
  my $host_id;
  my $host;
  my $column;

  my $dg_column_width = 12;
  my $max_col_screen;
  my $dg_column_no;

  $dg_column_no = keys(%dg_columns) - 1;
  if ($dg_column_no == -1) { return; };

  $max_col_screen = min($dg_column_no,int(($max_col-12-25) / $dg_column_width));

  foreach $host_id (sort {$dg_columns{$a} <=> $dg_columns{$b} } keys %dg_columns) {
    next if ($dg_columns{$host_id} < $dg_col_pos);
    last if ($dg_columns{$host_id}-$dg_col_pos > $max_col_screen);

    $host = $host_id;
    if (length($host) > (2*$dg_column_width-2)) {
      # Truncate IPv6 to include the last part as it is more significant
      $host = "<".substr($host_id,length($host)-(2*$dg_column_width-3),2*$dg_column_width-3); 
    }
    if ($display_name) {
      # Use the SIP Entity name (or LNR) instead of the IP
      $host = substr(get_ip_name($host_id),0,2*$dg_column_width-2);
    }
    if ($host_id =~ /:/) { # highligh (bold) the IPv6 names or IPs
      $host = colored($host, "bold"); 
    }

    if ($dg_columns{$host_id} % 2) {
      $first_header .= " "x((($dg_columns{$host_id}-$dg_col_pos+1) * $dg_column_width) - (length_no_color($host)/2) - length_no_color($first_header)).$host;
    } else {
      $second_header .= " "x((($dg_columns{$host_id}-$dg_col_pos+1) * $dg_column_width) - (length_no_color($host)/2) - length_no_color($second_header)).$host;
    }
  }

  my $low_line = (($line_chr x (13)).$vert_sep_l_chr) ;
  $low_line .= (($line_chr x (12-1)).$vert_sep_l_chr)x($max_col_screen);
  $low_line .= $line_chr x ($max_col-17-length($low_line));
  $low_line .= ($goto_search ? $vert_sep_h_chr.$line_chr."n=Next".($line_chr x 2)."p=Prev".$line_chr : ($line_chr x 18));
  my $high_line;
  $high_line = ($line_chr x ($max_col-17)).($goto_search ? $vert_sep_l_chr.($line_chr x 5)."Search".($line_chr x 5) : ($line_chr x 17));        
  goto_xy(0,0);
  print "$high_line\n";
  $first_header = "  ".$first_header;
  $first_header .= " " x ($max_col-17-length_no_color($first_header));
  goto_xy(0,2);
  $second_header = "  ".$second_header;
  $second_header .= " " x ($max_col-17-length_no_color($second_header));
  if (!($dg_col_pos  % 2)) {
    $tmp_header = $first_header;
    $first_header = $second_header;
    $second_header = $tmp_header; 
  }
  my $short_goto_search = substr($goto_search, 0, 16);
  if ($goto_search) {
    $first_header .= $vert_chr.colored($short_goto_search.(" " x (16-length_no_color($short_goto_search))), 'yellow');
    $second_header .= $vert_chr;
    print_search_header_msg($search_header_msg); 
  } else {
    $first_header .= " " x (18);
    $second_header .= " " x (18);
  }
  goto_xy(0,1);
  print $first_header;
  goto_xy(0,2);
  print $second_header;

  goto_xy(0,3);
  print "$low_line\n";
}

sub print_search_header_msg {
  $msg = shift;
  $search_header_msg = $msg;
  goto_xy($max_col-16,2);
  my $short_search_header_msg = substr($search_header_msg, 0, 16);
  print colored($search_header_msg.(" " x (16-length($short_search_header_msg))), 'red');
}

sub get_ip_name {
  my ($ip) = @_;
  if (exists($name_ip{$ip})) {
    return $name_ip{$ip};
  }

  if ($ip eq $asm_ip || $ip eq "127.0.0.1" || $ip eq "127.0.0.2") {
    $name_ip{$ip} = "SM";
    return $name_ip{$ip};
  }

  if ($ip eq $sm100_ip) {
    if ($sm100_ip eq "1.1.1.1") {
      $name_ip{$ip} = "Endpoint";
    } else {
      $name_ip{$ip} = "SM100";
    }
    return $name_ip{$ip};
  }

  if ($ip eq $asm_ipv6 || $ip eq "::1" || $ip eq "::2") {
    $name_ip{$ip} = "SMv6";
    return $name_ip{$ip};
  }

  if ($ip eq $sm100_ipv6) {
    $name_ip{$ip} = "SM100v6";
    return $name_ip{$ip};
  }

#  $host = substr($host_id,0,2*$dg_column_width-2);
 
  # Use the SIP Entity name instead of the IP
  if (exists($sipentity_ip{$ip})) {
    if (exists($sipentity{$sipentity_ip{$ip}}) && $sipentity{$sipentity_ip{$ip}} !~ /^id:/) {
      $name_ip{$ip} = $sipentity{$sipentity_ip{$ip}};
      return $name_ip{$ip};
    }
  }

  # Check the SIP Entity table in the DB
  my $sql;
  if ($psql_cmd eq "mgmtia") { # This is 7.1 where we start supporting IPv6
    $sql = "select name from sipentity where fqdnoripaddr='".$ip."' or fqdnoripaddr2='".$ip."';";
  } else { # Older version, only IPv4 is supported
    $sql = "select name from sipentity where fqdnoripaddr='".$ip."';";
  }
  $name = query_generic_database($sql);
  if ($name !~ /(\d+\.\d+\.\d+\.\d+|$IPv6_re)/ && $name ne "") {
    $name_ip{$ip} = $name;
  # Use the Local host name resolution
  } elsif (get_name("hostnameresolution",$ip) !~ /^id:/) {
    my $fqdn = get_name("hostnameresolution",$ip);
    my ($hostname) = ($fqdn =~ /^(.*?)\./);
    if (is_ipv4($ip)) { # IPv4
      my ($last_oct) = ($ip =~ /\d+\.\d+\.\d+\.(\d+)/);
      $name_ip{$ip} = "$hostname(.$last_oct)";
    } else { # IPv6
      my ($last_val) = ($ip =~ /:([^:]*)$/);
      $name_ip{$ip} = "$hostname(:$last_val)";
    }
  # Use the SIP Contact from SIP Endpoints
  } elsif (exists($contact_ip{$ip})) {
    $name_ip{$ip} = $contact_ip{$ip};
  } elsif ($name =~ /(\d+\.\d+\.\d+\.\d+|$IPv6_re)/) {
    $name_ip{$ip} = $name;
  } 

  if (exists($name_ip{$ip})) {
    return $name_ip{$ip};
  } else {
    return $ip
  }
}

sub change_status_bar_mode {
  my ($label,$color) = @_;
#printstack();
  $status_bar_mode = $label;
  $status_bar_mode_color = $color;
  refresh_footer(); 
}

sub change_status_bar_keys {
  my ($label) = @_;
  $status_bar_keys = $label;
  refresh_footer(); 
}

sub refresh_footer {
  goto_xy(0,$max_row);
  my $w = min(length($status_bar_mode),35);
  my $label = substr($status_bar_mode,0,$w);
  my $mode = $label;
  if ($mode eq "Capturing") {
    $label = " SIP  PPM  CallP TLS Push-Notification "; 
  } else {
    $label .= " " x ($w - length($label));
  }
  my $label_len = length($label) + 1;
  $w = min(length($status_bar_keys),$max_col-$label_len-3);
  my $status_bar_keys_tru = substr($status_bar_keys,0,$w);
  $label .= " | ";
  $label .= " " x (($max_col-length($status_bar_keys_tru)-length($label))/2);
  $label .= $status_bar_keys_tru;
  if (length($status_bar_keys_tru) < length($status_bar_keys)) {
    $label .= ">";
  } else {
    $label .= " " x ($max_col-length($label));
  }
  #print colored(substr($label,0,$label_len),$status_bar_mode_color).colored(substr($label,$label_len), 'reverse');
 
  if ($mode eq "Capturing") {
    my $color = "blue on_red";
    my $label_mode = "";
    $color = "black on_green" if is_asset_capture();
    $label_mode = colored(" SIP ",$color);

    $color = "blue on_red";
    $color = "black on_green" if is_ppm_capture();
    $label_mode .= colored(" PPM ",$color);

    $color = "blue on_red";
    $color = "black on_green" if is_sm_capture();
    $label_mode .= colored(" CallP ",$color);

    $color = "blue on_red";
    $color = "black on_green" if is_tls_capture();
    $label_mode .= colored(" TLS ",$color);

    $color = "blue on_red";
    $color = "black on_green" if is_push_notification_capture_started();
    $label_mode .= colored(" Push-Notification ",$color);

    print $label_mode; 
  } else { 
    print colored(substr($label,0,$label_len),$status_bar_mode_color);
  }
  print colored(substr($label,$label_len), 'reverse');
}

# We extended the "colored" function to include 256 colors.
# This is already supported in Perl 5.17.8, but SM
# is still not there (as of Sep 2014)
sub colored {
  my ($first, @rest) = @_;
  my ($string, @codes);

  # The TLS colors are from the 256 palette
  if ($rest[0] =~ /(tls\d+)/) {
    my $color = $1;
    if ($rest[0] =~ /reverse/) {
      return "\e[30;48;5;".$tls_colors{$color}."m".$first."\e[0m";
    } else {
      return "\e[38;5;".$tls_colors{$color}."m".$first."\e[0m";
    }
  } else {
    return Term::ANSIColor::colored($first, @rest);
  }
}

sub colored256 {
  my $string = shift;
  # "\e[48;5;${i}m  \e[0m"
  return "\e[48;5;197m".$string."\e[0m";
}

sub get_desc {
  my $params = shift;
  my %message = %$params;
  my $desc = "";

  if ($message{dropped_by} ne "") {
    my $dropped_by = $message{dropped_by};
    if ($dropped_by eq "AasSIPFW") {
      $dropped_by = "SIP FW";
    }
    $desc = "Dropped by: $dropped_by";
    if ($message{dropped_reason} ne "") {
      $desc .= ". Reason: $message{dropped_reason}";
    }
  } elsif ($message{type} eq "REQUEST") {
    $desc = $message{request_uri};
    if ($message{method} eq "INVITE" || $message{method} eq "REFER") {
      if ($message{sip} =~ /^(To|t): ("\w+"\s*)?<?sip:(.*)@.*>?/mi) {
        $desc = "T:".$3; 
      }
      if ($message{sip} =~ /^(From|f): (".*"\s*)?<?sip:(.*)(@|\.invalid).*>?/mi) {
        $desc .= " F:".$3; 
      }
      if ($message{sip} =~ /^INVITE sip:(.*)@.*/) {
        $desc .= " U:".$1;
      }

      # Get the 'phase' from the Route header
      if ($message{sip} =~ /^Route: .*phase=(\w+).*$/m) {
        $desc .= " P:$1";
      }

    } elsif ($message{method} =~ /NOTIFY|SUBSCRIBE|REGISTER/) {
      if ($message{sip} =~ /^(To|t): (.[^;\n]*)/m) {
        $desc = $2;
      }
      if ($message{sip} =~ /^Event: (.*)/mi) {
        $desc .= " Ev:".$1;
      }
      if ($message{sip} =~ /^Contact:.*expires=(\d+);.*/m || $message{sip} =~ /^Expires: (\d+)/m) {
        $desc .= " Exp:".$1;
      }
    } elsif ($message{method} eq "INFO") {
      # these are INFOs for interaction with AMS

      # Dialog start
      if ($message{sip} =~ /^<dialogstart name="([^"]+)".*target="([^"]+)"/m) {
        $ams_diag_ids{$1} = keys(%ams_diag_ids)+1 if !exists($ams_diag_ids{$1});
        $desc = "start diag:$ams_diag_ids{$1} ";
        if ($2 =~ /^conn:(.*)/) {
          $ams_ids{$1} = keys(%ams_ids)+1 if !exists($ams_ids{$1});
          $desc .= "ams_id:$ams_ids{$1} ";
        }
        # play an announcement
        #if ($message{sip} =~ /^<play /m && $message{sip} =~ /^<audio .*uri=".*\/([^"]*)"\//m) {
        if ($message{sip} =~ /^<play /m && ($message{sip} =~ /^<audio .*uri=".*\/([^\?]*)\?.*"\//m || $message{sip} =~ /^<audio .*uri=".*\/([^"]*)"\//m)) {
          $desc .= "play $1";
        }
        # capture DTMF
        if ($message{sip} =~ /^<dtmf /m) {
          $desc .= "dtmf pattern";
        }

      # Dialog end
      } elsif ($message{sip} =~ /^<dialogend id="([^"]+)"/m) {
        my $dialog_id = $1;
        $desc = "end ";
        if ($dialog_id =~ /dialog:([^\/]+)/) {
          $ams_diag_ids{$1} = keys(%ams_diag_ids)+1 if !exists($ams_diag_ids{$1});
          $desc .= "diag:$ams_diag_ids{$1} ";
        }
        if ($dialog_id =~ /conn:([^\/]+)/) {
          $ams_ids{$1} = keys(%ams_ids)+1 if !exists($ams_ids{$1});
          $desc .= "ams_id:$ams_ids{$1}";
        }

      # Events
      } elsif ($message{sip} =~ /^<event name="([^"]*)"/m) {
        $desc = "event $1";
        if ($message{sip} =~ /^<event name="[^"]*".* id="([^"]*)"/m || $message{sip} =~ /^id="([^"]*)"/m) {
          my $id = $1;
          if ($id =~ /dialog:([^\/]+)/) {
            $ams_diag_ids{$1} = keys(%ams_diag_ids)+1 if !exists($ams_diag_ids{$1});
            $desc .= " diag:$ams_diag_ids{$1}";
          }
          if ($id =~ /conn:([^\/]+)/) {
            $ams_ids{$1} = keys(%ams_ids)+1 if !exists($ams_ids{$1});
            $desc .= " ams_id:$ams_ids{$1}";
          }
        }
        $desc .= " ";
        while ($message{sip} =~ /<name>(.*)<\/name>\n<value>(.*)<\/value>/g) {
          $desc .= "$1=$2;";
        }
        $desc =~ s/;$//;

      # Create a conference
      } elsif ($message{sip} =~ /^<createconference /m) {
        $desc = "create conference";
        # Add the AMS conference ID
        if ($message{sip} =~ /^<audiomix id="([^"]+)/m) {
          $ams_conf_ids{$1} = keys(%ams_conf_ids)+1 if !exists($ams_conf_ids{$1});
          $desc .= " conf_id:$ams_conf_ids{$1}";
        }

      # Join/unjoin conf
      } elsif ($message{sip} =~ /^<((?:un)?join) id1="([^"]+)" id2="([^"]+)"/m) {
        my @ids=($2, $3);
        $desc = "$1";
        if ($message{sip} =~ /^<stream media="([^"]+)"/m) {
          $desc .= " $1";
        }
        foreach my $id (@ids) {
          if ($id =~ /^conn:(.*)/) {
            $ams_ids{$1} = keys(%ams_ids)+1 if !exists($ams_ids{$1});
            $desc .= " ams_id:$ams_ids{$1}";
          }
          if ($id =~ /^conf:(.*)/) {
            $ams_conf_ids{$1} = keys(%ams_conf_ids)+1 if !exists($ams_conf_ids{$1});
            $desc .= " conf_id:$ams_conf_ids{$1}";
          }
        }
      }
    } 
  } elsif ($message{type} eq "RESPONSE") {
    $desc = $message{response};
    if (($message{response} eq "200 OK") && ($message{sip} =~ /^Cseq:\s*\d+\s+(\S+)/mi)) {
      $desc = $desc." ($1)";
    } 

  } elsif ($message{type} eq "PINGPONG") {
    if ($message{method} eq "PING") {
      $desc = "PING from $message{host}";
    } else {
      $desc = "PONG to $message{host}";
    }
  } elsif ($message{type} eq "ERROR") {
    $desc = "Script error decoding packet.";
  } elsif ($message{type} eq "RTP") {
    $desc = "RTP $message{ep_1}:$message{port_1} <-$message{codec}-> $message{ep_2}:$message{port_2}";
  }
  # Add the AMS ID (x-nt-gslid)
  if ($desc !~ / ams_id:/ && $message{sip} =~ /^x-nt-gslid: (.*)$/m) {
    $ams_ids{$1} = keys(%ams_ids)+1 if !exists($ams_ids{$1});
    $desc .= " ams_id:$ams_ids{$1}";
  }
  $desc =~ s/[\r\n]//g;
  return $desc; 
}

sub get_label {
  my $params = shift;
  my %message = %$params;
  my $label = "";
  my $host;

  if ($message{type} eq "REQUEST") {
    $label = $message{method};
    if ($message{method} eq "INVITE") {
      $host = $message{host};
      my $invites = $calls{$message{call_id}}{invites}{$host};
      if ($invites == 0) {
        $calls{$message{call_id}}{invites}{$host}++;
      } else {
        if ($message{sip} =~ /^To: .*;tag=.*$/m) {
          $calls{$message{call_id}}{invites}{$host}++;
        }
      }
      if ($calls{$message{call_id}}{invites}{$host} > 1) {
        $label = "reINVITE";
      }
    }
  } elsif ($message{type} eq "RESPONSE") {
    if ($message{response} =~ /^\d+ (.*)/) {
      $label = $1;
      if ($label eq "OK") { $label = "200 OK"; };
    } else {
      $label = $message{response};
    }

  } elsif ($message{type} eq "PINGPONG") {
    $label = "$message{method}"

  } elsif ($message{type} eq "ERROR") {
    $label = "ERROR";

  } elsif ($message{type} eq "RTP") {
    $label = $message{codec};
  }
  return $label;
}

sub validate_cmd_line {
  my $pattern;
  my $regex;
  my $result;

  # Kill other running traceSM sessions
  if ($kill_others) {
    $pids = `pgrep traceSM`;
    for (split /\n/, $pids) {
      # Do not kill myself
      `kill -9 $_` if $_ != $$;
    }
  }

  # Check if there is another instance of traceSM running.
  if (!$multiple_instances && !$is_old_cygwin && !$is_new_cygwin && !$is_mac) {
    open(SELF,"<",$0) or die "Cannot open $0 - $!";
    flock(SELF, LOCK_EX|LOCK_NB) or die "ERROR: traceSM is already running. Only one instance is allowed.\n";
  }

  $result = validate_options($uri,$host_ip,$call_id,$header_value,$global_session_id,$contain_regex,$sip_retain);  
  die $result if $result; 

  # Change the SIP logrotate file to retain X number of tracer_asset.log 
  if ($sip_retain) {
    $result = `sed -i -e "/\\/var\\/log\\/Avaya\\/trace\\/tracer_asset.log {/,/}/s/rotate [0-9]\\+/rotate $sip_retain/" /etc/logrotate.d/assetLogRotate 2>&1`;
    chop($result);
    die "ERROR: Could not change the SIP logrotate file to change the number of files to retain:\n$result" if $result;
  }
}

sub validate_options {
  my ($uri,$host_ip,$call_id,$header_value,$global_session_id,$contain_regex,$sip_retain) = @_;
  if ($uri) {
    $pattern = $uri;
    $regexp = eval { qr/$pattern/ };
    return "The -u filter has an invalid regular expresion" if $@;
  }

  if ($host_ip) {
    $pattern = $host_ip;
    $regexp = eval { qr/$pattern/ };
    return "The -i filter has an invalid regular expresion" if $@;
  }

  if ($call_id) {
    $pattern = $call_id;
    $regexp = eval { qr/$pattern/ };
    return "The -c filter has an invalid regular expresion" if $@;
  }

  if ($global_session_id) {
    $pattern = $global_session_id;
    $regexp = eval { qr/$pattern/ };
    return "The -s filter has an invalid regular expresion" if $@;
  }

  if ($contain_regex) {
    $pattern = $contain_regex;
    $regexp = eval { qr/$pattern/ };
    return "The -o filter has an invalid regular expresion" if $@;
  }

  if ($header_value) {
    if ($header_value =~ /(.*?)=(.*)/) {
       $header = $1;
       $value = $2;
       $pattern = $value;
       $regexp = eval { qr/$pattern/ };
       return "The -g filter has an invalid <VALUE> as regular expresion" if $@;
       $pattern = $header;
       $regexp = eval { qr/$pattern/ };
       return "The -g filter has an invalid <HEA> as regular expresion" if $@;
    } else {
       return "The -g filter has an invalid format. It should be <HEA>=<VALUE>";
    }
  }

  if ($sip_retain) {
    return "The -sc parameter <NUM_FILES> should be an integer." unless $sip_retain =~ /^\d+$/; 
  }
 
  return;
} 

sub set_characterset {
  if ($no_unicode) {
    undef($unicode);
  } else {
    $unicode = 1;
  }

  if ($unicode) {
    # Change client Terminal (e.g. PuTTY) to Unicode/UTF-8 characterset
    @args_utf = ("echo", "-ne", "\e%G\e[?47h\e%G\e[?47l");
    #@args_utf = ("echo", "-ne", "\e%G\e[?47h\e%G\e[?47l\e[?7l");
    system(@args_utf);
    binmode STDOUT, ':utf8';

    $vert_chr = chr(9474);
    $single_line_chr = chr(9472);
    $line_chr = chr(9472);
    #$wide_line_chr = chr(9632);
    $wide_line_chr = chr(9552); # ==
    $left_arrow_chr = chr(9668);
    $right_arrow_chr = chr(9658);
    $vert_sep_l_chr = chr(9516);
    $vert_sep_h_chr = chr(9524);
    $vert_horiz = chr(9532);
    $hor_sep_l_chr = chr(9500);
    $hor_sep_r_chr = chr(9508);
    $corner_upper_left = chr(9484);
    $corner_upper_right = chr(9488);
    $corner_lower_left = chr(9492);
    $corner_lower_right = chr(9496);
    $thick_line_chr = chr(9632);

  } else {
    $vert_chr = "|";
    $line_chr = "-";
    $wide_line_chr = "=";
    $thick_line_chr = "=";
    $left_arrow_chr = "<";
    $right_arrow_chr = ">";
    $vert_sep_l_chr = "-";
    $vert_sep_h_chr = "-";
    $vert_horiz = "+";
    $hor_sep_l_chr = "|";
    $hor_sep_r_chr = "|";
    $corner_upper_left = "/";
    $corner_upper_right = "\\";
    $corner_lower_left = "\\";
    $corner_lower_right = "/";
  }
}

sub terminal_resize {
  $prev_screen_col = $max_col;
  get_screen_size();
  set_scroll_region($dg_top_margin, $max_row - 2);

  # reposition the column position
  my $dg_column_no = keys(%dg_columns);
  my $max_col_screen = int(($max_col-12-25) / $dg_column_width);
  $dg_col_pos = max(1,min($dg_col_pos,$dg_column_no - $max_col_screen));

  # reposition the top cursor position (diagram) 
  my $dg_record_no = scalar (@display_dg_records);
  my $dis_rec = min($max_row-$dg_top_margin-2,$dg_record_no);
  if ($dg_rec_pos-$dg_top_pos > $dis_rec) {
    $dg_top_pos = $dg_rec_pos-$dis_rec; 
  }

  # reposition the top cursor position (call_summary)
  my $cl_record_no = keys(%call_summary);
  my $dis_rec = min($max_row-5,$cl_record_no);
  if ($cl_rec_pos-$cl_top_pos > $dis_rec) {
    $cl_top_pos = $cl_rec_pos-$dis_rec;
  }

  if ($display_mode eq "call summary") {
    clear_screen();
    cl_refresh_header();
    cl_paint_all();
    refresh_footer();
  } else {
    $display_mode = "diagram";
    $prev_display_mode = "diagram";
    change_mode($capture_mode,$display_mode);
    dg_paint_all();
  }
}

sub get_screen_size {
  $max_row = 0;
  $max_col = 0;
  
  if ($is_mac or $is_new_cygwin) {
    $max_row = `tput lines`;
    chop($max_row);
    $max_col = `tput cols`;
    chop($max_col);
  } else { 
    return unless defined &TIOCGWINSZ;
    open(TTY, "+</dev/tty") or return;
    unless (ioctl(TTY, &TIOCGWINSZ, $winsize='x'x16)) {
      die sprintf "$0: ioctl TIOCGWINSZ (%08x: $!)\n", &TIOCGWINSZ;
    }
    ($max_row, $max_col, $xpixel, $ypixel) = unpack('S4', $winsize);
  }

  # When connecting thru XEN with "xm console sm", the size come 0,0
  if ($max_row == 0 && $max_col == 0) {
    $max_row = 24;
    $max_col = 80;
  }

  if (($max_row < $min_row) || ($max_col < $min_col)) {
    $need_resize = 1;
  } else {
    $need_resize = 0;
  }
}

sub create_color_table {
  @colors = ("red", "green", "yellow", "magenta", "cyan", "bold red", "bold green", "bold yellow", "bold blue", "bold magenta", "bold cyan");

  %tls_colors = (
    'tls0' => "199",
    'tls1' => "45",
    'tls2' => "82",
    'tls3' => "209",
    'tls4' => "185",
    'tls5' => "118",
    'tls6' => "252",
  );
}

sub init_screen {
  $| = 1;
  $delay = (shift() || 0) * 0.005;
  my $termios = POSIX::Termios->new();
  $termios->getattr;
  my $ospeed = $termios->getospeed;
  if ($is_old_cygwin or $is_new_cygwin) {
    # running under cygwin
    $tcap = Term::Cap->Tgetent ({ TERM => cygwin, OSPEED => $ospeed });
    $tcap->Trequire(qw(cl cm cd sf so se));
  } else {
    # running under linux
    $tcap = Term::Cap->Tgetent ({ TERM => linux, OSPEED => $ospeed });
    $tcap->Trequire(qw(cl cm cd sf cs so se vi));
  }

  $support_title = `tty | grep -c -v tty`;chop($support_title);

  get_screen_size();

  set_scroll_region($dg_top_margin, $max_row - 2);

  set_keyboard(1);

  cursor_visible(0); 
}

sub start_audit {
    if (!$is_mac) {
      # Audit log file
      open(AUDIT,'>>', "$trace_dir$audit_log_file");
      chmod 0666, "$trace_dir$audit_log_file";
      AUDIT->autoflush(1);
      audit("================ traceSM open ================");
      audit("Running with arguments: $all_command_args");
    }
}

sub end_screen {
  set_keyboard(0); 
  set_scroll_region(0, $max_row);
  cursor_visible(1);
  clear_screen(); 
}

sub set_scroll_region {
  my($start_row, $end_row) = @_;
  # set the scroll area
  $tcap->Tgoto('cs', $end_row, $start_row, *STDOUT);
  goto_xy(0,$end_row);
}

sub goto_xy {
  my($x, $y) = @_;
  $tcap->Tgoto('cm', $x, $y, *STDOUT);
}

sub set_keyboard {
  my ($flag) = @_;
  if ($flag) {
    system "stty cbreak </dev/tty >/dev/tty 2>&1";
    system "stty -echo </dev/tty >/dev/tty 2>&1";
  } else {
    system "stty -cbreak </dev/tty >/dev/tty 2>&1";
    system "stty echo </dev/tty >/dev/tty 2>&1";
  }
}

sub keyboard_loop {
  my $key;
  my $dg_record_no;
  my $dg_column_no;
  my $max_col_screen;
  my $fn_key = 0;
  $display_mode = "diagram";
  $prev_display_mode = "diagram";

  set_characterset();
  while(1){
    $new_key = getc(STDIN);
    if ($fn_key) {
      $key .= $new_key;
    } else {
      $key = $new_key;
    }
    # The arrow keys are actually a sequence of three keys.
    # For example the up arrow is ESC [ A
    if ($key eq "\e" || $key eq "\e[") {
      $fn_key = 1;
      next;
    }
    $fn_key = 0;
    $dg_record_no = scalar (@display_dg_records);
    $cl_record_no = keys(%call_summary);
    $dg_column_no = keys(%dg_columns);
    $max_col_screen = int(($max_col-12-25) / $dg_column_width);
    if ($display_mode ne "call summary") {
      $display_mode = "diagram";
    }

    # The UP/DOWN keys have two functions:
    #    1-Scroll between the messages
    #    2-When displaying the message details, scroll a message
    #      when it doesn't fit in the screen
    # UP
    if ($key eq "\e[A") {
      if ($prev_display_mode eq "details" && $display_dg_records[$dg_rec_pos-1]{type} eq "PPM" && $ppm_lines > $detail_box_h-2) {
        $ppm_start_line = max($ppm_start_line-1,0);
        $display_mode = "details";
        display_ppm_details_box($detail_box_w,$detail_box_h);
      } elsif ($prev_display_mode eq "details" && $display_dg_records[$dg_rec_pos-1]{type} eq "TLS" && $tls_lines > $detail_box_h-2) {
        $tls_start_line = max($tls_start_line-1,0);
        $display_mode = "details";
        display_tls_details_box($detail_box_w,$detail_box_h);
      } elsif ($prev_display_mode eq "details" && $display_dg_records[$dg_rec_pos-1]{type} !~ "INFO|PPM|RTP|TLS" && $sip_lines > $detail_box_h-2) {
        $sip_start_line = max($sip_start_line-1,0);
        $display_mode = "details";
        display_sip_details_box($detail_box_w,$detail_box_h);
      } elsif ($prev_display_mode eq "details" && $display_dg_records[$dg_rec_pos-1]{type} !~ "PUSH_NOTIFICATION_REQ|PUSH_NOTIFICATION_RESP" && $push_lines > $detail_box_h-2) {
        # DETAIL PUSH
        $push_start_line = max($push_start_line-1,0);
        $display_mode = "details";
        display_push_notification_details_box($detail_box_w,$detail_box_h);
      } elsif ($display_mode eq "call summary") {
        lock($cl_top_pos);lock($cl_rec_pos);
        $cl_rec_pos = max($cl_rec_pos-1,0);
        if ($cl_rec_pos < $cl_top_pos) {
          $cl_top_pos--;
        }

      } else {
        $dg_rec_pos = max($dg_rec_pos-1,1);
        dg_paint_all() if ($is_old_cygwin or $is_new_cygwin);
      }

    # DOWN
    } elsif ($key eq "\e[B") {
      if ($prev_display_mode eq "details" && $display_dg_records[$dg_rec_pos-1]{type} eq "PPM" && $ppm_lines > $detail_box_h-2) {
        $ppm_start_line = min($ppm_start_line+1,$ppm_lines-$detail_box_h+2);
        $display_mode = "details";
        display_ppm_details_box($detail_box_w,$detail_box_h);
      } elsif ($prev_display_mode eq "details" && $display_dg_records[$dg_rec_pos-1]{type} eq "TLS" && $tls_lines > $detail_box_h-2) {
        $tls_start_line = min($tls_start_line+1,$tls_lines-$detail_box_h+2);
        $display_mode = "details";
        display_tls_details_box($detail_box_w,$detail_box_h);
      } elsif ($prev_display_mode eq "details" && $display_dg_records[$dg_rec_pos-1]{type} !~ "INFO|PPM|RTP|TLS" && $sip_lines > $detail_box_h-(($display_dg_records[$dg_rec_pos-1]{dropped_by} ne "")?5:2)) {
        $sip_start_line = min($sip_start_line+1,$sip_lines-$detail_box_h+(($display_dg_records[$dg_rec_pos-1]{dropped_by} ne "")?5:2));
        $display_mode = "details";
        display_sip_details_box($detail_box_w,$detail_box_h);
      } elsif ($prev_display_mode eq "details" && $display_dg_records[$dg_rec_pos-1]{type} !~ "PUSH_NOTIFICATION_REQ|PUSH_NOTIFICATION_RESP" && $push_lines > $detail_box_h-2) {
        $push_start_line = min($push_start_line+1,$push_lines-$detail_box_h+2);
        $display_mode = "details";
        display_push_notification_details_box($detail_box_w,$detail_box_h);
      } elsif ($display_mode eq "call summary") {
        lock($cl_top_pos);lock($cl_rec_pos);
        $cl_rec_pos = min($cl_rec_pos+1,$cl_record_no-1);
        if ($cl_rec_pos > $cl_top_pos+$max_row-5) {
          $cl_top_pos++;
        }
      } else {
        $dg_rec_pos = min($dg_rec_pos+1,$dg_record_no);
        dg_paint_all() if ($is_old_cygwin or $is_new_cygwin);
      }

    # RIGHT
    } elsif ($key eq "\e[C") {
      if ($display_mode eq "call summary") {
        if (!$cl_view) {
          change_cl_view(1);
          clear_screen();
          cl_refresh_header();
          cl_paint_all();
          change_mode($capture_mode,$display_mode);
        }
      } else {
        $dg_col_pos = max(1,min($dg_col_pos+1,$dg_column_no - $max_col_screen));
      }
    
    # LEFT
    } elsif ($key eq "\e[D") {
      if ($display_mode eq "call summary") {
        if ($cl_view) {
          change_cl_view(0);
          clear_screen();
          cl_refresh_header();
          cl_paint_all();
          change_mode($capture_mode,$display_mode);
        }
      } else {
        $dg_col_pos = max(1,$dg_col_pos-1);
      }
    
    # ENTER or Space bar to View Details
    } elsif ($key eq "\n" || $key eq " ") {
      if ($display_mode eq "call summary") {
        filter_call_summary(1); 
      } else {
        view_details();
      }
    
    # PAGE DOWN
    } elsif ($key eq "\e[6") {
      if ($display_mode eq "call summary") {
        lock($cl_top_pos);lock($cl_rec_pos);
        $cl_rec_pos = min($cl_rec_pos+$max_row-5, $cl_record_no-1);
        $cl_top_pos = max($cl_rec_pos-($max_row-5),0);
      } else {
        $dg_rec_pos = min($dg_rec_pos+$max_row-$dg_top_margin-2,$dg_record_no);
      }
 
    # PAGE UP
    } elsif ($key eq "\e[5") {
      if ($display_mode eq "call summary") {
        lock($cl_top_pos);lock($cl_rec_pos);
        $cl_rec_pos = max($cl_rec_pos-($max_row-5),0);
        $cl_top_pos = $cl_rec_pos;
      } else {
        $dg_rec_pos = max($dg_rec_pos-($max_row-$dg_top_margin-2),1);
      }
 
    # END
    } elsif ($key eq "\e[4" || $key eq "\e[F") {
      if ($display_mode eq "call summary") {
        lock($cl_top_pos);lock($cl_rec_pos);
        $cl_rec_pos = $cl_record_no-1;
        $cl_top_pos = max($cl_rec_pos-($max_row-5),0);
      } else {
        $dg_rec_pos = $dg_record_no;
      }
    
    # HOME
    } elsif ($key eq "\e[1" || $key eq "\e[H") {
      if ($display_mode eq "call summary") {
        lock($cl_top_pos);lock($cl_rec_pos);
        $cl_rec_pos = 0;
        $cl_top_pos = 0;
      } else {
        $dg_rec_pos = 1;
      }
 
    # START or STOP
    } elsif (lc($key) eq "s") {
      start_stop_capture();
 
    # FILTER
    } elsif (lc($key) eq "f") {
      filter();
    
    # WRITE MESSAGES TO A FILE
    } elsif (lc($key) eq "w") {
      write_to_file();

    # ASSET 
    } elsif (lc($key) eq "a") {
      toggle_show_asm();

    # RTP 
    } elsif (lc($key) eq "r") {
      toggle_rtp();

    # GOTO A SPECIFIC RECORD
    } elsif (lc($key) eq "g" || lc($key) eq "/") {
      goto_record();

    # NEXT RECORD
    } elsif (lc($key) eq "n") {
      dg_paint_all() if dg_init_positions("next");

    # PREVIOUS RECORD
    } elsif (lc($key) eq "p") {
      dg_paint_all() if dg_init_positions("previous");

    # CLEAR 
    } elsif (lc($key) eq "c") {
      clear_capture();

    # IP or NAMES 
    } elsif (lc($key) eq "i") {
      toggle_name_ip();

    # CALL SUMMARY or DIAGRAM
    } elsif (lc($key) eq "d") {
      toggle_call_diagram();

    # FULL SCREEN DETAILS
    } elsif (lc($key) eq "u") {
      toggle_full_screen();

    # QUIT
    } elsif (lc($key) eq "q") {
      quit_program();
    }
    refresh();
    $prev_display_mode = $display_mode;
  }
}

sub refresh {
  return if $processing_initial_queue;
  if ($display_mode eq "call summary") {
    cl_refresh();
  } else {
    dg_refresh();
  }
}

sub cl_refresh {
  lock($cl_top_pos);lock($cl_rec_pos);
  if ($cl_rec_pos != $prev_cl_rec_pos) {
    cl_paint_all();
  }
  $prev_cl_rec_pos = $cl_rec_pos;
}

sub dg_refresh {
  my $index;
  lock(@dg_records);
  lock(@display_dg_records);
  lock(%calls);
  lock(%sessions);

  my $dg_record_no = scalar (@display_dg_records);
  my $dg_column_no = keys(%dg_columns);
  my $max_col_screen = int(($max_col-12-25) / $dg_column_width);
  return if !$dg_record_no or $display_mode ne "diagram";
  if ($need_resize) {
    display_message();
    return;
  }
  if ($display_mode eq "diagram" && $prev_display_mode ne "diagram") {
    change_mode($capture_mode,$display_mode);
    dg_paint_all();
  } elsif (($prev_dg_column_no != $dg_column_no) && ($dg_column_no >= $dg_col_pos && $dg_column_no <= $dg_col_pos + $max_col_screen) ){
      dg_paint_all();
  } elsif ($prev_dg_rec_pos < $dg_rec_pos) {
    my $rel_pos = $max_row-$dg_top_margin-1+$dg_top_pos;
    if ($dg_rec_pos < $rel_pos) {
      dg_display_line($dg_top_margin+$prev_dg_rec_pos-$dg_top_pos, 0, $prev_dg_rec_pos);
      dg_display_line($dg_top_margin+$dg_rec_pos-$dg_top_pos, 1, $dg_rec_pos);
    } elsif (($dg_rec_pos - $rel_pos) < 10) {
      dg_display_line($dg_top_margin+$prev_dg_rec_pos-$dg_top_pos, 0, $prev_dg_rec_pos);
      for $i ( 0 .. ($dg_rec_pos - $rel_pos)) {
        scroll_up($max_row-2);
        $dg_top_pos++;
        dg_display_line($dg_top_margin+$rel_pos-$dg_top_pos+$i, (($dg_rec_pos - $rel_pos)-$i)?0:1, $rel_pos+$i);
      }
    } else {
      $dg_top_pos = max($dg_rec_pos-($max_row-$dg_top_margin-2),1);
      dg_paint_all();
    }
  } elsif ($prev_dg_rec_pos > $dg_rec_pos) {
    if ($dg_rec_pos >= $dg_top_pos) {
      dg_display_line($dg_top_margin+$prev_dg_rec_pos-$dg_top_pos, 0, $prev_dg_rec_pos);
      dg_display_line($dg_top_margin+$dg_rec_pos-$dg_top_pos, 1, $dg_rec_pos);
    } elsif (($dg_top_pos - $dg_rec_pos - 1) < 10) {
      dg_display_line($dg_top_margin+$prev_dg_rec_pos-$dg_top_pos, 0, $prev_dg_rec_pos);
      for $i ( 0 .. ($dg_top_pos - $dg_rec_pos - 1)) {
        scroll_down($dg_top_margin);
        $dg_top_pos--;
        dg_display_line($dg_top_margin+0, ($dg_top_pos - $dg_rec_pos)?0:1, $dg_top_pos);
      }
    } else {
      $dg_top_pos = $dg_rec_pos;
      dg_paint_all();
    }
  } elsif ($prev_dg_col_pos != $dg_col_pos) {
    dg_paint_all();
  } elsif ( ($prev_dg_record_no != $dg_record_no) && ($max_row-$dg_top_margin-1+$dg_top_pos > $dg_record_no) ) {
    dg_display_line($dg_top_margin+$dg_record_no-1, 0, $dg_record_no);
  }

  $prev_dg_rec_pos = $dg_rec_pos;
  $prev_dg_col_pos = $dg_col_pos;
  $prev_dg_top_pos = $dg_top_pos;
  $prev_dg_column_no = $dg_column_no;
  $prev_dg_record_no = $dg_record_no;
}

sub dg_paint_all {
  my $dg_record_no = scalar (@display_dg_records);
  if (!$dg_record_no || $need_resize) { 
    display_message();
    #refresh_footer();
    return;   
  }
  my $dis_rec = min($max_row-$dg_top_margin-2,$dg_record_no-$dg_top_pos);
  if ($dg_rec_pos < $dg_top_pos) { $dg_top_pos = $dg_rec_pos; };
  if ($dg_rec_pos > $dg_top_pos + $dis_rec) { $dg_top_pos = min($dg_rec_pos-($max_row-$dg_top_margin-2),$dg_record_no); };
  my $index;
  dg_refresh_header();
  for $i ( 0 .. $dis_rec ) {
    $index = $i + $dg_top_pos;
    if ($index == $dg_rec_pos) {
      dg_display_line($dg_top_margin+$i, 1, $index);
    } else {
      dg_display_line($dg_top_margin+$i, 0, $index);
    }
  }

  # If there are less records than lines in the screen, clean the rest of the screen
  clear_end();

  refresh_footer();
}

sub dg_display_line {
  my ($y, $reverse, $index) = @_;
#if ($index < 0) {
#  print TMP "INDEX: $index\n";
#  printstack();
#  exit;  
#}
  my $line;
#print TMP "display_dg_records: ".scalar(@display_dg_records)."\n";
#printstack();
  if (!($throttle)) {
    # Pause for 0.0001 seconds to avoid high CPU usage
    select(undef, undef, undef, 0.0001);
  }

  goto_xy(0,$y);
#print TMP "reverse: $reverse index: $index\n";
  if ($reverse) {
    $line = generate_dg_line($display_dg_records[$index-1],"reverse");
  } else {
    $line = generate_dg_line($display_dg_records[$index-1],"");
  }
  print $line;
  if ($y >= $max_row) { 
#    print TMP "PRINTING OUTSIDE MR:$max_row Y:$y RP:$dg_rec_pos INDEX:$index\n";
  }
}

sub cursor_visible {
  my($visible) = @_;
  if ($visible) {
    $tcap->Tputs('ve', 1, *STDOUT);
  } else {
    $tcap->Tputs('vi', 1, *STDOUT);
  }
}

sub scroll_up {
  my($y) = @_;
  goto_xy(0, $y);
  $tcap->Tputs('sf', 1, *STDOUT);
}

sub scroll_down {
  my($y) = @_;
  goto_xy(0, $y);
  $tcap->Tputs('sr', 1, *STDOUT);
}

sub clear_screen {
  $tcap->Tputs('cl', 1, *STDOUT); 
}

sub clear_end {
  $tcap->Tputs('cd', 1, *STDOUT)
}

sub view_details {
  return if !scalar(@display_dg_records);
  if ($prev_display_mode eq "details") {
    $display_mode = "diagram";
    change_mode($capture_mode,$display_mode);
  } else {
    $display_mode = "details";
    change_mode($capture_mode,$display_mode);
    $sip_start_line = 0;
    $ppm_start_line = 0;
    $tls_start_line = 0;
    $push_start_line = 0;
    my $w,$h;
    if ($full_screen_details) {
      $w = $max_col;
      $h = $max_row-3;
    } else {
      $w = min(160,$max_col-10);
      $h = min(50,$max_row-$dg_top_margin-3);
    }

    if ($display_dg_records[$dg_rec_pos-1]{type} eq "INFO") {
      $h = min($h, get_dg_display_lines($w,$display_dg_records[$dg_rec_pos-1]{msg}));
      create_box($w,$h);
      display_asm_details_box($w,$h);
    } elsif ($display_dg_records[$dg_rec_pos-1]{type} eq "RTP") {
      my $label = get_desc($display_dg_records[$dg_rec_pos-1]);
      $detail_box_w = $w;
      $detail_box_w = min($w, length($label)+2) if !$full_screen_details;
      $detail_box_h = 3;
      create_box($detail_box_w,$detail_box_h); 
      display_rtp_details_box($detail_box_w,$detail_box_h,$label);
    } elsif ($display_dg_records[$dg_rec_pos-1]{type} eq "PPM") {
      $ppm_lines = get_dg_display_lines($w,$display_dg_records[$dg_rec_pos-1]{msg});
      $detail_box_h = min($h, $ppm_lines+2);
      $detail_box_w = $w;
      create_box($detail_box_w,$detail_box_h,1);
      display_ppm_details_box($detail_box_w,$detail_box_h);
    } elsif ($display_dg_records[$dg_rec_pos-1]{type} eq "TLS") {
      $tls_lines = get_dg_display_lines($w,$display_dg_records[$dg_rec_pos-1]{msg});
      $detail_box_h = min($h, $tls_lines+2);
      $detail_box_w = $w;
      create_box($detail_box_w,$detail_box_h,1);
      display_tls_details_box($detail_box_w,$detail_box_h);
    } elsif($display_dg_records[$dg_rec_pos-1]{type} eq "PUSH_NOTIFICATION_RESP" || $display_dg_records[$dg_rec_pos-1]{type} eq "PUSH_NOTIFICATION_REQ") { # PUSH
      $push_lines = get_dg_display_lines($w,$display_dg_records[$dg_rec_pos-1]{message});
      $extra_lines = 2;
      $detail_box_h = min($h, $push_lines+$extra_lines);
      $detail_box_w = $w;
      create_box($detail_box_w,$detail_box_h,($extra_lines==5)?2:1);
      display_push_notification_details_box($detail_box_w,$detail_box_h);
    } else { # SIP
      $sip_lines = get_dg_display_lines($w,$display_dg_records[$dg_rec_pos-1]{sip});
      $extra_lines = 2;
      $extra_lines += 3 if $display_dg_records[$dg_rec_pos-1]{dropped_by} ne "";
      $detail_box_h = min($h, $sip_lines+$extra_lines);
      $detail_box_w = $w;
      create_box($detail_box_w,$detail_box_h,($extra_lines==5)?2:1);
      display_sip_details_box($detail_box_w,$detail_box_h);
    }
  }
}

sub create_box {
  my ($w,$h,$header) = @_;
  
  my $top_border;
  my $bottom_border;
  my $margin = $dg_top_margin;

  if ($display_mode eq "details" && $full_screen_details) {
    $header_sep = $line_chr x $w;
    $top_border = $line_chr x $w;
    $bottom_border = $line_chr x $w;
    $header_sep = $line_chr x $w;
    $margin = 0;
  } else {
    $top_border = $corner_upper_left.($line_chr x $w).$corner_upper_right;
    $bottom_border = $corner_lower_left.($line_chr x $w).$corner_lower_right;
    $header_sep = $hor_sep_l_chr.($line_chr x $w).$hor_sep_r_chr;
  }
  goto_xy(($max_col - $w-2)/2, $margin + ($max_row-$margin-1 - $h-2)/2);
  print $top_border;
  for $i ( 1 .. $h ) {
    goto_xy(($max_col - $w-2)/2, $margin + ($max_row-$margin-1 - $h-2)/2 + $i);
    if ($header && $i==2) {
      print $header_sep;
    } elsif ($header ==2 && $i==5) {
      print $header_sep;
    } else {
      if ($display_mode eq "details" && $full_screen_details) {
        print " "x$w;
      } else {
        print $vert_chr.(" "x$w).$vert_chr;
      }
    }
  }
  goto_xy(($max_col - $w-2)/2, $margin + ($max_row-$margin-1 - $h-2)/2 + $h+2 - 1);
  print $bottom_border;
}

sub display_rtp_details_box {
  my ($w,$h,$msg) = @_;
  my $margin = $dg_top_margin;

  $margin = 0 if $full_screen_details;

  goto_xy(1 + ($max_col - $w)/2, 1 + $margin + ($max_row-$margin-1 - $h)/2);
  print $msg;
}

sub display_asm_details_box {
  my ($w,$h) = @_;
  my $pas;
  my $msg = $display_dg_records[$dg_rec_pos-1]{msg};
  my @lines = split("\n",$msg);
  my $i = 0;
  my $margin = $dg_top_margin;

  $margin = 0 if $full_screen_details;

  foreach my $line (@lines) {
    $pas = int(length($line)/$w);
    my $counter = 1;
    for $j (0 .. $pas) {
      goto_xy(($max_col - $w)/2, $margin + ($max_row-$margin-1 - $h)/2 + $i);
      $i++;
      if ($i > $h) {
        goto_xy(($max_col - $w)/2, $margin + ($max_row-$margin-1 - $h)/2 + $i-2);
        print " " x (($w-3)/2) . "..." . " " x (($w-2)/2);
        last;
      } else {
        my $l = substr($line,$w*$j,$w);
        my %quote_pos;
        while ($l =~ m/'/g) {
           $quote_pos{(pos($l)-1)} = "";
        }
        my $colored_line = "";
        my @parts = split(/'/,$l);
        my $count = () = $l =~ /'/g;
       
        #print TMP "NUM: ".(@parts)."  QUOTES: $count\n";
        foreach $part (@parts) {
          my $non_colored_line = $colored_line;
          $non_colored_line =~ s/\e\[.*?m//g;
          if (exists($quote_pos{length($non_colored_line)})) {
            $colored_line .= "'";
          }
          if ($counter % 2) { 
            $colored_line .= $part;
          } else {
            $colored_line .= colored($part,'bold red');
          }
          $counter++;
        }
        my $non_colored_line = $colored_line;
        $non_colored_line =~ s/\e\[.*?m//g;
        if (exists($quote_pos{length($non_colored_line)})) {
          $colored_line .= "'";
        }
        $counter = $counter - (@parts) + $count;
        print $colored_line;
      }
    }
    $l_c++;
    last if $i > $h;
  }
}

sub display_sip_details_box {
  my ($w,$h) = @_;
  my $pas;
  my @lines = split("\n",$display_dg_records[$dg_rec_pos-1]{sip});
  my $content_pos = 0;
  my $i = 0;
  my $first_line = 1;
  my $extra_lines = 2;
  my $margin = $dg_top_margin;

  $margin = 0 if $full_screen_details;

  # Add the transport top line
  goto_xy(($max_col - $w)/2, $margin + ($max_row-$margin-1 - $h)/2 + 0);
  my $remote_ip = $display_dg_records[$dg_rec_pos-1]{host};
  my $remote = (is_ipv4($remote_ip) ? "" : "[").$remote_ip.(is_ipv4($remote_ip) ? "" : "]").":".$display_dg_records[$dg_rec_pos-1]{port};
  my $local_ip = $display_dg_records[$dg_rec_pos-1]{local_host};
  my $local = (is_ipv4($local_ip) ? "" : "[").$local_ip.(is_ipv4($local_ip) ? "" : "]").":".$display_dg_records[$dg_rec_pos-1]{local_port};
  my $src="",$dst="";
  if ($display_dg_records[$dg_rec_pos-1]{send_receive} eq "Incoming") {
    $src = $remote." ";
    $dst .= " ".$local;
  } else {
    $src = $local." ";
    $dst .= " ".$remote;
  }
  $src = sprintf('%*.*s', int(($w-9)/2), int(($w-9)/2), $src);
  $dst = sprintf('%-*.*s', int(($w-9)/2), int(($w-9)/2), $dst);

  print $src.$line_chr.$line_chr.$display_dg_records[$dg_rec_pos-1]{protocol}.$line_chr.$right_arrow_chr.$dst;

  # Add DROPPED by lines (if needed)
  if ($display_dg_records[$dg_rec_pos-1]{dropped_by} ne "") {
    $extra_lines += 3;
    goto_xy(($max_col - $w)/2, $margin + ($max_row-$margin-1 - $h)/2 + 2);
    my $first_line = sprintf("%-".$w."s",substr("Dropped by: ".$display_dg_records[$dg_rec_pos-1]{dropped_by},0,$w));
    print colored($first_line,"red reverse");
    goto_xy(($max_col - $w)/2, $margin + ($max_row-$margin-1 - $h)/2 + 3);
    my $second_line = sprintf("%-".$w."s",substr("Reason: ".$display_dg_records[$dg_rec_pos-1]{dropped_reason},0,$w));
    print colored($second_line,"red reverse");
  }

  # Add the SIP message details
  foreach my $line (@lines) {
    $line =~ s/\n//g;
    if (length($line) == 0) {$content_pos = 1;};
    $line =~ s/\r//g;
    $pas = int(length($line)/$w);
    for $j (0 .. $pas) {
      goto_xy(($max_col - $w)/2, $margin + ($max_row-$margin-1 - $h)/2 + $extra_lines + $i - $sip_start_line);
      $i++;
      if ($sip_start_line+1 <= $i) {
        if ($i-$sip_start_line > $h-$extra_lines) {
          goto_xy(($max_col - $w)/2, $margin + ($max_row-$margin-1 - $h)/2 + $extra_lines + $i-2 - $sip_start_line);
          print " " x (($w-3)/2) . "..." . " " x (($w-2)/2);
          last;
        } else {
          my $l = substr($line,$w*$j,$w);
          $l =~ s/\t/     /g;
          $l .= " " x ($w-length($l));
          if ($content_pos) {
            $l = colored($l,'bold green');
          } else {
            if ($first_line) {
              $l = colored($l,'red');
            } else {
              if ($j==0) {
                $l =~ s/^(.[^=]*?:)(.*$)/colored($1,'bold blue').$2/e;
              }
            }
          }
          print $l;
        }
      }
    }
    last if $i-$sip_start_line > $h-$extra_lines;
    $first_line = 0;
  }
}

sub display_ppm_details_box {
  my ($w,$h) = @_;
  my $pas;
  my @lines = split("\n",$display_dg_records[$dg_rec_pos-1]{msg});
  my $i = 0;
  my $margin = $dg_top_margin;

  $margin = 0 if $full_screen_details;

  # Add the transport top line
  goto_xy(($max_col - $w)/2, $margin + ($max_row-$margin-1 - $h)/2 + 0);
  my $remote = $display_dg_records[$dg_rec_pos-1]{host};
  my $local;
  if (is_ipv4($remote)) {
    $local = $sm100_ip;
  } else {
    $local = $sm100_ipv6;
  }
  $local = "SM100" if $local eq "";
  my $src="",$dst="";
  if ($display_dg_records[$dg_rec_pos-1]{send_receive} eq "Incoming") {
    $src = $remote." ";
    $dst .= " ".$local;
  } else {
    $src = $local." ";
    $dst .= " ".$remote;
  }
  $src = sprintf('%*.*s', int(($w-9)/2), int(($w-9)/2), $src);
  $dst = sprintf('%-*.*s', int(($w-9)/2), int(($w-9)/2), $dst);

  print $src.$line_chr.$line_chr.$line_chr.$right_arrow_chr.$dst;

  # Add the PPM message details
  foreach my $line (@lines) {
    $line =~ s/\r//g;
    #next if $line =~ /^\s*$/;
    $pas = int(length($line)/$w);
    for $j (0 .. $pas) {
      goto_xy(($max_col - $w)/2, $margin + ($max_row-$margin-1 - $h)/2 + 2 + $i - $ppm_start_line);
      $i++;
      if ($ppm_start_line+1 <= $i) {
        if ($i-$ppm_start_line > $h-2) {
          goto_xy(($max_col - $w)/2, $margin + ($max_row-$margin-1 - $h)/2 + 2 + $i-2 - $ppm_start_line);
          print " " x (($w-3)/2) . "..." . " " x (($w-2)/2);
          last;
        } else {
          my $l = substr($line,$w*$j,$w);
          $l =~ s/\t/     /g;
          $l .= " " x ($w-length($l));
          #$l =~ s/^(.[^=]*?:)(.*$)/colored($1,'bold blue').$2/e;
          $l = colored($l,'bold green');
          $l =~ s/^(.*>)(.*)(<\/.*)/colored($1,'bold green').colored($2,'bold red').colored($3,'bold green')/e; 
          #$l = colored($l,'bold green');
          print $l;
        }
      }
    }
    last if $i-$ppm_start_line > $h-2;
  }
}

sub display_tls_details_box {
  my ($w,$h) = @_;
  my $pas;
  my @lines = split("\n",$display_dg_records[$dg_rec_pos-1]{msg});
  my $i = 0;
  my $margin = $dg_top_margin;

  $margin = 0 if $full_screen_details;

  # Add the transport top line
  goto_xy(($max_col - $w)/2, $margin + ($max_row-$margin-1 - $h)/2 + 0);
  my $remote_ip = $display_dg_records[$dg_rec_pos-1]{host};
  my $remote = (is_ipv4($remote_ip) ? "" : "[").$remote_ip.(is_ipv4($remote_ip) ? "" : "]").":".$display_dg_records[$dg_rec_pos-1]{port};
  my $local_ip = $display_dg_records[$dg_rec_pos-1]{local_host};
  my $local = (is_ipv4($local_ip) ? "" : "[").$local_ip.(is_ipv4($local_ip) ? "" : "]").":".$display_dg_records[$dg_rec_pos-1]{local_port};
  my $src="",$dst="";
  if ($display_dg_records[$dg_rec_pos-1]{send_receive} eq "Incoming") {
    $src = $remote." ";
    $dst .= " ".$local;
  } else {
    $src = $local." ";
    $dst .= " ".$remote;
  }
  $src = sprintf('%*.*s', int(($w-9)/2), int(($w-9)/2), $src);
  $dst = sprintf('%-*.*s', int(($w-9)/2), int(($w-9)/2), $dst);
  print $src.$line_chr.$line_chr.$display_dg_records[$dg_rec_pos-1]{protocol}.$line_chr.$right_arrow_chr.$dst;

  # Add the TLS message details
  foreach my $line (@lines) {
    $line =~ s/\r//g;
    #next if $line =~ /^\s*$/;
    $pas = int(length($line)/$w);
    for $j (0 .. $pas) {
      goto_xy(($max_col - $w)/2, $margin + ($max_row-$margin-1 - $h)/2 + 2 + $i - $tls_start_line);
      $i++;
      if ($tls_start_line+1 <= $i) {
        if ($i-$tls_start_line > $h-2) {
          goto_xy(($max_col - $w)/2, $margin + ($max_row-$margin-1 - $h)/2 + 2 + $i-2 - $tls_start_line);
          print " " x (($w-3)/2) . "..." . " " x (($w-2)/2);
          last;
        } else {
          my $l = substr($line,$w*$j,$w);
          $l =~ s/\t/     /g;
          $l .= " " x ($w-length($l));

          # Color each line. The $carried_color is used to color the next line that was wraped.
          if ($l =~ s/^(\s+)(Certificate \d+ .*$)/$1.colored($2,'bold magenta')/e) {
            $carried_color = 'bold magenta';
          } elsif ($l =~ s/^(\s+[^:]*)$/colored($1,'bold green')/e) {
            $carried_color = 'bold green';
          } elsif ($l =~ s/^(\s+)(issuer:)(.*$)/$1.colored($2,'bold green').colored($3,'tls0')/e) {
            $carried_color = 'tls0';
          } elsif ($l =~ s/^(\s+)(subject:)(.*$)/$1.colored($2,'bold green').colored($3,'tls1')/e) {
            $carried_color = 'tls1';
          } elsif ($l =~ s/^(\s+)(.[^=]*?:)(.*$)/$1.colored($2,'bold green').$3/e) {
            $carried_color = '';
          } elsif ($l =~ s/^(.*Record Layer: .*)/colored($1,'bold red')/e) {
            $carried_color = 'bold red';
          } else {
            $l =~ s/^(.*)$/colored($1,$carried_color)/e;
          }

          print $l;
        }
      }
    }
    last if $i-$tls_start_line > $h-2;
  }
}

sub get_dg_display_lines {
  my ($w,$msg) = @_;
  # get the number of lines this message will use counting the carrier
  # returns and not exceding the box width
  my @lines = split(/\n/,$msg);
  my $num_lines = scalar(@lines);
  foreach my $line (@lines) {
    $num_lines += int(length($line) / $w);  
  }
  return $num_lines;
}

sub display_message {
  my $label,$w,$h;
  if ($need_resize) {
    $label = "Resize the window (min ".$min_row."x".$min_col.")";
  } elsif ($capture_mode eq "opening_file") {
    $label = "Opening file...";
  } elsif ($processing_initial_queue && not $is_real_time) {
    $label = "Processing messages. Please wait...";
  } elsif ($capture_mode eq "file") {
    $label = "No packets in the file(s) or no filter match";
  } elsif ($capture_mode eq "stop") {
    $label = "Press 's' to start the capture";
  } elsif ($capture_mode eq "starting") {
    $label = "Initiating capture...";
  } elsif ($capture_mode eq "start") {
    $label = "Capturing...";
  } elsif ($capture_mode eq "stopping") {
    $label = "Stopping capture...";
  } else {
    $label = "";
  }
  $w = length($label);
  $h = 1;
  display_text_box($w,$h,$label);
}

sub display_text_box {
  my ($w,$h,$label) = @_;
  clear_screen();
  if ($label ne "") {
    create_box($w+2,$h+2);
    goto_xy(($max_col - $w)/2, $dg_top_margin + ($max_row-$dg_top_margin-1 - $h)/2);
    print $label;
  }
  refresh_footer();
}

sub filter {
  my $w = 75;
  my $h = 30;
  my $x, $y, $options_result;

  $display_mode = "filter";
  create_box($w,$h);
  $x = ($max_col - $w-2)/2 + 1; 
  $y = $dg_top_margin + ($max_row-$dg_top_margin-1 - $h-2)/2 + 1;

  goto_xy($x, $y++);
  print "Filter Usage:";
  goto_xy($x, $y++);
  print "  -u <URI|NUMBER>  Filter calls that contain <URI|NUMBER> in"; 
  goto_xy($x, $y++);
  print "                   the 'From' or 'To' field.";
  goto_xy($x, $y++);
  print "  -i <IP>          Filter SIP messages from/to <IP> address.";
  goto_xy($x, $y++);
  print "  -c <CALL-ID>     Filter on the SIP 'Call-ID' header.";
  goto_xy($x, $y++);
  print "  -s <GSID>        Filter on the SIP 'Av-Global-Session-ID' header.\n";
  goto_xy($x, $y++);
  print "  -g <HEA>=<VALUE> Filter SIP packets with header <HEA> and value <VALUE>.";
  goto_xy($x, $y++);
  print "  -o <REGEX>       Filter SIP sessions that contain <REGEX>.";
  goto_xy($x, $y++);
  print "  -pu <USER>       Filter PUSH NOTIFICATIONs for <USER>.";
  goto_xy($x, $y++);
  print "  -or              Use a logical OR operator instead of the implicit";
  goto_xy($x, $y++);
  print "                   AND when using multiple filter options.";
  goto_xy($x, $y++);
  print "  -nr              Do not display REGISTER messages.";
  goto_xy($x, $y++);
  print "  -ns              Do not display SUBSCRIBE/NOTIFY messages.";
  goto_xy($x, $y++);
  print "  -no              Do not display OPTIONS messages.";
  goto_xy($x, $y++);
  print "  -ni              Do not display PING/PONG messages (RFC5626).";
  goto_xy($x, $y++);
  print "  -na              Do not display SM Call processing messages.";
  goto_xy($x, $y++);
  print "  -np              Do not display PPM messages.";
  goto_xy($x, $y++);
  print "  -nt              Do not display TLS messages.";
  goto_xy($x, $y++);
  print "  -nu              Do not display PUSH NOTIFICATION messages.";

  goto_xy($x, $y++);
  print "Filter examples:\n";
  goto_xy($x, $y++);
  print " To display a call to/from 3035556666 and not REGISTER messages:";
  goto_xy($x, $y++);
  print "    -u 3035556666 -nr";
  goto_xy($x, $y++);
  print " To display SIP messages from/to 1.1.1.1 and 2.2.2.2:";
  goto_xy($x, $y++);
  print "    -i \"1.1.1.1|2.2.2.2\"";

  $y++;
  goto_xy($x, $y++);
  print "Current Filter: ".filter_string();
  
  while (1) {
    undef($result);
    undef($options_result);
    undef($new_uri);
    undef($new_host_ip);
    undef($new_no_register);
    undef($new_no_subscribe);
    undef($new_no_options);
    undef($new_no_pingpong);
    undef($new_no_asm);
    undef($new_no_ppm);
    undef($new_no_tls);
    undef($new_call_id);
    undef($new_header_value);
    undef($new_or);
    undef($new_global_session_id);
    undef($new_contain_regex);
    undef($new_no_push);
    undef($new_push_user);

    goto_xy($x, $y);
    print "New Filter: ";

    # display the cursor and change to normal keyboard mode
    set_keyboard(0);
    cursor_visible(1);

    $new_filter = <STDIN>;

    # hide the cursor and go back to the special keyboard mode
    set_keyboard(1);
    cursor_visible(0);

    # clear the ERROR line
    goto_xy($x, $y+1);
    print " " x $w;
    local $SIG{__WARN__} = sub { $result = $_[0]; };
    $options_result = GetOptionsFromString($new_filter, 'u=s' => \$new_uri, 'i=s' => \$new_host_ip, 'c=s' => \$new_call_id, 'nu' => \$new_no_push, 'pu=s' => \$new_push_user,'s=s' => \$new_global_session_id, 'g=s' => \$new_header_value, 'o=s' => \$new_contain_regex, 'or' => \$new_or, 'nr' => \$new_no_register, 'ns' => \$new_no_subscribe, 'no' => \$new_no_options, 'ni' => \$new_no_pingpong, 'na' => \$new_no_asm, 'np' => \$new_no_ppm, 'nt' => \$new_no_tls, '<>' => sub { $result = "Unknown option $_[0]"; });
    if (!($options_result) || $result) {
      goto_xy($x, $y+1);
      print colored("ERROR: $result",'red');
      next;
    }
    $result = validate_options($new_uri,$new_host_ip,$new_call_id,$new_header_value,$new_global_session_id,$new_contain_regex,$sip_retain);
    if ($result) {
      goto_xy($x, $y+1);
      print colored("ERROR: $result",'red');
      next;
    }
    last;
  }
  $uri = $new_uri;
  $host_ip = $new_host_ip;
  $call_id = $new_call_id;
  $global_session_id = $new_global_session_id;
  $header_value = $new_header_value;
  $contain_regex = $new_contain_regex;
  $or = $new_or;
  $no_register = $new_no_register;
  $no_subscribe = $new_no_subscribe;
  $no_options = $new_no_options;
  $no_pingpong = $new_no_pingpong;
  $no_asm = $new_no_asm;
  $no_ppm = $new_no_ppm;
  $no_tls = $new_no_tls;
  $no_push = $new_no_push;
  $push_user = $new_push_user;

  audit("Filter applied: ".$new_filter);

  # refilter the packets
  goto_xy($x, $y+1);
  print "Filtering packets. Please wait...";

  # If no filters, then all the SM messages are displayed
  if ($new_filter eq "\n" || $new_filter eq "-np\n") {
    $display_asm = -1;
  } else {
    $display_asm = 0;
  }

  # Create the GSI filter
  $gsi_call_id = "";
  create_gsi_call_id_filter_from_regexp($global_session_id) if ($global_session_id);

  refilter();
}

sub refilter {
#printstack();
  my $host;

  # When using the -o option, we scan all the messages first and
  # add the Call-ID to the %contain_regex_callid hash. We need this as
  # we may match a message that already had previous message
  %contain_regex_callid = ();
  if ($contain_regex) {
    foreach $record (@dg_records) {
      if (($record->{type} eq "REQUEST" || $record->{type} eq "RESPONSE") && !exists($contain_regex_callid{$record->{call_id}}) && $record->{sip} =~ /$contain_regex/) {
        $contain_regex_callid{$record->{call_id}} = 1; 
      }
    }
  }

  %dg_columns = ();
  @display_dg_records = ();
  reset_calls();
  foreach $record (@dg_records) {
    if (filter_message($record) == 0) {
      if ($record->{type} eq "RTP") {
        add_column($record{ep_1});
        add_column($record{ep_2});
      } else {
        #$host = $record->{host};
        add_column($record->{host});
        add_column($record->{local_host});
      }
    }
    # Slow down if throttle is enabled (default)
    if (!($throttle)) {
      # Pause for 0.0001 seconds to avoid high CPU usage
      select(undef, undef, undef, 0.0001);
    }
  }
  $display_mode = "diagram";
  $prev_display_mode = "diagram";

  dg_init_positions("bottom");

  # update the window title
  set_title();

  dg_paint_all();
  $display_mode = "diagram";

}

sub reset_calls {
  foreach $key (keys(%calls)) {
    $calls{$key}{status} = 0; 
    $calls{$key}{display} = 0;
    foreach $key2 (keys(%{$calls{$key}{invites}})) {
      $calls{$key}{invites}{$key2} = 0;
    }
  }
}

sub display_write_to_file_dialog {
  my ($w, $h, $x, $y, $partial_size, $total_size, $minutes_since_start) = @_;

  create_box($w,$h);
  $x = ($max_col - $w-2)/2 + 1;
  $y = $dg_top_margin + ($max_row-$dg_top_margin-1 - $h-2)/2 + 1;

  goto_xy($x, $y);
  print "                                Save to file";
  $x += 1; $y += 2;
  goto_xy($x, $y);
  print "File name:                                    ".colored("(do not include the directory)", "bold black");
  goto_xy($x, $y+2);
  print "[ ] Include the displayed (filtered) SIP packets. The output .tgz file ";
  goto_xy($x, $y+3);
  print "    contains a text and Wireshark (.pcapng) version.";
  goto_xy($x, $y+4);
  print "[ ] Include the unfiltered logs since the beginnig of this capture (last ".colored($minutes_since_start,"green");
  goto_xy($x, $y+5);
  print "    minute".($minutes_since_start > 1 ? "s":"")."). The logs size is ".colored($partial_size,"green")." prior to compression (average 90%).";
  goto_xy($x, $y+6);
  print "[ ] Include all unfiltered logs on the server. The logs size is ".colored($total_size,"green");
  goto_xy($x, $y+7);
  print "    prior to compression (average 90%).";
  goto_xy($x+27, $y+9);
  print "[   OK   ]  [ CANCEL ]";
  if (is_capture()) {
    goto_xy($x+1, $y+10);
    print colored("WARNING: It is recommended to stop the capture to avoid files to rollover.", "yellow");
  }

  $x += 1;

  $_[2] = $x;
  $_[3] = $y;
}

sub refresh_write_to_file_chekbox {
  my ($x, $y, $pos) = @_;
  goto_xy($x, $y);
  if ($pos == 0) {
    cursor_visible(1);
  } else {
    cursor_visible(0);
  }
  for $i (0..5) {
    $reverse = "";
    $reverse = "reverse" if $pos == $i;

    if ($i == 0) { # The filename field

    } elsif ($i < 4) { # the chekboxes
      $label = " ";
      $label = "X" if $write_to_file_chekbox[$i-1];
      goto_xy($x, $y+$i*2);
      print colored($label,$reverse);
    } elsif ($i == 4) {  # OK
      goto_xy($x+27, $y+9);
      $label = "   OK   ";
      print colored($label,$reverse);
    } elsif ($i == 5) {  # CANCEL
      goto_xy($x+39, $y+9);
      $label = " CANCEL ";
      print colored($label,$reverse);
    }
  }
}

sub write_to_file {
  my $w = 78;
  my $h = 13;
  my ($x, $y, $file_name);
  my $tmp_ascii_file;
  my $pos = 0; # The file name field
  my $cancel = 0;

  %tcp_seq_num = ();
  $display_mode = "write";

  # By default check the first two options (save the filtered SIP and all the logs form the capture)
  @write_to_file_chekbox = (1, 1, 0);

  # Get the files modified since the start of the capture or when the user last clear the screen
  my $minutes_since_start = 1+int((time() - $start_capture_time) / 60);
  my $partial_size = `find $to_archive_trace_dir -mmin -$minutes_since_start -name "*.log*" | xargs du -h -c | tail -1 | cut -f1`;chop($partial_size);
  my $partial_size_kbytes = `find $to_archive_trace_dir -mmin -$minutes_since_start -name "*.log*" | xargs du -c | tail -1 | cut -f1`;chop($partial_size_kbytes);
  my $total_size = `du -h -c "$to_archive_trace_dir"*.log* | tail -1 | cut -f1`;chop($total_size);
  my $total_size_kbytes = `du -c "$to_archive_trace_dir"*.log* | tail -1 | cut -f1`;chop($total_size_kbytes);
  display_write_to_file_dialog($w, $h, $x, $y, $partial_size, $total_size, $minutes_since_start);
  while (1) {
    goto_xy($x, $y);
    my $fn_key = 0;
    my $include_full_logs = 1;
    while (1) {
      refresh_write_to_file_chekbox($x, $y, $pos);

      if ($pos == 0) {
        goto_xy($x+10+length($file_name), $y);
      }

      $new_key = getc(STDIN);
      if ($fn_key) {
        $key .= $new_key;
      } else {
        $key = $new_key;
      }
      # The arrow keys are actually a sequence of three keys.
      # For example the up arrow is ESC [ A
      if ($key eq "\e" || $key eq "\e[") {
        $fn_key = 1;
        next;
      }
      $fn_key = 0;

      if ($key eq "\e[A" || $key eq "\e[D") { # UP or LEFT
        $pos--;
        $pos = 5 if $pos<0;
      } elsif ($key eq "\e[B" || $key eq "\e[C") { # DOWN or RIGHT
        $pos++;
        $pos = 0 if $pos>5;
      } elsif ($key eq "\n" || ($key eq " " && $pos != 0)) { # ENTER or SPACE
        if ($pos == 0) { # In file name field
          $pos++;
        } elsif ($pos < 4) { # In the checkboxes
          # Toggle the checkbox
          $write_to_file_chekbox[$pos-1] = 1 - $write_to_file_chekbox[$pos-1];
        } elsif ($pos == 4) { # OK
          last;
        } elsif ($pos == 5) { # CANCEL
          $cancel = 1;
          last;
        }
      } elsif ($pos == 0 && length($key) == 1 && ord($key) >= 20 && ord($key) <= 126) { # Any printable ASCII character (sapce (20) to ~ (126))
        # replace space for underscore
        $key = "_" if $key eq " ";
        $file_name .= "$key";
        print $key;
      } elsif ($pos == 0 && ord($key) == 127 && length($file_name)) { # DEL/Backspace
        chop($file_name);
        print $key;
      }
    }

    # hide the cursor and go back to the special keyboard mode
    set_keyboard(1);
    cursor_visible(0);

    # clear the ERROR line
    goto_xy($x, $y+10);
    print " " x ($w-2);

    # Just return if the user did CANCEL
    last if $cancel;

    if (!length($file_name)) {
      goto_xy($x, $y+10);
      print colored("ERROR: Empty file name.",'red');
      next;
    }

    # Get the basename (do not allow to put in another dir as we need to create a dir structure
    $file_name = basename($file_name);
    if (!length($file_name)) {
      goto_xy($x, $y+10);
      print colored("ERROR: Empty or invalid file name.",'red');
      next;
    }

    my $sum = 0;
    foreach (@write_to_file_chekbox) {
      $sum += $_;
    }
    if (!$sum) {
      goto_xy($x, $y+10);
      print colored("ERROR: At least one checkbox should be checked.",'red');
      next;
    }

    # Check for disk space. The compression rate is usually 90%
    my $avail_space = `df . | tail -1 | awk '{ print \$(NF-2) }'`;chop($avail_space);
    my $mount_point = `df . | tail -1 | awk '{ print \$NF}'`;chop($mount_point);
    if ($write_to_file_chekbox[2] && $avail_space < $total_size_kbytes*0.1) { # All logs in the server
      goto_xy($x, $y+10);
      print colored("ERROR: Not enough disk space in $mount_point partition for all the logs.",'red');
      next;
    } elsif ($write_to_file_chekbox[1] && $avail_space < $partial_size_kbytes*0.1) { # Logs since the capture started
      goto_xy($x, $y+10);
      print colored("ERROR: Not enough disk space in $mount_point partition for the logs since started.",'red');
      next;
    }

    if ($write_to_file_chekbox[0]) { # SIP filtered messages
#      # Remove any existing file in case something bad happen in previous runs
#      `rm -f filtered_sip/*`;

      # create the filtered_sip dir
#      `mkdir -p filtered_sip`;
#      if ($?) {
#        goto_xy($x, $y+10);
#        print colored("ERROR: Could not create filtered_sip directory.",'red');
#        next;
#      }

      if (!(open OUT, "> $file_name")) {
        goto_xy($x, $y+10);
        print colored("ERROR: Could not open $file_name for writing.",'red');
        next;
      }

      $tmp_ascii_file = "/tmp/traceSM.tmp.ascii.$$";
      if (!(open ASCII, "> $tmp_ascii_file")) {
        goto_xy($x, $y+10);
        print colored("ERROR: Could not open temp file $tmp_ascii_file for writing.",'red');
        next;
      }

    }

    last;
  }
#  my $append = 0;
  if (!$cancel) {
    goto_xy($x, $y+10);
    print "                    ".colored("Writing packets. Please wait...                      ","green");

    if ($write_to_file_chekbox[0]) { # SIP filtered messages
      audit("Writing SIP messages to file $file_name");

      # Write the SIP text version
      write_sip_filtered();

      #Convert the ASCII to pcap
      $result = `text2pcap -q -t "%d/%m/%Y %H:%M:%S." $tmp_ascii_file $file_name.pcap 2>&1`;
      if($result eq "") {
        # Convert to pcapng and add the Name resolution
        convert_to_pcapng($file_name);
      } else {
        notify_user_pcap_conversion_failed() unless $result eq "";
        # Delete the temporarly pcap file
        die_message("Can't delete temporary file $file_name.pcap\nERROR: $!\n") unless unlink("$file_name.pcap");
      }
      die_message("Can't delete temporary file $tmp_ascii_file\nERROR: $!\n") unless unlink($tmp_ascii_file);
    }

    # Remove the directories if exist
    `rm -rf unfiltered_all`;
    `rm -rf unfiltered_since_start`;

    if ($write_to_file_chekbox[2]) { # All logs in the server (could be huge)
      audit("Writing all the logs ($total_size) in the server to file $file_name");
      # Create a unfiltered_all directory
      $result = `mkdir unfiltered_all 2>&1`;
      die_message("Could not create directory unfiltered_all\nERROR: $result\n") unless $result eq "";
      # Tar and zip all the logs
      `find $to_archive_trace_dir -name "*.log*" -printf '%f\n' | xargs tar czf unfiltered_all/logs.tgz --directory="$to_archive_trace_dir"`;
      audit("Finished writing all the logs");
    }

    if ($write_to_file_chekbox[1]) { # All logs since start of the capture
      audit("Writing the logs ($partial_size) since the capture start to file $file_name");
      # Create a unfiltered_since_start directory
      $result = `mkdir unfiltered_since_start 2>&1`;
      die_message("Could not create directory unfiltered_since_start\nERROR: $result\n") unless $result eq "";
      # Tar and zip the logs not older than the start of the capture. Also the first file of each category
      # needs to be reduced to only start from the first byte stored when the capture started (start_capture_file_data)
      # this is so when opening them, it is much faster as we filter out any old history.
      # First clear the "processed" flag
      foreach (keys %start_capture_file_data) {
        $start_capture_file_data{$_}{processed} = 0;
      }
      # Files could rollover (e.g. created tracer_asset.log.X), so for each file check based on the timestmap
      # and remove the first part of the file. Note this is not 100% safe as if the file has
      # rollover to the last (e.g. tracer_asset.log.60), then we will truncate that one even
      # that may not be the one that was first writting when the capture started. Unfortuinatly
      # we cannot easily avoid it as when files rotate, the inode does not move so can not tell
      # exactly which file was originally named.
      $minutes_since_start = 1+int((time() - $start_capture_time) / 60); # refresh this value as the user may have been in this dialog for some time
      my @list_of_files = split /\n/, `find $to_archive_trace_dir -mmin -$minutes_since_start -name "*.log*" | xargs ls -1tr`;
      my $files_to_tar = "";
      foreach (@list_of_files) {
        my $full_file_name = $_;
        my $file_name = basename($full_file_name);
        (my $base_file_name) = ($file_name =~ /(.*\.log)(?:\.\d+)?/);
        if (exists($start_capture_file_data{$base_file_name}) && !$start_capture_file_data{$base_file_name}{processed}) {
          # Create a new .trunc file removing the first X bytes
          `tail -c +$start_capture_file_data{$base_file_name}{size} $full_file_name > $full_file_name.trunc`;

          # Preserve the timestamp of the orginal file
          my $sb = stat("$full_file_name");
          utime($sb->atime, $sb->mtime, "$full_file_name.trunc");

          # Process each base file only once (the first/oldest one)
          $start_capture_file_data{$base_file_name}{processed} = 1;

          # Add the truncated version to the list of files to tar/gz
          $files_to_tar .= "$file_name.trunc ";
        } else {
          $files_to_tar .= "$file_name  ";
        }
      }
      # Finaly tar/gz the files
      `tar czf unfiltered_since_start/logs.tgz --directory="$to_archive_trace_dir" $files_to_tar`;

      # Clean the .trunc files
      `rm -f /var/log/Avaya/trace/*.trunc`;
      audit("Finished writing logs since the start of the capture");
    }


    # Tar and gzip the files
    $result = `tar --remove-files -czf "$file_name.tgz" --ignore-failed-read $file_name.pcapng $file_name unfiltered_all/logs.tgz unfiltered_since_start/logs.tgz 2>&1`;
    if ($?) {
      die_message("Can't tar files \nERROR: $result\n");
    }

    # ASM-62717 to fix for 7.1 umask change of permissions
    $result = `/bin/chmod 644 "$file_name.tgz"`;
    chomp($result);
    if ($result ne "") {
      die_message("Can't change permission of tar file \nERROR: $result\n");
    }

    # Remove the directories if exist
    `rm -rf unfiltered_all`;
    `rm -rf unfiltered_since_start`;
    audit("Finished tar and gzip the files");
  }

  # Free the TCP seq number hash
  %tcp_seq_num = ();

  $display_mode = "diagram";
  $prev_display_mode = "diagram";

  dg_init_positions("bottom");

  # update the window title
  set_title();

  dg_paint_all();
  $display_mode = "diagram";
}

sub write_sip_filtered {
  # write the displayed packets
  print OUT "### traceSM name_ip: ";
  foreach  $ip (keys %name_ip) {
    print OUT $ip."->";
    my $name = $name_ip{$ip};
    $name =~ s/->/__/g;
    $name =~ s/;/,/g;
    print OUT $name.";";
  }
  print OUT "\n";
  # Add the current filter
  print OUT "### filter: ".filter_string()."\n";

  foreach $message (@display_dg_records) {
    if ($message->{type} =~ "REQUEST|RESPONSE") {
      print OUT "com.avaya.asm  SIPMSGT ";
      my $dir = "";
      my $ingress = "\tingress: [NO TARGET]\n";
      my $egress = "\tegress: [NO TARGET]\n";

      # Add the [ ] for IPv6 to mimic what Asset generates
      if ($message->{local_host} =~ /\d+\.\d+\.\d+\.\d+/) {  # IPv4
        $local_ip = $message->{local_host};
        $remote_ip = $message->{host};
      } else {                                               # IPv6
        $local_ip = "[".$message->{local_host}."]";
        $remote_ip = "[".$message->{host}."]";
      }
      if ($message->{dropped_by} ne "") {
        print OUT "MESSAGE DROPPED BY:".$message->{dropped_by}."--------- REASON:".$message->{dropped_reason};
        $dir = "--v";
        $ingress = "\tingress: { L".$local_ip.":".$message->{local_port}."/R".$remote_ip.":".$message->{port}."/".$message->{protocol}."/0xa }\n";
      } elsif ($message->{send_receive} eq "Incoming") {
        $dir = "-->";
        $ingress = "\tingress: { L".$local_ip.":".$message->{local_port}."/R".$remote_ip.":".$message->{port}."/".$message->{protocol}."/0xa }\n";
      } else { # Outgoing
        $dir = "<--";
        $egress = "\tegress: { L".$local_ip.":".$message->{local_port}."/R".$remote_ip.":".$message->{port}."/".$message->{protocol}."/0xa }\n";
      }
      print OUT "\n";
      print OUT "--------------------\n";
      print OUT $message->{day}." ".$message->{timestamp}." ".$dir." \n";
      print OUT "\toctets: ".$message->{msglen}.", Body Length: ".$message->{bodylen}."\n";
      print OUT $ingress;
      print OUT $egress;
      if ($message->{context} ne "") {
        print OUT "\tAPMsgContext: {\n";
        print OUT "\t\t$message->{context}";
        print OUT "\t}\n";
      }
      print OUT "--------------------\n";
      $sip_msg = $message->{sip};
      $sip_msg =~ s/\n/\r\n/g;
      print OUT $sip_msg;
      print OUT "\n--------------------\n";

      create_ascii_hex_dump(\%message);
    } elsif ($message->{type} =~ "PPM") {
      create_ppm_ascii_hex_dump(\%message);
    }
  }
  close OUT;
  close ASCII;
}

sub convert_to_pcapng {
  my $file_name = shift;

  $result = `command -v tshark | wc -l`;
  chop($result);
  if ($result ne "1") {
	  # Incase wireshark rpm are not installed (possible in SW only installation)
	  # display warning message to user and continue writing files to tgz
	  notify_user_wireshark_missing_pcapng_wont_work();
	  return;
  }

  # Convert the pcap to pcapng
  $result = `tshark -F pcapng -r "$file_name.pcap" -w "$file_name.pcapng.tmp" 2>&1`;
  die_message("Can't convert to pcapng format.\nERROR: $result\n") unless $result eq "Running as user \"root\" and group \"root\". This could be dangerous.\n";

  open(PCAPNGTMP, "$file_name.pcapng.tmp") or die_message("Can't open $file_name.pcapng.tmp for reading.\nERROR: $!\n");
  open(PCAPNG, ">$file_name.pcapng") or die_message("Can't open $file_name.pcapng for writing.\nERROR: $!\n");

  # Add the Name resolution to the pcapng file

  # Read the len of the Section Header Block (bytes 4 to 8)
  read(PCAPNGTMP, $buffer, 8);
  ($block_type,$block_total_len) = unpack("VV",$buffer);
  die_message("ERROR: Invalid pcapng file (block type: $block_type)\n") unless $block_type==168627466; # Block Type should be 0x0A0D0D0A
  print PCAPNG $buffer;

  # Read the rest of the Section Header Block
  read(PCAPNGTMP, $buffer, ($block_total_len-8));
  print PCAPNG $buffer;

  # Append the Name Resolution Blocks
  # Block Type = 0x00000004
  my $name_res_block = pack("V",4);
  # Dummy length (will calcualte later)
  $name_res_block .= pack("V",0);
  foreach $ip (keys %name_ip) {
    # Record Type (IPv4=1)
    $name_res_block .= pack("v",1);
    # Record length (4(IP)+len(name)+1(null_term))
    my $rec_len = 4+length($name_ip{$ip})+1;
    $name_res_block .= pack("v",$rec_len);
    # Record value (aligned to 32 bits)
    # First the IP
    $name_res_block .= pack("C4",split(/\./, $ip));
    # Then the name as zero-terminated string
    $name_res_block .= $name_ip{$ip}."\0";
    # Pad to 32 bits
    $name_res_block .= "\0" x (4 - ($rec_len % 4)) if ($rec_len % 4) > 0;
  }
  # End of Record
  $name_res_block .= pack("vv",0,0);
  # Recalculate the Name resolution block length
  my $block_total_len = length($name_res_block)+4;
  $name_res_block = substr($name_res_block,0,4).pack("V",$block_total_len).substr($name_res_block,8);
  # Add the block total length at the end
  $name_res_block .= pack("V",$block_total_len);
  print PCAPNG $name_res_block;

  # Copy the rest of the orifinal file
  while ( read(PCAPNGTMP, $buffer, 1024) ) {
    print PCAPNG $buffer;
  }

  close PCAPNG;
  close PCAPNGTMP;

  # Delete the temporarly pcapng file
  die_message("Can't delete temporary file $file_name.pcapng.tmp\nERROR: $!\n") unless unlink("$file_name.pcapng.tmp");
  # Delete the temporarly pcap file
  die_message("Can't delete temporary file $file_name.pcap\nERROR: $!\n") unless unlink("$file_name.pcap");
}

sub create_ascii_hex_dump {
  my $params = shift;
  my %message = %$params;

#print TMP "Time: ".$message->{timestamp}."\n".$message->{sip}."\n";

  print ASCII "$message->{day} $message->{timestamp}\n";

  my $sip_msg = $message->{sip};

  # Recalculate the Content-Length header
  if ($sip_msg =~ /^Content-Length:\s*\d+/mi) {

    my ($body) = $sip_msg =~ /(?:.*?)\n\n(.*)/s;
    my $body_len = length($body);
    $sip_msg =~ s/^Content-Length:\s*\d+/Content-Length: $body_len/m;
  }
  my $sip_len = length($sip_msg);

  my $frame = "";
  # Dummy MAC addresses.
  if ($message->{protocol} eq "TCP") {
    $frame .= pack("C*",10,10,10,10,10,10,10,10,10,10,10,10);
  } elsif ($message->{protocol} eq "TLS") {
    $frame .= pack("C*",11,11,11,11,11,11,11,11,11,11,11,11);
  } else { # UDP
    $frame .= pack("C*",12,12,12,12,12,12,12,12,12,12,12,12);
  }
  # IP encap 0x800
  $frame .= pack("n",hex("0x800"));

  # IP v4 and header len
  $frame .= pack("C",hex("0x45"));
  # Diff Serv
  $frame .= pack("C",hex("0x00"));
  # IP Total len
  $frame .= pack("n",$sip_len+20+($message->{protocol} eq "UDP" ? 8 : 20));
  # Dummy IP Identifier 0x1234, flags, fragment offset, TTL
  $frame .= pack("nnC",hex("0x1234"),0,255);
  # Protocol
  $frame .= pack("C",$message->{protocol} eq "UDP" ? 17 : 6 );
  # Dummy checksum
  $frame .= pack("n", 0);
  # Source and Destination IPs
  if ($message->{send_receive} eq "Incoming") {
    $frame .= pack("C4",split(/\./, $message->{host}));
    $frame .= pack("C4",split(/\./, $message->{local_host}));
  } else {
    $frame .= pack("C4",split(/\./, $message->{local_host}));
    $frame .= pack("C4",split(/\./, $message->{host}));
  }

  # Get the IP header only to calculate the checksum
  my $ip_hdr = substr($frame,14,20);
  my $ip_chksum = in_cksum($ip_hdr);
  # Replace with correct IP cheksum
  $frame = substr($frame,0,14+10).pack("v",$ip_chksum).substr($frame,14+10+2);

  # UDP or TCP header
  # Source and destination port
  if ($message->{send_receive} eq "Incoming") {
    $frame .= pack("n",$message->{port});
    $frame .= pack("n",$message->{local_port});
  } else {
    $frame .= pack("n",$message->{local_port});
    $frame .= pack("n",$message->{port});
  }
  if ($message->{protocol} eq "UDP") {
    # UDP len
    $frame .= pack("n",$sip_len+8);
    # Dummy cheksum
    $frame .= pack("n",0);
  } else { # TCP
    # Sequence number
    my $seq_hash_key;
    if ($message->{send_receive} eq "Incoming") {
      $seq_hash_key = "In_".$message->{host}.":".$message->{port}."_".$message->{local_port}.":".$message->{local_host};
    } else {
      $seq_hash_key = "Out_".$message->{local_port}.":".$message->{local_host}."_".$message->{host}.":".$message->{port};
    }
    $frame .= pack("N",$tcp_seq_num{$seq_hash_key});
    $tcp_seq_num{$seq_hash_key} += $sip_len;
    # ACK number (always 0)
    $frame .= pack("N",0);
    # Flags and TCP header len
    $frame .= pack("C2",hex("0x50"),0);
    # Window size
    $frame .= pack("n",8192);
    # Dummy cheksum
    $frame .= pack("n",0);
    # Urgent pointer
    $frame .= pack("n",0);
  }
  $frame .= $sip_msg;
  my $offset = 0;
  my(@array,$format);
  foreach my $data (unpack("a16"x(length($frame)/16)."a*",$frame)) {

    $data =~ tr/\N{BOM}/./d;
    my($len)=length($data);
    @array = unpack('C*', $data);
    $_ = sprintf "%2.2x", $_ for @array;
    push(@array, '  ') while $len++ < 16;
    $format="%08x %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s   %s\n";
    # Replace non-ascii characters for a "."
    $data =~ tr/\0-\37\177-\377/./;
    # Also replace the "#" for a "." as it casues an
    # issue with text2pcap when the # is the last
    # character in the 16 byte desc column and
    # is preceeded by a space. Under those conditions
    # text2pcap think the following line
    # is a comment, which causes the message to fail parse
    $data =~ tr/#/./;

    printf ASCII $format,$offset,@array,$data;
    $offset += 16;
  }
}

sub create_ppm_ascii_hex_dump {
  my $params = shift;
  my %message = %$params;

  print TMP "create_ppm_ascii_hex_dump called \n";

  my ($year,$month,$day) = $message->{day} =~ /(\d{4})-(\d{1,2})-(\d{1,2})/;
  my ($hour,$minute,$seconds,$milliseconds) = $message->{timestamp} =~ /(\d{1,2}):(\d{1,2}):(\d{1,2}),(\d{1,3})?/;

  print ASCII "$day/$month/$year $hour:$minute:$seconds.$milliseconds\n";
  my $ppm_msg = $message->{msg};
  my $ppm_len = length($ppm_msg);

  my $frame = "";
  # Dummy MAC addresses.
  if ($message->{protocol} eq "TCP") {
    $frame .= pack("C*",10,10,10,10,10,10,10,10,10,10,10,10);
  } elsif ($message->{protocol} eq "TLS") {
    $frame .= pack("C*",11,11,11,11,11,11,11,11,11,11,11,11);
  } else { # UDP
    $frame .= pack("C*",12,12,12,12,12,12,12,12,12,12,12,12);
  }
  # IP encap 0x800
  $frame .= pack("n",hex("0x800"));

  # IP v4 and header len
  $frame .= pack("C",hex("0x45"));
  # Diff Serv
  $frame .= pack("C",hex("0x00"));
  # IP Total len
  $frame .= pack("n",$ppm_len+20+($message->{protocol} eq "UDP" ? 8 : 20));
  # Dummy IP Identifier 0x1234, flags, fragment offset, TTL
  $frame .= pack("nnC",hex("0x1234"),0,255);
  # Protocol
  $frame .= pack("C",$message->{protocol} eq "UDP" ? 17 : 6 );
  # Dummy checksum
  $frame .= pack("n", 0);
  # Source and Destination IPs
  if ($message->{send_receive} eq "Incoming") {
    $frame .= pack("C4",split(/\./, $message->{host}));
    $frame .= pack("C4",split(/\./, $message->{local_host}));
  } else {
    $frame .= pack("C4",split(/\./, $message->{local_host}));
    $frame .= pack("C4",split(/\./, $message->{host}));
  }

  # Get the IP header only to calculate the checksum
  my $ip_hdr = substr($frame,14,20);
  my $ip_chksum = in_cksum($ip_hdr);
  # Replace with correct IP cheksum
  $frame = substr($frame,0,14+10).pack("v",$ip_chksum).substr($frame,14+10+2);

  # UDP or TCP header
  # Source and destination port
  if ($message->{send_receive} eq "Incoming") {
    $frame .= pack("n",$message->{port});
    $frame .= pack("n",$message->{local_port});
  } else {
    $frame .= pack("n",$message->{local_port});
    $frame .= pack("n",$message->{port});
  }
  if ($message->{protocol} eq "UDP") {
    # UDP len
    $frame .= pack("n",$ppm_len+8);
    # Dummy cheksum
    $frame .= pack("n",0);
  } else { # TCP
    # Sequence number
    my $seq_hash_key;
    if ($message->{send_receive} eq "Incoming") {
      $seq_hash_key = "In_".$message->{host}.":".$message->{port}."_".$message->{local_port}.":".$message->{local_host};
    } else {
      $seq_hash_key = "Out_".$message->{local_port}.":".$message->{local_host}."_".$message->{host}.":".$message->{port};
    }
    $frame .= pack("N",$tcp_seq_num{$seq_hash_key});
    $tcp_seq_num{$seq_hash_key} += $ppm_len;
    # ACK number (always 0)
    $frame .= pack("N",0);
    # Flags and TCP header len
    $frame .= pack("C2",hex("0x50"),0);
    # Window size
    $frame .= pack("n",8192);
    # Dummy cheksum
    $frame .= pack("n",0);
    # Urgent pointer
    $frame .= pack("n",0);
  }
  $frame .= $ppm_msg;
  my $offset = 0;
  my(@array,$format);
  foreach my $data (unpack("a16"x(length($frame)/16)."a*",$frame)) {

    $data =~ tr/\N{BOM}/./d;
    my($len)=length($data);
    @array = unpack('C*', $data);
    $_ = sprintf "%2.2x", $_ for @array;
    push(@array, '  ') while $len++ < 16;
    $format="%08x %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s   %s\n";
    # Replace non-ascii characters for a "."
    $data =~ tr/\0-\37\177-\377/./;
    # Also replace the "#" for a "." as it casues an
    # issue with text2pcap when the # is the last
    # character in the 16 byte desc column and
    # is preceeded by a space. Under those conditions
    # text2pcap think the following line
    # is a comment, which causes the message to fail parse
    $data =~ tr/#/./;

    printf ASCII $format,$offset,@array,$data;
    $offset += 16;
  }
}

# Calculate IP checksum (from NetPacket.pm)
sub in_cksum {

    my ($packet) = @_;
    my ($plen, $short, $num,  $count, $chk);

    $plen = length($packet);
    $num = int($plen / 2);
    $chk = 0;
    $count = $plen;

    foreach $short (unpack("S$num", $packet)) {
        $chk += $short;
        $count = $count - 2;
    }

    if($count == 1) {
        $chk += unpack("C", substr($packet, $plen -1, 1));
    }

    # add the two halves together (CKSUM_CARRY -> libnet)
    $chk = ($chk >> 16) + ($chk & 0xffff);
    return(~(($chk >> 16) + $chk) & 0xffff);
}

sub goto_record {
  my $w = 72;
  my $h = 5;
  my ($x, $y);

  $display_mode = "goto";
  create_box($w,$h);
  $x = ($max_col - $w-2)/2 + 1;
  $y = $dg_top_margin + ($max_row-$dg_top_margin-1 - $h-2)/2 + 1;

  goto_xy($x, $y++);
  print " Go to the next record (SIP/PPM/CallP/TLS) which contains the ";
  goto_xy($x, $y++);
  print " following regex. A timestamp (e.g. 13:14:33) could also be specified ";
  goto_xy($x, $y++);
  while (1) {
    undef($goto_search);
    undef($search_header_msg);

    goto_xy($x, $y);
    print " Search: ";

    # display the cursor and change to normal keyboard mode
    set_keyboard(0);
    cursor_visible(1);

    $goto_search = <STDIN>;
    chop($goto_search);

    # hide the cursor and go back to the special keyboard mode
    set_keyboard(1);
    cursor_visible(0);

    # clear the ERROR line
    goto_xy($x, $y+1);
    print " " x $w;

    # Just return if the user did not enter any input
    last if length($goto_search) == 0; 

    # Check if it is a valid regex
    eval { qr/$goto_search/ };
    if ($@) {
      goto_xy($x, $y+1);
      print colored(" ERROR: Invalid regular expression.",'red');
      next;
    }
    
    last;
  }
  $display_mode = "diagram";
  $prev_display_mode = "diagram";

  dg_init_positions("next");
  dg_paint_all(); # Always repain to get rid of the popup and move to the matched record 

  # update the window title
  set_title();

  $display_mode = "diagram";
}


sub confirm_close {
  my $w = 45;
  my $h = 4;
  my ($x, $y, $answer);

  $display_mode = "write";
  create_box($w,$h);
  $x = ($max_col - $w-2)/2 + 1;
  $y = $dg_top_margin + ($max_row-$dg_top_margin-1 - $h-2)/2 + 1;

  goto_xy($x, $y++);
  print "   SM is still capturing and will continue";
  goto_xy($x, $y++);
  print "   logging in the background if you quit.";
  $y++;
  
  until ($answer =~ /^y(es)?$|^n(o)?$/i) {
    undef($answer);

    goto_xy($x, $y);
    print "Are you sure you want to quit (Yes/No)? ";

    # display the cursor and change to normal keyboard mode
    set_keyboard(0);
    cursor_visible(1);

    $answer = <STDIN>;
    chop($answer);

    # hide the cursor and go back to the special keyboard mode
    set_keyboard(1);
    cursor_visible(0);

  }

  $display_mode = "diagram";
  $prev_display_mode = "diagram";

  dg_init_positions("bottom");

  # update the window title
  set_title();

  dg_paint_all();
  $display_mode = "diagram";

  return ($answer =~ /^y/i);
}



sub filter_string {
  my $filter = "";
  $filter .= "-u \"$uri\" " if $uri; 
  $filter .= "-i \"$host_ip\" " if $host_ip;
  $filter .= "-c \"$call_id\" " if $call_id;
  $filter .= "-s \"$global_session_id\" " if $global_session_id;
  $filter .= "-g \"$header_value\" " if $header_value;
  $filter .= "-o \"$contain_regex\" " if $contain_regex;
  $filter .= "-or " if $or;
  $filter .= "-nr " if $no_register;
  $filter .= "-ns " if $no_subscribe;
  $filter .= "-no " if $no_options;
  $filter .= "-ni " if $no_pingpong;
  $filter .= "-na " if $no_asm;
  $filter .= "-np " if $no_ppm;
  $filter .= "-nt " if $no_tls;

  $filter = "<NO FILTER>" if not $filter; 

  $filter = colored($filter,'green');
  return $filter;
}

sub die_message {
  my ($msg) = @_;
  if ($capture_mode eq "start") {
    start_stop_capture();
  }
  if ($msg ne "") {
    audit("Die: $msg");
  }
  quit_program($msg); 
}

sub set_title {
  return if !$support_title;
  my $display_dg_record_no = scalar (@display_dg_records);
  my $dg_record_no = scalar (@dg_records);
  my $label = "";
  my $label_filter = "";
  $label = " - MAX NUM PACKETS ($max_packets) EXEEDED!" if $dg_record_no > $max_packets;
  $label_filter = "- FILTERED " if filter_string() ne colored("<NO FILTER>",'green'); 
  print "\033]0;".hostname." - traceSM V$version ".$label_filter."- Captured: ".$dg_record_no."   Displayed: ".$display_dg_record_no.$label."\007"; 
}

sub get_name {
  my ($table,$ids) = @_;
  my $ids_to_query = "";
  my $result = "";
# print TMP "GET NAME $table  $ids\n";
  foreach (split(/,\s*/,$ids)) {
    if (!exists($$table{$_})) {
      if ($_ eq "null") {
        $$table{$_} = "null";
      } else {
        $ids_to_query .= $_.",";
      }
    }
  }
  chop($ids_to_query);
  if ($ids_to_query ne "") {
    query_database($table,$ids_to_query);
  }
  foreach (split(/,\s*/,$ids)) {
    $result .= $$table{$_}.", ";
  }
  chop($result);
  chop($result);
  return $result; 
}

sub query_database {
  my ($table,$ids) = @_;
  my $column = "name";
  if (!($no_database)) {
    if ($table eq "digitmap") {
      $column = "digitpattern";
    }
    my $sql = "select id,".$column." from ".$table." where id in(".$ids.");";
    if ($table eq "hostnameresolution") {
      $sql = "select asmhostnameresolutionip.ipaddress,fqdn from asmhostnameresolution,asmhostnameresolutionip where asmhostnameresolutionip.ipaddress='".$ids."' and asmhostnameresolutionip.hostnameresolution_id=asmhostnameresolution.id;";
    }

    $result = `$psql_cmd asm -U asm -c "$sql" -t -P format=unaligned 2>&1`;
    if ($result =~ /: FATAL:  authentication failed for user |sh: $psql_cmd: command not found/) {
      $no_database = 1;
    } else {
      foreach (split(/\n/,$result)) {
        if (/^(\d+|\d+\.\d+\.\d+\.\d+|$IPv6_re)\|(.*)/) {
          $$table{$1} = $2;
        }
      }
    }
  }

  foreach (split(/,\s*/,$ids)) {
    if (!exists($$table{$_})) {
      $$table{$_} = "id:$_";
    }
  }
}

sub query_generic_database {
  my ($sql) = @_;
  if (!($no_database)) {
    $result = `$psql_cmd asm -U asm -c "$sql" -t -P format=unaligned 2>&1`;
    if ($result =~ /: FATAL:  authentication failed for user |sh: $psql_cmd: command not found/) {
      $no_database = 1;
    } else {
      foreach (split(/\n/,$result)) {
        # retrun the first match only
        if (/^(\d+|\d+\.\d+\.\d+\.\d+|$IPv6_re)\|(.*)/) {
          return $2;
        } else {
          return $_;
        }
      }
    }
  }

  return "";
}

sub update_call_summary {
  my $params = shift;
  my %message = %$params;
  my $host;
  my $cid = $message{call_id};

  if (($message{method} eq "INVITE") && ($message{to_tag} eq "")) {
    # Get the 'phase' from the Route header
    my $phase = "";
    my $via = "";
    if ($message{sip} =~ /^Route: .*?phase=(\w+).*$/m) {
      $phase = $1;
      if (exists($ims_phase{$phase})) {
        $phase = $ims_phase{$phase};
      }
    }
    if ($message{sip} =~ /^Via:.*?branch=([a-zA-Z0-9\-\.!%\*_\+\`'~]*).*$/m) {
      $via = $1;
    } else {
#      print TMP "ERROR, NO Via in message:\n$message{sip}\n\n";
      return;
    }

    if (!exists($call_summary{$cid})) {
      add_call_summary_entry(\%message);
    }
    
    $call_summary{$cid}{call_flow_refresh} = 1;
    my ($cseq) = ($message{sip} =~ /^CSeq: (\d+) \w+/m);
    $call_summary{$cid}{last_cseq} = $cseq;

    if (!exists($call_summary{$cid}{INV}{$cseq})) {
      $call_summary{$cid}{INV}{$cseq} = &share({});
      $call_summary{$cid}{INV}{$cseq}{from_ip} = &share([]);
      $call_summary{$cid}{INV}{$cseq}{to_ip} = &share([]);
      $call_summary{$cid}{INV}{$cseq}{phase} = &share([]);
      $call_summary{$cid}{INV}{$cseq}{via} = &share([]);
      $call_summary{$cid}{INV}{$cseq}{resp_code} = &share({});
    }

    if ($message{sip} =~ /^Av-Global-Session-ID:\s+([^;\r\n]*)(?:;a-gsid=([^;\r\n]*))?/mi) {
#print TMP "$message{timestamp} requ $calls{$cid}{number} gsi:$1 agsi:$2\n";
      my $gsid = $1;
      my $agsi = $2;
      ($call_summary{$cid}{gsi}) = $gsid;
      if (!exists($sessions{$gsid})) {
        $sessions{$gsid} = &share({});
        $sessions{$gsid}{call_id} = &share({});
#        $sessions{$gsid}{number} = keys(%sessions);
      }
      #$sessions{$gsid}{number} = keys(%sessions);
#print TMP "$message{timestamp} requ $calls{$cid}{number} gsi:$gsid agsi:$agsi\n";
      update_session_number($gsid,$cid);
      $sessions{$gsid}{call_id}{$cid} = 1;
      $sessions{$gsid}{agsi} = $agsi;
      $calls{$cid}{global_session_id}{$gsid} = 1;
      $calls{$cid}{global_session_id}{$agsi} = 1;
    }


    if ($message{send_receive} eq "Incoming") {
      # A new call is consider for an INVITE which match all the following criteria:
      #           it does not yet exist in the call_summary hash
      #           it is Incoming to SM
      #           it is OOD
      if (exists($call_summary{$cid})) {
        update_players_call_summary_entry(\%message);
        update_state_call_summary_entry($cid,"Init","INVITE");
      }

      # Add the INVITE to the call flow array
      push(@{$call_summary{$cid}{INV}{$cseq}{from_ip}}, $message{host});
      push(@{$call_summary{$cid}{INV}{$cseq}{to_ip}}, $message{local_host});

    # Outgoing INVITE. 
    } else {
      # Add the INVITE to the call flow array
      push(@{$call_summary{$cid}{INV}{$cseq}{from_ip}}, $message{local_host});
      push(@{$call_summary{$cid}{INV}{$cseq}{to_ip}}, $message{host});
    }
    push(@{$call_summary{$cid}{INV}{$cseq}{phase}}, $phase);
    push(@{$call_summary{$cid}{INV}{$cseq}{via}}, $via);
    $call_summary{$cid}{INV}{$cseq}{resp_code}{$via} = "";
  }

  # request is CANCELed
  if (($message{method} eq "CANCEL") && ($message{send_receive} eq "Incoming") 
       && exists($call_summary{$cid})) {
    update_state_call_summary_entry($cid,"Canceled", "CANCEL");
  } 

  # BYE
  if (($message{method} eq "BYE") && ($message{send_receive} eq "Incoming") 
       && exists($call_summary{$cid}) && ($call_summary{$cid}{state} eq "Confirmed")) { 
    if ($message{host} eq $call_summary{$cid}{orig_ip} && $message{to_tag} eq $call_summary{$cid}{to_tag}) {
      update_state_call_summary_entry($cid,"Terminated", "BYE (calling)");
    } else {
      update_state_call_summary_entry($cid,"Terminated", "BYE (called)");
    }
  }
    
  if (($message{type} eq "RESPONSE") 
       && exists($call_summary{$cid}) && ($message{to_tag} ne "")) {
    if ($message{sip} =~ /^CSeq:\s*(\d+)\s*INVITE/m) {
      my $cseq = $1;
      ($resp_code, $resp_desc) = $message{response} =~ /^(\d+) (.*)/;
      if ($message{sip} =~ /^Via:.*?branch=([a-zA-Z0-9\-\.!%\*_\+\`'~]*).*$/m) {
        $via = $1;
      } else {
#        print TMP "ERROR, NO Via in response message:\n$message{sip}\n\n";
        return;
      }

      # Sometimes the GSID changes on the responses.
      if ($message{sip} =~ /^Av-Global-Session-ID:\s+([^;\r\n]*)(?:;a-gsid=([^;\r\n]*))?/mi) {
#print TMP "$message{timestamp} resp $calls{$cid}{number} gsi:$1 agsi:$2\n";
        my $gsid = $1;
        my $agsi = $2;
        if (!exists($sessions{$gsid})) {
          $sessions{$gsid} = &share({});
          $sessions{$gsid}{call_id} = &share({});
        }
#print TMP "$message{timestamp} resp $calls{$cid}{number} gsi:$1 agsi:$2\n";
        update_session_number($gsid,$cid);
        $sessions{$gsid}{call_id}{$cid} = 1;
        $sessions{$gsid}{agsi} = $agsi;
        $calls{$cid}{global_session_id}{$gsid} = 1;
        $calls{$cid}{global_session_id}{$agsi} = 1;
      }

      # Change response state code 
      if (($call_summary{$cid}{state} eq "Init" || $call_summary{$cid}{state} eq "Early") 
          && ($cseq eq $call_summary{$cid}{last_cseq})) {
        $call_summary{$cid}{to_tag} = $message{to_tag};
        # Outgoing: response to the original INVITE
        if ($resp_code >= 100 && $resp_code < 200) {
          update_state_call_summary_entry($cid,"Early", "$message{response}");
        } elsif ($resp_code >= 400 && $resp_code < 700) {
          update_state_call_summary_entry($cid,"Rejected","$message{response}");
        } elsif ($resp_code >= 200 && $resp_code < 300) {
          update_state_call_summary_entry($cid,"Confirmed","$message{response}");
        } elsif ($resp_code >= 300 && $resp_code < 400) {
          update_state_call_summary_entry($cid,"Redirected","$message{response}");
        }
      }


      if (!exists($call_summary{$cid}{response}{$cseq})) {
        $call_summary{$cid}{response}{$cseq} = &share({});
        $call_summary{$cid}{response}{$cseq}{from_ip} = &share([]);
        $call_summary{$cid}{response}{$cseq}{to_ip} = &share([]);
        $call_summary{$cid}{response}{$cseq}{code} = &share([]);
        $call_summary{$cid}{response}{$cseq}{via} = &share([]);
      }
      if ($message{send_receive} eq "Outgoing") {
        push(@{$call_summary{$cid}{response}{$cseq}{from_ip}}, $message{local_host});
        push(@{$call_summary{$cid}{response}{$cseq}{to_ip}}, $message{host});
      } else {
        push(@{$call_summary{$cid}{response}{$cseq}{from_ip}}, $message{host});
        push(@{$call_summary{$cid}{response}{$cseq}{to_ip}}, $message{local_host});
      }
      push(@{$call_summary{$cid}{response}{$cseq}{code}}, $resp_code);
      push(@{$call_summary{$cid}{response}{$cseq}{via}}, $via);

      if (exists($call_summary{$cid}{INV}{$cseq}) && exists($call_summary{$cid}{INV}{$cseq}{resp_code}) && exists($call_summary{$cid}{INV}{$cseq}{resp_code}{$via})) {
         $call_summary{$cid}{INV}{$cseq}{resp_code}{$via} = $resp_code; 
      }

      $call_summary{$cid}{call_flow_refresh} = 1;
    }
  }
 
  # Increment the number of SIP messages and flag to refresh the screen
  if (exists($call_summary{$cid})) {
    if ($message{host} eq "$asm_ip" || $message{host} eq "$asm_ipv6") {
      $call_summary{$cid}{no_msgs_internal}++;
    } else {
      $call_summary{$cid}{no_msgs_external}++;
    }
    $cl_need_refresh = 1;
  } 
}

sub reset_call_flow_refresh {
  foreach $cid (keys %call_summary) {
    $call_summary{$cid}{call_flow_refresh} = 1;
  }
  $cl_need_refresh = 1;
}

sub add_call_summary_entry {
  my $params = shift;
  my %message = %$params;
  lock($cl_top_pos);lock($cl_rec_pos);
  my $cid = $message{call_id};
  $call_summary{$cid} = &share({});
  $call_summary{$cid}{to_tag} = "";
  $call_summary{$cid}{state_detail} = "";
  $call_summary{$cid}{from} = get_uri_userinfo(($message{sip} =~ /^(?:From|f): (.*)/mi));
  $call_summary{$cid}{to} = get_uri_userinfo(($message{sip} =~ /^(?:To|t): (.*)/mi)); 
  $call_summary{$cid}{request_uri} = $message{request_uri}; 
  $call_summary{$cid}{start_time} = $message{timestamp};
  $call_summary{$cid}{INV} = &share({});
  $call_summary{$cid}{response} = &share({});
  $call_summary{$cid}{number} = keys(%call_summary);

#  ($call_summary{$cid}{cseq}) = ($message{sip} =~ /^CSeq: (\d+ \w+)/m);
  $call_summary{$cid}{orig_ip} = $message{host};
  $call_summary{$cid}{last_term_ip} = "";
  $call_summary{$cid}{no_msgs_internal} = 0;
  $call_summary{$cid}{no_msgs_external} = 0;
  $call_summary{$cid}{cid} = $cid;
  update_state_call_summary_entry($cid,"Init","INVITE");

  push(@display_cl_record, $call_summary{$cid});

  # if the cursor is already at the bottom, then move it
  my $no_call_summary = scalar(keys(%call_summary));
  if ($cl_rec_pos == $no_call_summary-2) {

    $cl_rec_pos++;
    if ($cl_rec_pos > $cl_top_pos+$max_row-5) {
      $cl_top_pos++;
    }
  }
}

sub update_players_call_summary_entry {
  my $params = shift;
  my %message = %$params;
  my $cid = $message{call_id};
  $call_summary{$cid}{from} = get_uri_userinfo(($message{sip} =~ /^(?:From|f): (.*)/mi));
  $call_summary{$cid}{to} = get_uri_userinfo(($message{sip} =~ /^(?:To|t): (.*)/mi)); 
  $call_summary{$cid}{request_uri} = $message{request_uri};
#  ($call_summary{$cid}{cseq}) = ($message{sip} =~ /^CSeq: (\d+ \w+)/m); 
}

sub get_uri_userinfo {
  my $uri = shift;
  (my $userinfo) = ($uri =~ /(?:".*"\s*)?<?sips?:([^@]*)[^;>\r\n]*>?/);
  return $userinfo if $uri =~ /@/;
  $uri =~ /(?:".*"\s*)?<?sips?:([^>]*)/;
  return $1;
}

sub update_state_call_summary_entry {
  my ($cid,$new_state,$state_detail) = @_;
  $call_summary{$cid}{state} = $new_state;
  $call_summary{$cid}{state_detail} = $state_detail;
  
  #print_call_summary();
}

sub print_call_summary {
  foreach $cid (keys(%call_summary)) {
    print TMP $cid."\n";
    print TMP "\t$call_summary{$cid}{start_time}  ";
    print TMP "\t$call_summary{$cid}{state} - $call_summary{$cid}{state_detail}  ";
    print TMP "\t$call_summary{$cid}{from}  ";
    print TMP "\t$call_summary{$cid}{to}  ";
    print TMP "\t$call_summary{$cid}{request_uri}  ";
    print TMP "\t$call_summary{$cid}{to_tag}\n";
    print TMP "\t$call_summary{$cid}{no_msgs_internal}\n";
    print TMP "\t$call_summary{$cid}{no_msgs_external}\n";
    print TMP "\t$call_summary{$cid}{orig_ip} -> ";
    print TMP "\n";

    foreach $cseq (keys(%{$call_summary{$cid}{INV}})) {
      print TMP "Call flow INVITE CSeq: $cseq\n";
      for my $i (0 .. $#{$call_summary{$cid}{INV}{$cseq}{from_ip}}) {
        print TMP "\t\tFrom IP: ".$call_summary{$cid}{INV}{$cseq}{from_ip}[$i]; 
        print TMP "\t\tTo IP: ".$call_summary{$cid}{INV}{$cseq}{to_ip}[$i]; 
        print TMP "\t\tPhase: ".$call_summary{$cid}{INV}{$cseq}{phase}[$i]."\n";
      }
      foreach $via (keys %{$call_summary{$cid}{INV}{$cseq}{resp_code}}) {
        print TMP "\t\t\tVia:$via  Response Code:$call_summary{$cid}{INV}{$cseq}{resp_code}{$via}\n";
      }
    }
    foreach $cseq (keys(%{$call_summary{$cid}{response}})) {
      print TMP "Call flow Response CSeq: $cseq\n";
      for my $i (0 .. $#{$call_summary{$cid}{response}{$cseq}{from_ip}}) {
        print TMP "\t\tFrom IP: ".$call_summary{$cid}{response}{$cseq}{from_ip}[$i];
        print TMP "\t\tTo IP: ".$call_summary{$cid}{response}{$cseq}{to_ip}[$i];
        print TMP "\t\tcode: ".$call_summary{$cid}{response}{$cseq}{code}[$i]."\n";
        print TMP "\t\tVia: ".$call_summary{$cid}{response}{$cseq}{via}[$i]."\n";
      }
    }    
    print TMP "\t";
    print TMP "\n";
  }
  print TMP "-----------------------------------------\n\n";
}

sub toggle_call_diagram {
  if ($display_mode eq "diagram") {
    $display_mode = "call summary";
    change_cl_view(0);
    clear_screen();
    cl_refresh_header();
    cl_paint_all();
  } else {
    $display_mode = "diagram";
    # Remove the Call-ID and GSID filters
    filter_call_summary(0);
    clear_screen();
    dg_paint_all();
  }
  change_mode($capture_mode,$display_mode);
}

sub toggle_full_screen {
  return if $prev_display_mode ne "details";
  if ($full_screen_details) {
    $full_screen_details = 0;
  } else {
    $full_screen_details = 1;
  }
  # Do not change the display mode (still in "details")
  $prev_display_mode = "diagram";
  dg_paint_all();
  view_details();
}

sub cl_paint_all {
  if ($need_resize) {
    display_message();
    return;
  }
  display_cl_records();
}

sub display_cl_records {
  my $cl_record_no = scalar (@display_cl_record);
  lock($cl_top_pos);lock($cl_rec_pos);

  for my $i ( $cl_top_pos .. $cl_top_pos+$max_row-5 ) {
    if (defined($display_cl_record[$i]) && $i == $cl_rec_pos) {
      cl_display_line($i, 1); 
    } else {
      cl_display_line($i, 0);
    }
  }
  $cl_need_refresh = 0;
}

sub cl_display_line {
  my ($y, $reverse) = @_;
  my $line;
  if (!($throttle)) {
    # Pause for 0.0001 seconds to avoid high CPU usage
    select(undef, undef, undef, 0.0001);
  }

  goto_xy(0,$y+3-$cl_top_pos);
  if ($reverse) {
    $line = generate_cl_line($y,"reverse");
  } else {
    $line = generate_cl_line($y,"");
  }
  print $line;
}

sub generate_cl_line {
  my ($index,$reverse) = @_;
  my $line = "";
#($start) = `date +%T.%N` =~ /(\d+\.\d+)/;
  # check if it is an empty line
  if ($index+1 > scalar(@display_cl_record)) {
    for (my $i=0; $i<scalar(@cl_column_width); $i++) {
      my $last_column = ($i == scalar(@cl_column_width)-1 ? 0 : 1);
      $line .= " " x ($cl_column_width[$i]-$last_column);
      if ($last_column == 1) {
        $line .= $vert_chr;
      }
    }
    return $line;
  }

  my $session_num = $display_cl_record[$index]{number};
  if ($reverse eq "" && $session_num ne "NA" && $session_num eq $display_cl_record[$cl_rec_pos]{number}) {
    $reverse = "bold";
  } 

  # line with content
  for (my $i=0; $i<scalar(@cl_column_width); $i++) {
    my $label = $display_cl_record[$index]{$cl_colum_keys[$i]};
    if ($cl_colum_keys[$i] eq state) {
      $label = get_state($index,$reverse);
    } elsif ($cl_colum_keys[$i] eq call_flow) {
       if ($display_cl_record[$index]{call_flow_refresh}) {
         $display_cl_record[$index]{call_flow} = get_call_flow($index,"");
         $label = $display_cl_record[$index]{call_flow};
         $display_cl_record[$index]{call_flow_refresh} = 0;
       }
       if ($reverse eq "reverse") {
         $label = reverse_color_string($label);
       } elsif ($reverse eq "bold") {
         $label = bold_color_string($label);
       }
    } elsif ($cl_colum_keys[$i] eq no_msgs) {
      my $num_messages = $display_cl_record[$index]{no_msgs_external};
      if ($show_asm) {
        $num_messages += $display_cl_record[$index]{no_msgs_internal};
      }
        
      $label = $session_num."/".$calls{$display_cl_record[$index]{cid}}{number}."/".$num_messages;
    }
    my $len = length_no_color($label);
    my $last_column = ($i == scalar(@cl_column_width)-1 ? 0 : 1);
    # Truncate the string to fit into the column
    if ($len > $cl_column_width[$i]-$last_column) {
      $label = colored(substr_color($label,0,$cl_column_width[$i]-1-$last_column),$reverse).colored(">",$reverse);
    } else {
      $label = colored(" " x ($cl_column_width[$i]-$last_column-$len),$reverse).colored($label,$reverse);
    }
    $line .= $label;
    if ($last_column == 1) {
      $line .= colored($vert_chr,$reverse); 
    }
  }
#($end) = `date +%T.%N` =~ /(\d+\.\d+)/;;
#printf TMP "$start $end Elapsed time: %.3f seconds!\n", $end - $start; 
  return $line;  
}

sub get_state {
  my ($index,$reverse) = @_;
  my $label = $display_cl_record[$index]{state}." - ".$display_cl_record[$index]{state_detail};
  my $color = "green";
  if ($display_cl_record[$index]{state} eq "Rejected") {
    $color = "red";
  } elsif ($display_cl_record[$index]{state} eq "Early") {
    $color = "yellow";
  } elsif ($display_cl_record[$index]{state} eq "Canceled") {
    $color = "blue";
  } 
  return colored($label,"$color $reverse");
}

sub get_call_flow {
  my ($index,$reverse) = @_;
  my $phase = "";
  my $label = "";
  my $last_cseq = "";

  for $cseq (sort {$a<=>$b} keys %{$display_cl_record[$index]{INV}}) {
    my $last_to_ip = "";
    my $response_count = 0;
    next if !exists($display_cl_record[$index]{INV}{$cseq});
    for my $i (0 .. $#{$display_cl_record[$index]{INV}{$cseq}{from_ip}}) {
      my $from_ip = $display_cl_record[$index]{INV}{$cseq}{from_ip}[$i];
      my $to_ip = $display_cl_record[$index]{INV}{$cseq}{to_ip}[$i];
      my $phase = "";
      $phase = "[".$display_cl_record[$index]{INV}{$cseq}{phase}[$i]."]" if $display_cl_record[$index]{INV}{$cseq}{phase}[$i] ne "";
      my $color_from = "cyan";
      $color_from = "" if $from_ip eq $asm_ip || $from_ip eq $sm100_ip || $from_ip eq $asm_ipv6 || $from_ip eq $sm100_ipv6;
      my $color_to = "cyan";
      $color_to = "" if $to_ip eq $asm_ip || $to_ip eq $sm100_ip || $to_ip eq $asm_ipv6 || $to_ip eq $sm100_ipv6; 

      # Add the INVITE
      if ($last_to_ip eq $from_ip) {
        if ($show_asm || ($to_ip ne $asm_ip && $to_ip ne $asm_ipv6 && $to_ip ne "127.0.0.1" && $to_ip ne "::1" && $to_ip ne "127.0.0.2" && $to_ip ne "::2")) {
          $label .= colored($phase,"$color_from $reverse").colored("->".($display_name?get_ip_name($to_ip):$to_ip),"$color_to $reverse");
          $last_to_ip = $to_ip;
        }  
      } else {
	if ($show_asm || (($to_ip ne $asm_ip && $to_ip ne $asm_ipv6 && $to_ip ne "127.0.0.1" && $to_ip ne "::1" && $to_ip ne "127.0.0.2" && $to_ip ne "::2") && ($from_ip ne $asm_ip && $from_ip ne $asm_ipv6 && $from_ip ne "127.0.0.1" && $from_ip ne "::1" && $from_ip ne "127.0.0.2" && $from_ip ne "::2"))) {
          if ($last_cseq == $cseq) {
            $label .= colored(" ",$reverse);
          }
          $label .= colored(($display_name?get_ip_name($from_ip):$from_ip).$phase,"$color_from $reverse").colored("->".($display_name?get_ip_name($to_ip):$to_ip),"$color_to $reverse");
          $last_to_ip = $to_ip;
        }   
      }

      # Add responses
      my $resp_code = "";
      if (($show_asm || (($to_ip ne $asm_ip && $to_ip ne $asm_ipv6 && $to_ip ne "127.0.0.1" && $to_ip ne "::1" && $to_ip ne "127.0.0.2" && $to_ip ne "::2")  && ($from_ip ne $asm_ip && $from_ip ne $asm_ipv6 && $from_ip ne "127.0.0.1" && $from_ip ne "::1" && $from_ip ne "127.0.0.2" && $from_ip ne "::2"))) && exists($display_cl_record[$index]{INV}{$cseq}{resp_code}{$display_cl_record[$index]{INV}{$cseq}{via}[$i]})) {
        $resp_code = $display_cl_record[$index]{INV}{$cseq}{resp_code}{$display_cl_record[$index]{INV}{$cseq}{via}[$i]};
      }
      if ($resp_code ne "") {
        if ($resp_code == 200) {
          $color = "green";
        } else {
          $color = "red";
        }
        #$label .= colored("(",$reverse).colored($resp_code,$color.' '.$reverse).colored(")",$reverse);
        $label .= colored("(".$resp_code.")",$color.' '.$reverse);
      }
      $last_cseq = $cseq; 
    }
    $label .= colored(" ",$reverse);
  }
  return $label;
}

# Return the length of the string not counting the color (escaped) characters
sub length_no_color {
  $no_color_string = shift;

  # color is encoded with an ESC (27) and ends with m (109) 
  $no_color_string =~ s/\e(.*?m)//g;
  return length($no_color_string);
}

sub reverse_color_string {
  my ($color_string) = @_;

  $color_string =~ s/(\e\[[\d;]*m)/\e\[7m$1\e\[7m/g;
  return $color_string;
}

sub bold_color_string {
  my ($color_string) = @_;

  $color_string =~ s/(\e\[[\d;]*m)/\e\[1m$1\e\[1m/g;
  return $color_string;
}

sub substr_color {
  my ($color_string, $start, $len) = @_;
  # get an array with only the text, and another with the colors
  my @non_color_string = split(/\e\[[\d;]*m/,$color_string);
  my @color_att = ($color_string =~ /\e\[[\d;]*m/g);

  my $substr = "";
  my $curr_len = 0;
  my $started = 0;
  for (my $i=0; $i<scalar(@non_color_string); $i++) {
    $curr_len += length($non_color_string[$i]);
    next if $curr_len < $start;
    if (!$started) {
      $non_color_string[$i] = substr($non_color_string[$i],$start-($curr_len-length($non_color_string[$i])));
      $started = 1;
    }
    if ($curr_len <= $len) {
      $substr .= $non_color_string[$i].$color_att[$i];
      next;
    } else {
      $substr .= substr($non_color_string[$i],0,-($curr_len-$len));
      if ($i % 2) {
        $substr .= $color_att[$i];
      }
      last;
    }
  }
  return $substr;
}

sub calulate_cl_column_width {
  @cl_column_width = @cl_column_width_min;
  
  my $w = get_cl_column_width();
  return if $w > $max_col;
  my $i = 0;
  my $no_columns = scalar(@cl_column_width);
  while ($w < $max_col) {
    if ($cl_column_width_max[$i % $no_columns] == $cl_column_width[$i % $no_columns]) {
      $i++;
      next;
    }
    $cl_column_width[$i % $no_columns]++;
    $w = get_cl_column_width();
    $i++; 
  }    
}

sub get_cl_column_width {
  my $w = 0;
  foreach (@cl_column_width) { $w += $_ };
  return $w;
}

sub cl_refresh_header {
  my $high_line;
  my $title_line;
  my $low_line;

  calulate_cl_column_width();

  for ($i=0; $i<scalar(@cl_column_width); $i++) {
    $high_line .= $line_chr x ($cl_column_width[$i]-1);
    my $column_label = " " x (($cl_column_width[$i]-1)/2-length($cl_colum_name[$i])/2).$cl_colum_name[$i];
    $title_line .= $column_label." " x (($cl_column_width[$i]-1)-length($column_label));
    $low_line .= $line_chr x ($cl_column_width[$i]-1);
    if ($i != scalar(@cl_column_width)-1) {
      $high_line .= $vert_sep_l_chr;
      $title_line .= $vert_chr; 
      $low_line .= $vert_horiz;
    } else {
      $high_line .= $line_chr;
      $title_line .= " "; 
      $low_line .= $line_chr;
    } 
  }
  goto_xy(0,0);
  print "$high_line\n";
  print "$title_line\n";
  print "$low_line\n";
    
}

sub cl_init_positions {
  $pos = shift;
  lock($cl_top_pos);lock($cl_rec_pos);
  my $cl_record_no = keys(%call_summary);

  if ($pos eq "top") {
    $cl_rec_pos = $cl_record_no?0:-1;
    $cl_top_pos = 0;
    $prev_cl_rec_pos = $cl_rec_pos;
    $prev_cl_top_pos = $cl_top_pos;
    $prev_cl_record_no = $cl_record_no;
  } elsif ($pos eq "bottom") {
    $prev_cl_rec_pos = 1;
    $prev_cl_top_pos = 1;
    $prev_cl_record_no = $cl_record_no;
    $cl_top_pos = max($cl_record_no-1-($max_row-5),0);
    $cl_rec_pos = max($cl_record_no-1,0);
    $prev_cl_rec_pos = $cl_rec_pos;
  }
  $cl_view = 0;
}

sub filter_call_summary {
  my $filter = shift;
  my $w = 30;
  my $h = 3;
  my ($x, $y);

  $display_mode = "filter call summary";
  create_box($w,$h);
  $x = ($max_col - $w-2)/2 + 1;
  $y = $dg_top_margin + ($max_row-$dg_top_margin-1 - $h-2)/2 + 2;
  goto_xy($x, $y);
  print "       Please wait...";

  # Apply the Call-ID or GSID filer
  if ($filter) {
    my $my_gsi = $display_cl_record[$cl_rec_pos]{gsi};

    $global_session_id = $my_gsi;
    if ($my_gsi) {
      $call_id = "";
      create_gsi_call_id_filter($my_gsi);
    } else {
      $call_id = $display_cl_record[$cl_rec_pos]{cid};
      $gsi_call_id = "";
    }
    $display_asm = 0;

  # Remove the filter
  } else {
    # Remove Call-ID and Global Session ID filters
    $global_session_id = "";
    $gsi_call_id = "";
    $call_id = "";
  }
  change_mode($capture_mode,$display_mode);
  refilter();
}

sub update_session_number {
  my ($my_gsi,$my_cid) = @_;

  my $session_number = $call_summary{$my_cid}{number};
 
  get_related_call_ids($my_gsi);

  # Change all related Call-IDs
  foreach $cid (keys %result_call_id) {
    $call_summary{$cid}{number}=$session_number;
  }
}

sub get_related_call_ids {
  my $my_gsi = shift;

  %result_call_id = ();
  %visited_gsi = ();

  get_recursive_call_id($my_gsi);

  # For each of the found call-ids, look if there is a non visisted GSI
  foreach $cid (keys %result_call_id) {
    foreach $gsi (keys %{$calls{$cid}{global_session_id}}) {
      get_recursive_call_id($gsi) if $gsi ne "" && !exists($visited_gsi{$gsi});
    }
  }

#  # For each of the found call-ids, look if there is a non visisted GSI
#  START_OVER:
#  foreach $gsi (keys %sessions) {
#    next if exists($visited_gsi{$gsi});
#    foreach $cid (keys %{$sessions{$gsi}{call_id}}) {
#      if (exists($result_call_id{$cid})) {
#print TMP "trying call-id $calls{$cid}{number} $gsi\n";
#        get_recursive_call_id($gsi);
#        # Agly code using goto. If a new call_id is added, then need to check all again
#        goto START_OVER;
#      }
#    }
#  }

}

sub create_gsi_call_id_filter_from_regexp {
  my $regex_gsi = shift;

  $gsi_call_id = ""; 
  foreach $gsi (keys %sessions) {
    if ($gsi =~ /$regex_gsi/) { 
      get_related_call_ids($gsi);
      $gsi_call_id .= join("|",keys %result_call_id)."|";
    }
  }
  chop($gsi_call_id);
}

sub create_gsi_call_id_filter {
  my $my_gsi = shift;

  $gsi_call_id = "";
  get_related_call_ids($my_gsi);

  $gsi_call_id = join("|",keys %result_call_id);
}

sub get_recursive_call_id {
  my $gsi = shift;

  return if !exists($sessions{$gsi});
#print TMP "get_recursive_call_id $gsi $sessions{$gsi}\n";
#printstack();
#STDERR->fdopen( \*TMP,  'w' ) or die $!;
  my $agsi = $sessions{$gsi}{agsi};

  # mark visited gsi
  return if exists($visited_gsi{$gsi});
  $visited_gsi{$gsi} = 1;

  # Add the direct GSI call_ids
  foreach (keys %{$sessions{$gsi}{call_id}}) {
#print TMP "added direct $calls{$_}{number}\n";
    $result_call_id{$_}=1;
  }

  # Add associated call_ids
  foreach (keys %sessions) {
    if ($_ eq $agsi || $sessions{$_}{agsi} eq $gsi) {
#print TMP "going recur $_ gsi $gsi\n";
      get_recursive_call_id($_);
    }
  }
}

sub change_cl_view {
  $cl_view = shift;
  # cl_view = 0 displays all the columns (time, from, to, etc...)
  # cl_view = 1 displays only time and call_flow
  if (!$cl_view) {
    @cl_colum_name = ("Time", "From", "To", "Request-URI", "State", "Ses/Call/Mgs", "Call flow");
    @cl_colum_keys = (start_time, from, to, request_uri, state, no_msgs, call_flow);
    @cl_column_width_max = (13, 18, 18, 30, 30, 13, 1000);
    @cl_column_width_min = (13, 10, 10, 10, 10, 13, 7);
  } else {
    #@cl_colum_name = ("Time", "Call flow");
    #@cl_colum_keys = (start_time, call_flow);
    #@cl_column_width_max = (13, 1000);
    #@cl_column_width_min = (13, 7);
    @cl_colum_name = ("Time", "Ses/Call/Mgs", "Call flow");
    @cl_colum_keys = (start_time, no_msgs, call_flow);
    @cl_column_width_max = (13, 13, 1000);
    @cl_column_width_min = (13, 13, 15);
  }
}

sub file_type {
  my $filename = shift @_;

#print TMP "file: $filename\n";
  $result = `grep "com.avaya.asm  SIPMSGT " -m 1 -c "$filename"`;
  chop($result);
#print TMP "result: $result\n";
  if ($result eq "1") {
#print TMP "File type: asset\n";
    return "asset";
  } else {
    $result = `grep -P "(FINE|FINER|DEBUG) \\[com.avaya.ccs.ppm" -m 1 -c "$filename"`;
    chop($result);
#print TMP "result $result\nfilename $filename\n";
    if ($result eq "1") {
      return "ppm";
#print TMP "File type: ppm\n";
    } else {
      $result = `grep -P ' DBH:     SIGNAL: \\[\\S+\\] (RECEIVED|SENT)' -m 1 -c "$filename"`;
      chop($result);
      if ($result eq "1") {
#print TMP "File type: onexc\n";
        return "onexc";
      } else {
        $result = `grep -P '\\] (RECEIVED|SENDING) \\d+ bytes (from|to) .* {' -m 1 -c "$filename"`;
        chop($result);
        if ($result eq "1") {
#print TMP "File type: IOS\n";
          return "ios";
        } else {
          $result = `grep -P 'Frame \\d+: \\d+ bytes on wire .* bytes captured' -m 1 -c "$filename"`;
          chop($result);
            if ($result eq "1") {
#print TMP "File type: TLS\n";
              return "tls";
            } else {
              $result = `grep "SIPMSGT" -m 1 -c "$filename"`;
              chop($result);
#print TMP "result: $result\n";
              if ($result eq "1") {
#print TMP "File type: asset\n";
                return "asset";
              } else {
		$result = `grep "pushnotification.ApplePushNotification FINE - PUSH_NOTIFICATION" -m 1 -c "$filename"`;
                chop($result);
                if($result eq "1") {
                  return "push";
                } else {
#print TMP "File type: asm\n";
                return "asm";
              }
            }
          }
        }
      }
    }
  } 
}

sub printstack {
  my $i = 1;
  for (;;) {
    my ($package, $filename, $line, $subroutine) = caller($i);
    last if (!defined(scalar caller($i))); 
    print TMP "Subroutine: $subroutine; Line: $line; Arg: ${DB::args[0]}\n";
    $i++;
  }
}

sub read_metadata {
  my $line = shift;
  if ($line =~ /^name_ip: (.*);$/) {
    my @tuple = split(";", $1);
    foreach (@tuple) {
      (my $ip, my $name) = split("->", $_);
      $name_ip{$ip} = $name;
    }
  }
}

sub first_time_cygwin_old_install {
  my $error = 0;
  # Check for the termcap package
  if (! -f "/etc/termcap") {
    print "ERROR: Cygwin termcap package must be installed first. Run the Cygwin setup.exe and install the \"termcap\" package\n";
   $error = 1;
  }

  my $stddef_file = `find /usr/lib/gcc -name 'stddef.h' -print -quit`;
  chomp($stddef_file);
  if ($stddef_file eq "") {
    print "ERROR: Cygwin gcc-core package must be installed first. Run the Cygwin setup.exe and install the \"gcc-core\" package\n";
    $error = 1; 
  }
  exit() if $error;

  # Save current dir
  my $curr_dir = `pwd`;
  chomp $curr_dir;

  # Get the first Perl lib directory to place the header files
  $perlib = $INC[0];

  my $in = '/usr/include';
  chdir($in) or die "ERROR: cannot chdir to $in: $!"; 
  @conv_inc_headers = ("h2ph", "-Q", "-d", "$perlib", "_ansi.h", "newlib.h", "stdint.h", "endian.h", "byteswap.h");
#  @conv_inc_headers = ("h2ph", "$in/_ansi4.h", "$in/newlib.h", "$in/stdint.h", "$in/endian.h", "$in/byteswap.h", "$in/sys/ioctl.h", "$in/sys/cdefs.h", "$in/sys/termios.h", "$in/sys/types.h", "$in/sys/_ansi.h", "$in/sys/_types.h", "$in/sys/config.h", "$in/sys/features.h", "$in/sys/sysmacros.h", "$in/sys/lock.h");
  system(@conv_inc_headers) == 0 or die "ERROR: when running \"@conv_inc_headers\": $?"; 

  $in = '/usr/include/sys';
  if (! -d "$perlib/sys") {
    mkdir("$perlib/sys") or die "ERROR: cannot mkdir $perlib/sys: $!";
  }
  chdir($in) or die "ERROR: cannot chdir to $in: $!";
  @conv_inc_headers = ("h2ph", "-Q", "-d", "$perlib/sys", "ioctl.h", "cdefs.h", "termios.h", "types.h", "_types.h", "config.h", "features.h", "sysmacros.h", "lock.h");
  system(@conv_inc_headers) == 0 or die "ERROR: when running \"@conv_inc_headers\": $?"; 

  $in = '/usr/include/bits';
  if (! -d "$perlib/bits") {
    mkdir("$perlib/bits") or die "ERROR: cannot mkdir $perlib/bits: $!";
  }
  chdir($in) or die "ERROR: cannot chdir to $in: $!";
  @conv_inc_headers = ("h2ph", "-Q", "-d", "$perlib/bits", "endian.h", "wordsize.h");
  system(@conv_inc_headers) == 0 or die "ERROR: when running \"@conv_inc_headers\": $?"; 

  open(WORDSIZE_FILE, ">", "wordsize.ph") or die "ERROR: Cannon open wordsize.ph: $!"; 
  print WORDSIZE_FILE "$wordsize_file";
  close WORDSIZE_FILE;

  $in = '/usr/include/machine';
  if (! -d "$perlib/machine") {
    mkdir("$perlib/machine") or die "ERROR: cannot mkdir $perlib/machine: $!";
  }
  chdir($in) or die "ERROR: cannot chdir to $in: $!";
  @conv_inc_headers = ("h2ph", "-Q", "-d", "$perlib/machine", "ieeefp.h", "_types.h", "types.h", "_default_types.h");
  system(@conv_inc_headers) == 0 or die "ERROR: when running \"@conv_inc_headers\": $?";

  $in = '/usr/include/cygwin';
  if (! -d "$perlib/cygwin") {
    mkdir("$perlib/cygwin") or die "ERROR: cannot mkdir $perlib/cygwin: $!";
  }
  chdir($in) or die "ERROR: cannot chdir to $in: $!";
  @conv_inc_headers = ("h2ph", "-Q", "-d", "$perlib/cygwin", "config.h", "types.h");
  system(@conv_inc_headers) == 0 or die "ERROR: when running \"@conv_inc_headers\": $?";

  my ($file_name, $dir) = fileparse($stddef_file);
  chdir($dir) or die "ERROR: cannot chdir to $dir: $!";
  @conv_inc_headers = ("h2ph", "-Q", "-d", "$perlib", "$file_name");
  system(@conv_inc_headers) == 0 or die "ERROR: when running \"@conv_inc_headers\": $?";

  
  chdir($curr_dir);

  require 'sys/ioctl.ph'
}

sub audit {
  my $msg = shift;
  return if $is_old_cygwin or $is_new_cygwin or $is_mac;
  $user = $ENV{SUDO_USER};
  $user = (getpwuid($<))[0] if $user eq "";
  $msg =~ s/\n/ /g;
  print AUDIT localtime()." - ".$user.":$$ - $msg\n";
}

sub is_ipv4 {
  my $ip = shift;
  return $ip =~ /\./;
}

sub init_regex_IPv6 {
  # This was literally taken from the Perl module Regexp::IPv6 to avoid importing a new module
  # the license seems to allow it
  my $IPv4 = "((25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))";
  my $G = "[0-9a-fA-F]{1,4}";

  my @tail = ( ":",
             "(:($G)?|$IPv4)",
             ":($IPv4|$G(:$G)?|)",
             "(:$IPv4|:$G(:$IPv4|(:$G){0,2})|:)",
             "((:$G){0,2}(:$IPv4|(:$G){1,2})|:)",
             "((:$G){0,3}(:$IPv4|(:$G){1,2})|:)",
             "((:$G){0,4}(:$IPv4|(:$G){1,2})|:)" );

  $IPv6_re = $G;
  $IPv6_re = "$G:($IPv6_re|$_)" for @tail;
  $IPv6_re = qq/:(:$G){0,5}((:$G){1,2}|:$IPv4)|$IPv6_re/;
  $IPv6_re =~ s/\(/(?:/g;
}

sub set_start_capture_time {
  # We need to save the current file sizes. Need this info
  # in case the user wants to save all the logs since the beginning
  # of the caputre as we need to save from now on (discard previous log
  # entries the log may have)

  foreach (keys %log_file) {
    my $sb = stat("$trace_dir$log_file{$_}");
    if (-f "$trace_dir$log_file{$_}") {
      $start_capture_file_data{$log_file{$_}}{size} = $sb->size;
    } else {
      $start_capture_file_data{$log_file{$_}}{size} = 0;
    }
  }
#print TMP Dumper(%start_capture_file_data);

  $start_capture_time = time();
}

sub notify_user_wireshark_missing {
  my $w = 55;
  my $h = 4;
  my ($x, $y, $answer);

  $display_mode = "write";
  create_box($w,$h);
  $x = ($max_col - $w-2)/2 + 1;
  $y = $dg_top_margin + ($max_row-$dg_top_margin-1 - $h-2)/2 + 1;

  goto_xy($x, $y++);
  print "   TLS capture will not work without tshark. Please";
  goto_xy($x, $y++);
  print "      install wireshark for TLS capture to work.";
  $y++;
  
  goto_xy($x, $y);
  print "          Press any key to close this message. ";

  # display the cursor and change to normal keyboard mode
  set_keyboard(1);
  $answer = <STDIN>;
}

sub notify_user_wireshark_missing_pcapng_wont_work {
  my $w = 55;
  my $h = 6;
  my ($x, $y, $answer);

  $display_mode = "write";
  create_box($w,$h);
  $x = ($max_col - $w-2)/2 + 1;
  $y = $dg_top_margin + ($max_row-$dg_top_margin-1 - $h-2)/2 + 1;

  goto_xy($x, $y++);
  print "   pcapng file won't be created. Please install";
  goto_xy($x, $y++);
  print "      wireshark for pcapng conversion to work.";
  goto_xy($x, $y++);
  print "      TGZ will be created without pcapng file.";
  $y++;
  
  goto_xy($x, $y);
  print "          Press any key to close this message. ";

  # display the cursor and change to normal keyboard mode
  set_keyboard(1);
  $answer = <STDIN>;
}

sub notify_user_pcap_conversion_failed {
  my $w = 55;
  my $h = 6;
  my ($x, $y, $answer);

  $display_mode = "write";
  create_box($w,$h);
  $x = ($max_col - $w-2)/2 + 1;
  $y = $dg_top_margin + ($max_row-$dg_top_margin-1 - $h-2)/2 + 1;

  goto_xy($x, $y++);
  print "             Pcapng conversion failed.";
  goto_xy($x, $y++);
  print "      TGZ will be created without pcapng file.";
  $y++;
  
  goto_xy($x, $y);
  print "          Press any key to close this message. ";

  # display the cursor and change to normal keyboard mode
  set_keyboard(1);
  $answer = <STDIN>;
}

sub build_jboss_cli_cmd_arg {
  my $operation = shift;
  my $pkg_list = shift @_;
  $arg_list = "\"";
  foreach my $pkg (@$pkg_list) {
    $arg_list = $arg_list."/subsystem=logging/logger=$pkg:$operation,";
  }
  return $arg_list."\"";
}

sub is_sip_file_based_log_running {
  if (-d "/var/lock/subsys/sip_trace.lockdir") {
    return 1;
  } else {
    return 0;
  }
}

sub notify_user_write_blocked {
  my $w = 55;
  my $h = 6;
  my ($x, $y, $answer);

  $display_mode = "write";
  create_box($w,$h);
  $x = ($max_col - $w-2)/2 + 1;
  $y = $dg_top_margin + ($max_row-$dg_top_margin-1 - $h-2)/2 + 1;

  goto_xy($x, $y++);
  print "         Logs can not be saved when always ON";
  goto_xy($x, $y++);
  print "                SIP logging is enabled.";
  $y++;
  
  goto_xy($x, $y);
  print "          Press any key to close this message. ";

  # display the cursor and change to normal keyboard mode
  set_keyboard(1);
  $answer = <STDIN>;
}

########## PUSH NOTIFICATION SECTION  ##############
sub start_push_notification_capture_cmd {
  my $log4jprops = "$sm_conf_dir/log4j.properties";
  if (-w $log4jprops) {
  `sed -i "s/log4j.logger.com.avaya.asm.callprocessing.pushnotification.ApplePushNotification=INFO, PUSH_NOTIFICATION_LOGGER/log4j.logger.com.avaya.asm.callprocessing.pushnotification.ApplePushNotification=FINEST, PUSH_NOTIFICATION_LOGGER/" $log4jprops`;
  } else {
    die_message("Cannot open log4j.properties file: $log4jprops");
  }
}

sub stop_push_notification_capture_cmd {
  my $log4jprops = "$sm_conf_dir/log4j.properties";
  if (-w $log4jprops) {
  `sed -i "s/log4j.logger.com.avaya.asm.callprocessing.pushnotification.ApplePushNotification=FINEST, PUSH_NOTIFICATION_LOGGER/log4j.logger.com.avaya.asm.callprocessing.pushnotification.ApplePushNotification=INFO, PUSH_NOTIFICATION_LOGGER/" $log4jprops`;
  } else {
    die_message("Cannot open log4j.properties file: $log4jprops");
  }
}

sub start_push_notification_capture {
  start_push_notification_capture_cmd();
}

sub stop_push_notification_capture {
#printstack();
  stop_push_notification_capture_cmd();
}

sub is_push_notification_capture_started {
  my $log4jprops = "$sm_conf_dir/log4j.properties";
  if (-f $log4jprops) {
    return `egrep "log4j.logger.com.avaya.asm.callprocessing.pushnotification.ApplePushNotification=FINEST, PUSH_NOTIFICATION_LOGGER" $log4jprops 2>&1`;
  } else {
    return 0;
  }
}

sub process_push_notification_file {
  my($file, $file_name) = @_;
  my $in_multiline = "";
  my $max_dg_records = $max_packets;  # Stop the capture if there are more than 10000 packets
  my $file_size = -s $file_name;
  undef(%message);
  binmode STDOUT, ':utf8';
  my $prev_time = 0;
  my $window_time = 0;
  my $window_pos = 0;
  my $per_complete = 0;
  my $eta = -1;
  my @perf_history;
  my $full_file_name = $file_name;
  $file_name = basename($file_name);
  my $inode = stat($file)->ino;
  my $count = 0;
  my $curpos = 0;
  my $start_line = 0;
  my $in_msg = 0;
  my $sm100_ip = "Unknown";

  my $ipv4 = `ip addr show | grep eth1 | grep "inet " | grep secondary -v`;
  if ($ipv4 =~ /^.*inet (\d+\.\d+\.\d+\.\d+).*$/) {
    $sm100_ip = $1;
  }

  for (;;) {
#print TMP "max_exceeded: $max_exceeded\n";
    if (!$max_exceeded) {
      for ($curpos = tell($file); $_ = <$file>; $curpos = tell($file)) {
        if (/^(\d+[-\/]\d+[-\/]\d+) (\d{2}:\d{2}:\d{2}[,\.]\d{3}) pushnotification.ApplePushNotification FINE - PUSH_NOTIFICATION Sending HTTP POST for push notification for (.*)/) {
          $message{day} = $1;
          $message{timestamp} = $2;
          $message{user} = $3;
          $start_line = 1;
          $message{apns_id} = "None";
          $message{type} = "PUSH_NOTIFICATION_REQ";
	  $in_msg = 1;
        } elsif (/^(\d+[-\/]\d+[-\/]\d+) (\d{2}:\d{2}:\d{2}[,\.]\d{3}) pushnotification.ApplePushNotification FINE - PUSH_NOTIFICATION Received HTTP POST response for push notification for (.*)/) {
          $message{day} = $1;
          $message{timestamp} = $2;
          $message{user} = $3;
          $message{apns_id} = "None";
          $message{type} = "PUSH_NOTIFICATION_RESP";
          $start_line = 1;
        } elsif (/^(\d+[-\/]\d+[-\/]\d+) (\d{2}:\d{2}:\d{2}[,\.]\d{3}) pushnotification.ApplePushNotification ERROR - PUSH_NOTIFICATION Failed (.*)/) {
          # TO DO
        } elsif (/----------/) {
          next if(!%message);
          # Get the Call-ID header
          if ($message{apns_id} eq "None") {
            $invalid_apns_id = "apns-id not availale";
            $message{apns_id} = $invalid_apns_id;
            $apns_tx{$invalid_apns_id} = &share({});
            $apns_tx{$invalid_apns_id}{number} = keys(%apns_tx);
          } else {
            if (!exists($apns_tx{$message{apns_id}})) {
              $apns_tx{$message{apns_id}} = &share({});
              $apns_tx{$message{apns_id}}{number} = keys(%apns_tx);
              $apns_tx{$message{apns_id}}{user} = "user";
            }
          }
          $message{local_host} = $sm100_ip;
          $message{host} = "APNP";
          process_push_notification_packet(\%message);
          undef(%message);
          $in_msg = 0;
          $start_line = 0;
        } elsif ($start_line) {
          $message{message} .= $_;
          $message{start_line} .= $_;
	  $start_line = 0;
        } else {
	  $start_line = 0;
          if($message{type} eq "PUSH_NOTIFICATION_REQ") {
            if(/av-notification before encryption: {"content":(.*),"contentType"/) {
              $message{label} = "POST";
              $message{desc} = "User='$message{user}', $1";
            } elsif(/{"aps":{"alert"/) {
              $message{message} .= "\n$_";
            } else {
              $message{message} .= $_;
            }
          } else {
            $message{message} .= $_;
          }

          if(/apns-id: (.*)/) {
            $message{apns_id} = $1;
          }
        }
 
        # Slow down if throttle is enabled (default)
        if (!($throttle)) {
          # Pause for 0.0001 seconds to avoid high CPU usage
          select(undef, undef, undef, 0.0001);
        }
        # Display percentage and remainding time
        if ($capture_mode eq "opening_file" && (time() - $prev_time > 1)) {
          if ($file_size != 0) {
            $per_complete = $curpos * 100 / $file_size;
          } else {
            $per_complete = 100;
          }
  
          $his{pos} = $curpos;
          $his{time} = time();
          push(@perf_history,{%his});
          $eta = -1;
          if (scalar(@perf_history) > 5) {
            $hist = shift(@perf_history);
            
            $window_time = time() - $hist->{time};
            $window_pos = $curpos - $hist->{pos};
            if ($window_pos != 0) {
              $eta = ($file_size-$curpos)*$window_time/$window_pos;
            }
          }
  
          if ($eta == -1) {
            $eta = "n/a";
          } else { 
            my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = gmtime($eta);
            $eta = sprintf("%02d:%02d:%02d", $hour+($mday-1)*24, $min, $sec);
          }
          $label = "Opening ".$file_name." (".int($per_complete)."%  ETA: ".$eta.")";
          my $w = length($label);
          my $h = 1;
          display_text_box($w,$h,$label);
          $prev_time = time();
        }
      }
    } else {
      seek($file, 0, SEEK_END);
      $curpos = tell($file);
    }
    $count++;
    # This is to simulate a 'tail -f'
    sleep(1);
    my $dg_record_no = scalar (@dg_records);

    # Refresh the call summary screen
    if ($display_mode eq "call summary" && $cl_need_refresh) {
      cl_paint_all();
    }

    # update the window title
    set_title();
    if ($tail_log) {
      seek($file, $curpos, 0);

      # Check if log file has rotated (using inode) and we have finsihed
      # processing the complete file (using the file size -s)
      # The log rotation is done by log4j
      if ($inode != stat($full_file_name)->ino && (-s $file) == $curpos) {
        close($file);
        open(FILE, "$full_file_name") || die_message("Can't open $full_file_name file.\nERROR: $!\n");
        $file = \*FILE;
        $inode = stat($file)->ino;
      }
    } else {
      last;
    }
    # To prevent the capture to run forever, 
    # stop after 10k packets.
    if ( $dg_record_no > $max_dg_records ) {
      $max_exceeded = 1;
    }
  }
}

sub process_push_notification_packet {
  my $params = shift;
  my %message = %$params;
  if($message{type} eq "PUSH_NOTIFICATION_RESP") {
    $message{send_receive} = "Incoming";
    (my $part1, my $part2) = ($message{start_line} =~ /(\S+)(.*)/);
    $message{label} = $part2;
    $message{label} =~ s/^\s+//;
    $message{desc} = "Received '$message{label}' for $message{user}"
  } elsif($message{type} eq "PUSH_NOTIFICATION_REQ") {
    $message{send_receive} = "Outgoing";
  } else {
    $message{type} = "ERROR";
  }
  queue_push_notification_record(\%message);
}

sub queue_push_notification_record {
  my $params = shift;
  my %message = %$params;
  my $host;
  undef(%record);

  my ($year,$month,$day) = $message{day} =~ /(\d{4})-(\d{1,2})-(\d{1,2})/;
  my ($hour,$minute,$seconds,$milliseconds) = $message{timestamp} =~ /(\d{1,2}):(\d{1,2}):(\d{1,2}),(\d{1,3})?/;
  my $ts = timelocal($seconds,$minute,$hour,$day,$month-1,$year) + $milliseconds/1000;
 
  my $queue_push_records_no = scalar (@queue_push_records);
  $queue_push_records[$queue_push_records_no] = &share({});
  $queue_push_records[$queue_push_records_no]{day} = $message{day};
  $queue_push_records[$queue_push_records_no]{timestamp} = $message{timestamp};
  $queue_push_records[$queue_push_records_no]{time_seconds} = $ts;
  $queue_push_records[$queue_push_records_no]{host} = $message{host};
  $queue_push_records[$queue_push_records_no]{type} = $message{type};
  $queue_push_records[$queue_push_records_no]{send_receive} = $message{send_receive};
  $queue_push_records[$queue_push_records_no]{apns_id} = $message{apns_id};
  $queue_push_records[$queue_push_records_no]{user} = $message{user};
  $queue_push_records[$queue_push_records_no]{desc} = $message{desc};
  $queue_push_records[$queue_push_records_no]{local_host} = $message{local_host};
  $queue_push_records[$queue_push_records_no]{label} = $message{label};
  $queue_push_records[$queue_push_records_no]{message} = $message{message};
}

sub generate_push_notification_record {
  my $params = shift;
  my %message = %$params;
  my $host;
  undef(%record);

  # add the record to the dg_records array
  my $dg_record_no = scalar (@dg_records);
  $dg_records[$dg_record_no] = &share({});
  $dg_records[$dg_record_no] = $params;

  my $filtered = filter_push_notification_message($dg_records[$dg_record_no]);
  if ($filtered == 0) {
    if ($message{send_receive} eq "Outgoing") {
      add_column($message{local_host});
      add_column($message{host});
    } else {
      add_column($message{host});
      add_column($message{local_host});
    }

    # When capturing, if the cursor is in the bottom we refresh the screen
    $dg_record_no = scalar(@display_dg_records);
#print TMP "generate capture_mode: $capture_mode dg_record_no: $dg_record_no\n";
    if ($capture_mode ne "opening_file" && $display_mode ne "details") {
      if ($dg_rec_pos == $dg_record_no-1) {
        $dg_rec_pos = $dg_record_no;
      }
    }
    refresh();
  }
}

sub display_push_notification_details_box {
  my ($w,$h) = @_;
  my $pas;
  my @lines = split("\n",$display_dg_records[$dg_rec_pos-1]{message});
  my $content_pos = 0;
  my $i = 0;
  my $first_line = 1;
  my $extra_lines = 2;
  my $margin = $dg_top_margin;

  $margin = 0 if $full_screen_details;

  # Add the transport top line
  goto_xy(($max_col - $w)/2, $margin + ($max_row-$margin-1 - $h)/2 + 0);
  my $remote_ip = $display_dg_records[$dg_rec_pos-1]{host};
  my $remote = (is_ipv4($remote_ip) ? "" : "[").$remote_ip.(is_ipv4($remote_ip) ? "" : "]");
  my $local_ip = $display_dg_records[$dg_rec_pos-1]{local_host};
  my $local = (is_ipv4($local_ip) ? "" : "[").$local_ip.(is_ipv4($local_ip) ? "" : "]");
  my $src="",$dst="";
  if ($display_dg_records[$dg_rec_pos-1]{send_receive} eq "Incoming") {
    $src = $remote." ";
    $dst .= " ".$local;
  } else {
    $src = $local." ";
    $dst .= " ".$remote;
  }
  $src = sprintf('%*.*s', int(($w-9)/2), int(($w-9)/2), $src);
  $dst = sprintf('%-*.*s', int(($w-9)/2), int(($w-9)/2), $dst);

  print $src.$line_chr.$line_chr.$display_dg_records[$dg_rec_pos-1]{protocol}.$line_chr.$right_arrow_chr.$dst;

  # Add the PUSH message details
  foreach my $line (@lines) {
    $line =~ s/\n//g;
    if (length($line) == 0) {$content_pos = 1;};
    $line =~ s/\r//g;
    $pas = int(length($line)/$w);
    for $j (0 .. $pas) {
      goto_xy(($max_col - $w)/2, $margin + ($max_row-$margin-1 - $h)/2 + $extra_lines + $i - $push_start_line);
      $i++;
      if ($push_start_line+1 <= $i) {
        if ($i-$push_start_line > $h-$extra_lines) {
          goto_xy(($max_col - $w)/2, $margin + ($max_row-$margin-1 - $h)/2 + $extra_lines + $i-2 - $push_start_line);
          print " " x (($w-3)/2) . "..." . " " x (($w-2)/2);
          last;
        } else {
          my $l = substr($line,$w*$j,$w);
          $l =~ s/\t/     /g;
          $l .= " " x ($w-length($l));
          if ($content_pos) {
            $l = colored($l,'bold green');
          } else {
            if ($first_line) {
              $l = colored($l,'red');
            } else {
              if ($j==0) {
                $l =~ s/^(.[^=]*?:)(.*$)/colored($1,'bold blue').$2/e;
              }
            }
          }
          print $l;
        }
      }
    }
    last if $i-$push_start_line > $h-$extra_lines;
    $first_line = 0;
  }
}

sub filter_push_notification_message {
  my $ref = shift;
  my %message = %$ref;
  my $user;
  if ($no_push) {
    if ($message{type} eq "PUSH_NOTIFICATION_REQ" || $message{type} eq "PUSH_NOTIFICATION_RESP") {
      return 1;
    }
  }

  # Filter based on the host IP address
  if ($push_user) {
    $user = $message{user};
    if ($user !~ /($push_user)/) {
      return 1;
    }
  }
  my $dg_record_no = scalar (@display_dg_records);
  $display_dg_records[$dg_record_no] = &share({});
  $display_dg_records[$dg_record_no] = $ref;
  return 0;
}

####################################################
